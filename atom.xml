<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yzhid</title>
  <icon>https://www.gravatar.com/avatar/f20385d9f48ffd0dbe4536638d7a3d29</icon>
  
  <link href="https://lscgx.github.io/atom.xml" rel="self"/>
  
  <link href="https://lscgx.github.io/"/>
  <updated>2020-10-23T01:10:15.587Z</updated>
  <id>https://lscgx.github.io/</id>
  
  <author>
    <name>Yzhid</name>
    <email>dy0407@live.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TESTTETS</title>
    <link href="https://lscgx.github.io/2020/10/23/TESTTETS/"/>
    <id>https://lscgx.github.io/2020/10/23/TESTTETS/</id>
    <published>2020-10-23T00:38:41.000Z</published>
    <updated>2020-10-23T01:10:15.587Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>hdh j h d jh  sh  d</p></blockquote><p><img src="3fa6231c46d2b757dab5e58bde3c305fceb036d4.png" alt="img"></p><p><img src="images\3fa6231c46d2b757dab5e58bde3c305fceb036d4.png" alt="img"></p>]]></content>
    
    
    <summary type="html">orz</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CF1433F F. Zero Remainder Sum [dp]</title>
    <link href="https://lscgx.github.io/2020/10/22/CF1433F/"/>
    <id>https://lscgx.github.io/2020/10/22/CF1433F/</id>
    <published>2020-10-22T02:35:47.000Z</published>
    <updated>2020-10-22T03:40:08.586Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1433/problem/F" target="_blank" rel="noopener">F. Zero Remainder Sum</a></p><p>You are given a matrix a of size n×m consisting of integers.</p><p>You can choose <strong>no more than</strong> $\left\lfloor\frac{m}{2}\right\rfloor$ elements in <strong>each row</strong>. Your task is to choose these elements in such a way that their sum is <strong>divisible by</strong> k and this sum is the <strong>maximum</strong>.</p><p>In other words, you can choose no more than a half (rounded down) of elements in each row, you have to find the maximum sum of these elements divisible by k.</p><p>Note that you can choose zero elements (and the sum of such set is 00).</p><p>Input</p><p>The first line of the input contains three integers n, mm and k (1≤n,m,k≤70) — the number of rows in the matrix, the number of columns in the matrix and the value of k. The next n lines contain mm elements each, where the j-th element of the i-th row is $a_{i,j} (1≤a_{i,j}≤70)$.</p><p>Output</p><p>Print one integer — the maximum sum divisible by k you can obtain.</p><p>Examples</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">5 2 2 2</span><br><span class="line">7 1 1 4</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure><blockquote><p>题意：一个矩阵每一行至多选择$\left\lfloor\frac{m}{2}\right\rfloor$ 个数，且最后总和 sum 能被 k 整除。</p><p>设 $d[i][j][c][r]$ 表示取到第（i，j）个元素，第 i 行取了 c 个时，余数为 r 时的最大值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">70</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,a[MAX][MAX],d[MAX][MAX][MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">sf(n);sf(m);sf(k);</span><br><span class="line">fi(i,<span class="number">0</span>,n) fi(j,<span class="number">0</span>,m) sf(a[i][j]);</span><br><span class="line">mem(d,<span class="number">-0x3f</span>);</span><br><span class="line">d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">0</span>,n) fi(j,<span class="number">0</span>,m) fi(c,<span class="number">0</span>,m/<span class="number">2</span>+<span class="number">1</span>) fi(r,<span class="number">0</span>,k)&#123;</span><br><span class="line"><span class="keyword">if</span>(d[i][j][c][r]==-INF) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(j==m<span class="number">-1</span>)&#123;</span><br><span class="line">d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][r] = max(d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][r],d[i][j][c][r]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">d[i][j+<span class="number">1</span>][c][r] = max(d[i][j+<span class="number">1</span>][c][r],d[i][j][c][r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c&lt;(m/<span class="number">2</span>))&#123;</span><br><span class="line"><span class="keyword">int</span> t = (r+a[i][j])%k;</span><br><span class="line"><span class="keyword">if</span>(j==m<span class="number">-1</span>)&#123;</span><br><span class="line">d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][t] = max(d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][t] ,d[i][j][c][r]+a[i][j]);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">d[i][j+<span class="number">1</span>][c+<span class="number">1</span>][t] = max(d[i][j+<span class="number">1</span>][c+<span class="number">1</span>][t],d[i][j][c][r]+a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pfn(d[n][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CF1433F F. Zero Remainder Sum [dp]</summary>
    
    
    
    <category term="算法" scheme="https://lscgx.github.io/categories/算法/"/>
    
    <category term="题解" scheme="https://lscgx.github.io/categories/算法/题解/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>CF1365D Solve The Maze [ dfs ]</title>
    <link href="https://lscgx.github.io/2020/09/26/CF1365D/"/>
    <id>https://lscgx.github.io/2020/09/26/CF1365D/</id>
    <published>2020-09-26T14:47:12.000Z</published>
    <updated>2020-09-26T15:02:04.647Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1365/problem/D" target="_blank" rel="noopener">CF1365D Solve The Maze </a></p><p>Vivek has encountered a problem. He has a maze that can be represented as an n×m grid. Each of the grid cells may represent the following:</p><ul><li>Empty — ‘.’</li><li>Wall — ‘#’</li><li>Good person  — ‘G’</li><li>Bad person — ‘B’</li></ul><p>The only escape from the maze is at cell (n,m)(n,m).</p><p>A person can move to a cell only if it shares a side with their current cell and does not contain a wall. Vivek wants to block some of the empty cells by replacing them with walls in such a way, that all the good people are able to escape, while none of the bad people are able to. A cell that initially contains ‘G’ or ‘B’ <strong>cannot be blocked</strong> and <strong>can be travelled through</strong>.</p><p>Help him determine if there exists a way to replace some (zero or more) empty cells with walls to satisfy the above conditions.</p><p><strong>It is guaranteed that the cell (n,m) is empty.</strong> Vivek can also block this cell.</p><p>Input</p><p>The first line contains one integer t (1≤t≤100) — the number of test cases. The description of the test cases follows.</p><p>The first line of each test case contains two integers n, m (1≤n,m≤50)— the number of rows and columns in the maze.</p><p>Each of the next n lines contain mm characters. They describe the layout of the maze. If a character on a line equals ‘.’, the corresponding cell is empty. If it equals ‘#’, the cell has a wall. ‘G’ corresponds to a good person and ‘B’ corresponds to a bad person.</p><p>Output</p><p>For each test case, print “Yes” if there exists a way to replace some empty cells with walls to satisfy the given conditions. Otherwise print “No”</p><p>You may print every letter in any case (upper or lower).</p><p>Example</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 1</span><br><span class="line">.</span><br><span class="line">1 2</span><br><span class="line">G.</span><br><span class="line">2 2</span><br><span class="line">#B</span><br><span class="line">G.</span><br><span class="line">2 3</span><br><span class="line">G.#</span><br><span class="line">B#.</span><br><span class="line">3 3</span><br><span class="line">#B.</span><br><span class="line">#..</span><br><span class="line">GG.</span><br><span class="line">2 2</span><br><span class="line">#B</span><br><span class="line">B.</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><blockquote><p>题意：一个网格上有好人有坏人，放置一些墙，使得只有好人能到达 （n,m）</p><p>可以观察到：</p><p>1、好人G 到达终点的路径上不能出现坏人 B, 显然。</p><p>2、坏人旁边不能有好人</p><p>所以可以这样处理：</p><p>1、先判断所有的好人是否可以不经过坏人到达终点，不可以则输出 “NO”。</p><p>2、然后处理所有坏人，将每一个坏人周围为 “.” 的全改为 “#” ，“B” 不处理，但是如果有 “G” 则不可行。因为经过上一步的处理，所有的好人都是不经过坏人到达终点的，所以此坏人B也是可以到达终点。</p><p>3、再次判断是否所有的好人能否都到达终点。</p><p>需要优化的地方是: 对于已经判断可以到达的点，后续再次经过时，可直接跳出。另 dfs 也需即时跳出。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">50</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,gx[<span class="number">3000</span>],gy[<span class="number">3000</span>],bx[<span class="number">3000</span>],by[<span class="number">3000</span>],gl,bl;</span><br><span class="line"><span class="keyword">int</span> vis[MAX][MAX],rev[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,ok=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ok) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x==n &amp;&amp; y==m) &#123;</span><br><span class="line">ok = <span class="number">1</span>;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tx = x + aw[i][<span class="number">0</span>],ty = y + aw[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(judge(tx,ty) &amp;&amp; vis[tx][ty] != key&amp;&amp;a[tx][ty]!=<span class="string">'#'</span>&amp;&amp;a[tx][ty]!=<span class="string">'B'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[tx][ty]) &#123;</span><br><span class="line">ok =<span class="number">1</span> ;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[tx][ty]=key; </span><br><span class="line">dfs(tx,ty,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">sf(n);sf(m);</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">gl=bl=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">'G'</span>) &#123;</span><br><span class="line">gx[gl] = i; gy[gl++] = j;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'B'</span>)&#123;</span><br><span class="line">bx[bl] = i;by[bl++] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">mem(vis,<span class="number">0</span>);mem(rev,<span class="number">0</span>);</span><br><span class="line">fi(i,<span class="number">0</span>,gl)&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line">dfs(gx[i],gy[i],i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ok) &#123;</span><br><span class="line">cnt++;rev[gx[i]][gy[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt!=gl)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bl==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ok =<span class="number">1</span>;</span><br><span class="line">fi(i,<span class="number">0</span>,bl)&#123;</span><br><span class="line">ok = <span class="number">1</span>;</span><br><span class="line">fi(j,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> tx = bx[i] + aw[j][<span class="number">0</span>],ty = by[i] + aw[j][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(judge(tx,ty) )&#123;</span><br><span class="line"><span class="keyword">if</span>(a[tx][ty]==<span class="string">'.'</span>) a[tx][ty] = <span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[tx][ty]==<span class="string">'G'</span>)&#123;</span><br><span class="line">ok =<span class="number">0</span> ;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ok) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ok) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">mem(vis,<span class="number">0</span>);mem(rev,<span class="number">0</span>);</span><br><span class="line">fi(i,<span class="number">0</span>,gl)&#123;</span><br><span class="line">ok=<span class="number">0</span>;</span><br><span class="line">dfs(gx[i],gy[i],i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ok) &#123;cnt++;rev[gx[i]][gy[i]] = <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt!=gl)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CF1365D Solve The Maze</summary>
    
    
    
    <category term="算法" scheme="https://lscgx.github.io/categories/算法/"/>
    
    <category term="题解" scheme="https://lscgx.github.io/categories/算法/题解/"/>
    
    
    <category term="dfs" scheme="https://lscgx.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>CF1339D Edge Weight Assignment [ 构造贪心 ]</title>
    <link href="https://lscgx.github.io/2020/09/26/CF1339D/"/>
    <id>https://lscgx.github.io/2020/09/26/CF1339D/</id>
    <published>2020-09-26T04:30:33.000Z</published>
    <updated>2020-09-26T04:49:57.022Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1339/problem/D" target="_blank" rel="noopener">CF1339D Edge Weight Assignment</a></p><p>You have unweighted tree of n vertices. You have to assign a <strong>positive</strong> weight to each edge so that the following condition would hold:</p><ul><li>For every two different leaves v1 and v2 of this tree, <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR" target="_blank" rel="noopener">bitwise XOR</a> of weights of all edges on the simple path between v1 and v2 has to be equal to 0.</li></ul><p>Note that you can put <strong>very large</strong> positive integers (like $10^{10}$).</p><p>It’s guaranteed that such assignment always exists under given constraints. Now let’s define f as <strong>the number of distinct weights</strong> in assignment.</p><p><img src="822324016e7a6837336849481ecbe0190b03dfa3.png" alt="img"></p><p>In this example, assignment is valid, because bitwise XOR of all edge weights between every pair of leaves is 0. ff value is 2 here, because there are 2 distinct edge weights(4 and 5).</p><p><img src="82d52d5070be134d11729e65fab0a8709aae6b3f.png" alt="img"></p><p>In this example, assignment is invalid, because bitwise XOR of all edge weights between vertex 1 and vertex 6 (3,4,5,4) is not 0.</p><p>What are the minimum and the maximum possible values of f for the given tree? Find and print both.</p><p>Input</p><p>The first line contains integer n ($3≤n≤10^5$) — the number of vertices in given tree.</p><p>The ii-th of the next n−1 lines contains two integers ai and bi ($1≤ai&lt;bi≤n$) — it means there is an edge between ai and bi. It is guaranteed that given graph forms tree of n vertices.</p><p>Output</p><p>Print two integers — the minimum and maximum possible value of f can be made from valid assignment of given tree. Note that it’s always possible to make an assignment under given constraints.</p><p>Examples</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br></pre></td></tr></table></figure><blockquote><p>首先找到一个度为 1 的点作为树根构造树。记录每个节点的深度 d[i] 和其到其最深的叶子节点的距离 l[i]</p><p>可以观察到：</p><p>对于可分配的最大值有</p><p>1、一个父亲节点的所有 $l[i] = 1$ 的子节点一共可以分配一个值（因为之前的路径上的值是已经分配好的，要想 XOR 为 0, 这里必须分配同一个值），其他的可以各自分配一个。有一个例外就是 当 $d[i] &lt;= 3$ 因为到根节点的距离 = 2，所以不分配新的值。</p><p>对于可分配的最小值有</p><p>1、如果根到某一个叶子节点的边数为偶数，则分配一个值足以。</p><p>2、如果为奇数，则最多需要三个。简单证明：$x = 3 + x’$  , $x 为奇数x’ 为偶数$ 偶数分配一个值，三个奇数需要三个值，总的下来需要三个值。</p><p>所以可以这样判断，对于所有不为根的叶子节点如果有奇数，则可分配的最小值为 3，否则 为1。2 的话显然可以用 1 替换。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,sz[MAX],rt=<span class="number">0</span>,vis[MAX],l[MAX],d[MAX],_min=<span class="number">1</span>,_max=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">e[tot].to = v;</span><br><span class="line">e[tot].next = head[u];</span><br><span class="line">head[u] = tot++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>;</span><br><span class="line">l[u] = max(l[u],dfs(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> l[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ++l[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> zo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(l[v] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(zo &amp;&amp; d[v]&gt;<span class="number">3</span>)&#123;</span><br><span class="line">zo = <span class="number">0</span>;</span><br><span class="line">_max ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(l[v]&gt;<span class="number">0</span>) _max++;</span><br><span class="line">dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">mem(head,<span class="number">-1</span>);mem(sz,<span class="number">0</span>);mem(vis,<span class="number">0</span>);mem(l,<span class="number">0</span>);</span><br><span class="line">sf(n);</span><br><span class="line">fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">sf(a);sf(b);</span><br><span class="line">addedge(a,b);addedge(b,a);</span><br><span class="line">sz[a]++;sz[b]++;</span><br><span class="line">&#125;</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(sz[i]==<span class="number">1</span>) &#123;</span><br><span class="line">rt = i; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">d[rt] = <span class="number">1</span>;</span><br><span class="line">dfs(rt);</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(sz[i] == <span class="number">1</span> &amp;&amp; i != rt &amp;&amp; (d[i]<span class="number">-1</span>) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">_min = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mem(vis,<span class="number">0</span>);</span><br><span class="line">dfs2(rt);</span><br><span class="line">pf(_min);pfc(<span class="string">" "</span>);pfn(_max);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CF1339D Edge Weight Assignment</summary>
    
    
    
    <category term="算法" scheme="https://lscgx.github.io/categories/算法/"/>
    
    <category term="题解" scheme="https://lscgx.github.io/categories/算法/题解/"/>
    
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
    <category term="dfs" scheme="https://lscgx.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>CF1370D D. Odd-Even Subsequence [ 二分 ]</title>
    <link href="https://lscgx.github.io/2020/06/21/CF1370D/"/>
    <id>https://lscgx.github.io/2020/06/21/CF1370D/</id>
    <published>2020-06-21T05:14:28.000Z</published>
    <updated>2020-06-21T05:22:06.726Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1370/problem/D" target="_blank" rel="noopener">D. Odd-Even Subsequence</a></p><p>题意： 对于数列 a , 找出数列的子序列 s , 使得 $min(max(s_1, s_3,       s_5, \ldots), max(s_2, s_4, s_6, \ldots))$ 最小。</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 4</span><br><span class="line">5 3 50 2 4 5</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>首先，奇偶交替是一定的，所以可以选择一个奇下标元素后再选择偶的。</p><p>假定最小元素在奇序列中，</p><p>二分答案，遍历原序列 a，观察是否可以组成长度 &gt; k 满足所有元素都小于 x 的子序列。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,k,a[MAX],l=INF,r=<span class="number">0</span>,ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;=x)&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(n);sf(k);</span><br><span class="line">fi(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">sf(a[i]);</span><br><span class="line">l = min(l,a[i]);</span><br><span class="line">r = max(r,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(f(m,<span class="number">0</span>) || f(m,<span class="number">1</span>))&#123;</span><br><span class="line">ans = m;</span><br><span class="line">r = m<span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l = m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pf(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">D. Odd-Even Subsequence</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
    <category term="二分" scheme="https://lscgx.github.io/tags/二分/"/>
    
    <category term="二分答案" scheme="https://lscgx.github.io/tags/二分答案/"/>
    
  </entry>
  
  <entry>
    <title>CF1363E Tree Shuffling [ dfs ]</title>
    <link href="https://lscgx.github.io/2020/06/04/CF1363E/"/>
    <id>https://lscgx.github.io/2020/06/04/CF1363E/</id>
    <published>2020-06-04T09:02:30.000Z</published>
    <updated>2020-06-04T09:18:16.507Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1363/problem/E" target="_blank" rel="noopener">CF1363E Tree Shuffling</a></p><p>题意：Ashish has a tree consisting of n nodes numbered 1 to n rooted at node 1. The ii-th node in the tree has a cost a[i], and binary digit b[i] is written in it. He wants to have binary digit c[i] written in the i-th node in the end.</p><p>To achieve this, he can perform the following operation any number of times:</p><p>Select any k nodes from the subtree of any node u, and shuffle the digits in these nodes as he wishes, incurring a cost of k⋅a[u]. Here, he can choose k ranging from 1 to the size of the subtree of u.</p><p>He wants to perform the operations in such a way that every node finally has the digit corresponding to its target.</p><p>Help him find the minimum total cost he needs to spend so that after all the operations, every node u has digit c[u] written in it, or determine that it is impossible.</p><p><img src="02ed56cecf6dea5880ad08c321cf503b04888bd7.png" alt="img"></p><p>Examples</p><p>input1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 0 1</span><br><span class="line">20 1 0</span><br><span class="line">300 0 1</span><br><span class="line">4000 0 0</span><br><span class="line">50000 1 0</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><p>output1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>input2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10000 0 1</span><br><span class="line">2000 1 0</span><br><span class="line">300 0 1</span><br><span class="line">40 0 0</span><br><span class="line">1 1 0</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><p>output2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24000</span><br></pre></td></tr></table></figure><blockquote><p>显然可以观察到： 当一个节点拥有 0 需要 1 时，可以看作整体拥有一个 “0” 资源，对于 1 同理；</p><p>所以只有当两个相等是才是有解的。</p><p>可以观察到，当在某一个节点 u 操作时</p><p>1、此时的代价应为 u 到root 路径上最小代价，此时有两种方法，一是提前计算出在某节点操作的最小代价；二是将操作推迟到最小处再执行</p><p>2、当节点 u 的子节点操作后，该节点 u 所拥有的 0/1 个数是变化的，可以在递归回溯的时候更新</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,u,v;</span><br><span class="line">vi g[MAX];</span><br><span class="line">ll a[MAX],b[MAX],c[MAX],vis[MAX],fa[MAX],m[MAX],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,ll _min)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">fi(i,<span class="number">0</span>,g[u].size())&#123;</span><br><span class="line"><span class="keyword">int</span> v=g[u][i];</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">fa[v]=u;</span><br><span class="line">m[v]=min(m[v],_min);</span><br><span class="line">dfs(v,m[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">pii <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">pii cnt;</span><br><span class="line"><span class="keyword">if</span>(b[u]!=c[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(b[u]) cnt.first++;</span><br><span class="line"><span class="keyword">else</span> cnt.second++;</span><br><span class="line">&#125;</span><br><span class="line">fi(i,<span class="number">0</span>,g[u].size())&#123;</span><br><span class="line"><span class="keyword">int</span> v=g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">pii res= dfs2(v);</span><br><span class="line">cnt.first+=res.first;</span><br><span class="line">cnt.second+=res.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[u]&lt;=m[u])&#123;</span><br><span class="line"><span class="keyword">int</span> tmp =  min(cnt.first, cnt.second);</span><br><span class="line">ans += <span class="number">2</span>*tmp*a[u];</span><br><span class="line">cnt.first-=tmp;</span><br><span class="line">cnt.second-=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(n);</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">m[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">sf(u);sf(v);</span><br><span class="line">g[u].pb(v);g[v].pb(u);</span><br><span class="line">&#125;</span><br><span class="line">mem(vis,<span class="number">0</span>);mem(fa,<span class="number">0</span>);</span><br><span class="line">dfs(<span class="number">1</span>,a[<span class="number">1</span>]);</span><br><span class="line">pii res=dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(res.first||res.second)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Tree Shuffling</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
    <category term="dfs" scheme="https://lscgx.github.io/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>CF1359D Yet Another Yet Another Task [ dp ]</title>
    <link href="https://lscgx.github.io/2020/05/31/CF1359D/"/>
    <id>https://lscgx.github.io/2020/05/31/CF1359D/</id>
    <published>2020-05-31T12:59:04.000Z</published>
    <updated>2020-05-31T13:03:33.386Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1359/problem/D" target="_blank" rel="noopener">D. Yet Another Yet Another Task</a></p><p>题意：一个数列，找字段和去除段内最大值后最大的区间；</p><blockquote><p>枚举最大值 _max，对于有比 _max 大的区间都不考虑，在此基础上求最大字段和</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a[MAX],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(n);</span><br><span class="line">fi(i,<span class="number">0</span>,n) sf(a[i]);</span><br><span class="line">fi(_max,<span class="number">1</span>,<span class="number">31</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> em=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp= a[i]&gt;_max?-INF:a[i];</span><br><span class="line">em=max(em,<span class="number">0</span>)+tmp;</span><br><span class="line">res=max(res,em);</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans,res-_max);</span><br><span class="line">&#125;</span><br><span class="line">pfn(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Yet Another Yet Another Task [ dp ]</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
    <category term="枚举" scheme="https://lscgx.github.io/tags/枚举/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P1005 矩阵取数 [ 高精 dp ]</title>
    <link href="https://lscgx.github.io/2020/05/06/%E6%B4%9B%E8%B0%B7P1005/"/>
    <id>https://lscgx.github.io/2020/05/06/%E6%B4%9B%E8%B0%B7P1005/</id>
    <published>2020-05-06T09:57:46.000Z</published>
    <updated>2020-05-06T10:05:17.696Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1005" target="_blank" rel="noopener">P1005 矩阵取数</a></p><p><strong>题目描述</strong></p><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 n<em>×</em>m 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：</p><ol><li>每次取数时须从每行各取走一个元素，共 n 个。经过 m 次后取完矩阵内所有元素；</li><li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li><li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 ×2^i，其中 <em>i</em> 表示第 <em>i</em> 次取数（从 1 开始编号）；</li><li>游戏结束总得分为 m 次取数得分之和。</li></ol><p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p><p><strong>输入输出格式</strong></p><p>输入文件包括 n+1 行：</p><p>第一行为两个用空格隔开的整数 n 和 m。</p><p>第 2∽<em>n</em>+1 行为 n<em>×</em>m 矩阵，其中每行有 m 个用单个空格隔开的非负整数。</p><p><strong>输出格式</strong></p><p>输出文件仅包含1行，为一个整数，即输入矩阵取数后的最大得分。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 2 3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">82</span><br></pre></td></tr></table></figure><p><strong>HINT</strong></p><p>NOIP 2007 提高第三题。</p><p>数据范围：</p><p>60% 的数据满足：1≤<em>n</em>,<em>m</em>≤30，答案不超过 $10^{16}$。</p><p>100% 的数据满足：1≤<em>n</em>,<em>m</em>≤80，$0≤a_{ij}≤1000$。</p><blockquote><p>区间dp, 题目是取的，逆着放就可以了。。</p><p>然后就是预处理出2的幂，保存起来，<strong>用高精！</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll a[MAX][MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MOD=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],len;</span><br><span class="line">bigint()&#123;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">len = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">bigint(ll x)&#123;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">a[len++]=x%MOD;</span><br><span class="line">x/=MOD;</span><br><span class="line">&#125;<span class="keyword">while</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> bigint &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len&lt;b.len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(len&gt;b.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;b.a[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;b.a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">bigint <span class="keyword">operator</span> + (<span class="keyword">const</span> bigint &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">bigint res;</span><br><span class="line">res.len=max(len,b.len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)&#123;</span><br><span class="line">res.a[i]+=((i&lt;len)?a[i]:<span class="number">0</span>)+((i&lt;b.len)?b.a[i]:<span class="number">0</span>);</span><br><span class="line">res.a[i+<span class="number">1</span>]+=res.a[i]/MOD;</span><br><span class="line">res.a[i]%=MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res.a[res.len]&gt;<span class="number">0</span>) res.len++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">bigint <span class="keyword">operator</span> * (<span class="keyword">const</span> bigint &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">bigint res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> up=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=a[i]*b.a[j] + res.a[i+j]+up;</span><br><span class="line">res.a[i+j] = tmp % MOD;</span><br><span class="line">up = tmp / MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(up) res.a[i+b.len] = up;</span><br><span class="line">&#125;</span><br><span class="line">res.len =len + b.len; </span><br><span class="line"><span class="keyword">while</span>(res.a[res.len <span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; res.len &gt;<span class="number">1</span>) res.len--;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[len<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%04d"</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bigint f[MAX][MAX],ans,p2[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">p2[<span class="number">0</span>]=bigint(<span class="number">1</span>);</span><br><span class="line">fi(i,<span class="number">1</span>,MAX) p2[i]=p2[i<span class="number">-1</span>]*bigint(<span class="number">2</span>);</span><br><span class="line">sf(n);sf(m);</span><br><span class="line">fi(i,<span class="number">0</span>,n)</span><br><span class="line">fi(j,<span class="number">0</span>,m) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i][j]);</span><br><span class="line">fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">fi(j,<span class="number">0</span>,m) f[j][j]=bigint(a[i][j])*p2[m];</span><br><span class="line">fi(k,<span class="number">2</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">fi(j,<span class="number">0</span>,m-k+<span class="number">1</span>)&#123; </span><br><span class="line"><span class="keyword">int</span> e = j + k - <span class="number">1</span>;</span><br><span class="line">bigint t1 = f[j+<span class="number">1</span>][e] + bigint(a[i][j])*p2[m-k+<span class="number">1</span>];</span><br><span class="line">bigint t2 = f[j][e<span class="number">-1</span>] + bigint(a[i][e])*p2[m-k+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(t1&lt;t2) f[j][e] = t2;</span><br><span class="line"><span class="keyword">else</span> f[j][e] = t1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = ans + f[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans.print();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">洛谷 P1005 矩阵取数 [ 高精 dp ]</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
    <category term="高精度" scheme="https://lscgx.github.io/tags/高精度/"/>
    
  </entry>
  
  <entry>
    <title>洛谷p1941飞扬的小鸟[ dp ]</title>
    <link href="https://lscgx.github.io/2020/05/06/%E6%B4%9B%E8%B0%B7p1941/"/>
    <id>https://lscgx.github.io/2020/05/06/%E6%B4%9B%E8%B0%B7p1941/</id>
    <published>2020-05-06T01:58:36.000Z</published>
    <updated>2020-05-06T02:27:12.140Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1941" target="_blank" rel="noopener">P1941 飞扬的小鸟</a></p><p><strong>题目描述</strong></p><p><code>Flappy Bird</code> 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。</p><p>为了简化问题，我们对游戏规则进行了简化和改编:</p><p>游戏界面是一个长为 <em>n</em>，高为 m 的二维平面，其中有 <em>k</em> 个管道（忽略管道的宽度）。</p><p>小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。</p><p>小鸟每个单位时间沿横坐标方向右移的距离为 1，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 <em>x</em>，<strong>每个单位时间可以点击多次</strong>，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 y<em>。小鸟位于横坐标方向不同位置时，上升的高度 x 和下降的高度 </em>y* 可能互不相同。</p><p>小鸟高度等于 0 或者小鸟碰到管道时，游戏失败。<strong>小鸟高度为 m 时，无法再上升</strong>。</p><p>现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。</p><p><strong>输入格式</strong></p><p>第 1 行有 3 个整数 n, m, k，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；</p><p>接下来的 n 行，每行 2 个用一个空格隔开的整数 <em>x</em> 和 y<em>，依次表示在横坐标位置 0∼</em>n<em>−1 上玩家点击屏幕后，小鸟在下一位置上升的高度 x</em>，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度 y。</p><p>接下来 k 行，每行 3 个整数 p,l,h，每两个整数之间用一个空格隔开。每行表示一个管道，其中 p 表示管道的横坐标，l 表示此管道缝隙的下边沿高度，h 表示管道缝隙上边沿的高度（输入数据保证 <em>p</em> 各不相同，但不保证按照大小顺序给出）。</p><p><strong>输出格式</strong></p><p>共两行。</p><p>第一行，包含一个整数，如果可以成功完成游戏，则输出 1，否则输出 0。</p><p>第二行，包含一个整数，如果第一行为 1，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10 10 6 </span><br><span class="line">3 9  </span><br><span class="line">9 9  </span><br><span class="line">1 2  </span><br><span class="line">1 3  </span><br><span class="line">1 2  </span><br><span class="line">1 1  </span><br><span class="line">2 1  </span><br><span class="line">2 1  </span><br><span class="line">1 6  </span><br><span class="line">2 2  </span><br><span class="line">1 2 7 </span><br><span class="line">5 1 5 </span><br><span class="line">6 3 5 </span><br><span class="line">7 5 8 </span><br><span class="line">8 7 9 </span><br><span class="line">9 1 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">10 10 4 </span><br><span class="line">1 2  </span><br><span class="line">3 1  </span><br><span class="line">2 2  </span><br><span class="line">1 8  </span><br><span class="line">1 8  </span><br><span class="line">3 2  </span><br><span class="line">2 1  </span><br><span class="line">2 1  </span><br><span class="line">2 2  </span><br><span class="line">1 2  </span><br><span class="line">1 0 2 </span><br><span class="line">6 7 9 </span><br><span class="line">9 1 4 </span><br><span class="line">3 8 10</span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><img src="1348.png" alt="img"></p><blockquote><p>$f[i][j]$ 表示前 i 个管子高度为 j 的最小代价，</p><p>注意题目，向上，每个单位时间内可以点击多次，所以有 </p><p>$f[i][j]=min(f[i-1][j-k*x[i]]+k,f[i][j])$</p><p>复杂度 $ O(nm^2)$ ,T le..</p><p>因为是从下往上计算的，那么有$f[i][j]=f[i][j-x[i]]+1$</p><p>所以更新一下：$f[i][j]=min(f[i-1][j-x[i]],f[i][j-x[i]])+1$</p><p>观察上面的式子，$f[i-1][j-x[i]],f[i][j-x[i]]$ 第二维是相同的，如果 $l[i]+1&lt;= j &lt;= h[i]-1$</p><p>那么 $f[i-1][j-2*x[i]]$ 可能错过，所以 $x[i]&lt;= j &lt;= h[i]-1$</p><p>然后又有问题了…因为上年多计算了，导致一些存在管道的地方也有值了，本来是不能到达的…</p><p>所以，计算完后，把不属于  $[l[i]+1,h[i]-1]$ 赋值 INF 。</p><p>下面的同理。</p><p>向下的话，显然只能有一种情况 $f[i][j]=min(f[i][j],f[i-1][j+y[i]]),(j+y[i]&lt;=m)$</p><p>当 j == m 的时候，因为到顶就不上升，有</p><p>$f[i][m]=min(f[i][m],min(f[i-1][m-j],f[i][m-j])+1)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,p,l[MAX],h[MAX],x[MAX],y[MAX],ans,cnt,flag;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10100</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">sf(n);sf(m);sf(k);</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>) &#123;</span><br><span class="line">sf(x[i]);sf(y[i]);</span><br><span class="line">&#125;</span><br><span class="line">mem(l,<span class="number">0</span>);mem(h,<span class="number">0x3f</span>);</span><br><span class="line">fi(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">sf(p);sf(l[p]);sf(h[p]);</span><br><span class="line">&#125;</span><br><span class="line">mem(f,<span class="number">0x3f</span>);</span><br><span class="line">fi(i,<span class="number">0</span>,<span class="number">2</span>*m) f[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">fi(j,<span class="number">1</span>,min(m+<span class="number">1</span>,h[i])) &#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=x[i]) f[i][j] = min(f[i][j-x[i]],f[i<span class="number">-1</span>][j-x[i]]) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(f[i][j]&lt;INF) flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fi(j,m-x[i],m+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(m&lt;=h[i])f[i][m]=min(f[i][m],min(f[i][j],f[i<span class="number">-1</span>][j])+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(f[i][m]&lt;INF) flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fi(j,l[i]+<span class="number">1</span>,min(m+<span class="number">1</span>,h[i])) &#123;</span><br><span class="line"><span class="keyword">if</span>(j+y[i] &lt;= m) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j+y[i]]);</span><br><span class="line"><span class="keyword">if</span>(f[i][j]&lt;INF) flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fi(j,<span class="number">0</span>,l[i]+<span class="number">1</span>) f[i][j]=INF;</span><br><span class="line">fi(j,h[i],m+<span class="number">1</span>) f[i][j]=INF;</span><br><span class="line"><span class="keyword">if</span>(h[i]&lt;=m)&#123;</span><br><span class="line"><span class="keyword">if</span>(flag) cnt ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">ans =INF;</span><br><span class="line">fi(j,<span class="number">0</span>,m+<span class="number">1</span>) ans = min(ans,f[n][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n%d"</span>,ans); </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0\n%d"</span>,cnt); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">飞扬的小鸟</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 T126840 加密通信 [ gcd ]</title>
    <link href="https://lscgx.github.io/2020/05/04/%E6%B4%9B%E8%B0%B7T126840/"/>
    <id>https://lscgx.github.io/2020/05/04/%E6%B4%9B%E8%B0%B7T126840/</id>
    <published>2020-05-04T11:54:17.000Z</published>
    <updated>2020-05-04T12:05:04.071Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/T126840?contestId=28335" target="_blank" rel="noopener">加密通信</a></p><p><strong>题目描述</strong></p><p>首先，八意永琳会写出需要被加密的明文 <em>A</em> ，此段明文由 <em>n</em>−1 个正整数构成。</p><p>之后，她会构造出一个由 n 个<strong>质数</strong>构成的密文 B*，满足对 $\forall  i ∈[1, n),B_i×B_{i+1}=A_i$ 。</p><p>为了提高信息的利用率，八意永琳规定 <em>B</em> 中出现的所有质数的值必须在 [1,M] 范围内。</p><p><strong>输入格式</strong></p><p>第一行一个整数 <em>T</em> , 表示需要被加密的明文的组数。</p><p>对于每组明文：</p><p>第一行两个整数 n,M ，代表明文的长度+1，也即所求密文的长度和可出现质数的最大值。</p><p>接下来一行 n - 1 个由空格隔开的正整数，代表明文 A*。</p><p><strong>输出格式</strong></p><p>对于每组明文，均输出一行：</p><ul><li>若有解，输出<strong>任意一组</strong>合法密文 B<em>B</em> 即可，密文中的 n* 个质数以空格隔开。</li><li>若无解，输出 <code>-1</code>。</li></ul><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4 233</span><br><span class="line">55 35 77</span><br><span class="line">4 5</span><br><span class="line">55 35 77</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11 5 7 11 </span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h4 id="数据保证："><a href="#数据保证：" class="headerlink" title="数据保证："></a>数据保证：</h4><ul><li>若不考虑 b_i 在 [1,M] 范围内的条件，必然有至少一组合法解。</li><li>有至少一对 (i,j)，使得 $a_i \ne a_{i+1}$ 。</li></ul><p><a href="https://www.luogu.com.cn/blog/chenxinyang2006/di-yue-jia-mi-tong-xin-ti-xie" target="_blank" rel="noopener"><strong>题解</strong></a></p><blockquote><p>题目数据保证，至少有一对  $a_i \ne a_{i+1}$。</p><p>因为 $a_i$ 都是两个质数相乘的形式， $a_i \ne a_{i+1}$，所以 $a_i$ 和 $a_{i+1}$ 至多只有一个公因子，所以 $b_i=gcd(a_i,a_{i+1})$ 。</p><p>从不相等的这处开始向两边扩展。</p></blockquote>]]></content>
    
    
    <summary type="html">gcd</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="数学" scheme="https://lscgx.github.io/tags/数学/"/>
    
    <category term="构造" scheme="https://lscgx.github.io/tags/构造/"/>
    
  </entry>
  
  <entry>
    <title>CF1348D Phoenix and Science [ 贪心+二分 ]</title>
    <link href="https://lscgx.github.io/2020/05/02/CF1348D/"/>
    <id>https://lscgx.github.io/2020/05/02/CF1348D/</id>
    <published>2020-05-02T09:21:35.000Z</published>
    <updated>2020-05-02T09:34:58.278Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1348/problem/D" target="_blank" rel="noopener">D. Phoenix and Science</a></p><p>Phoenix has decided to become a scientist! He is currently investigating the growth of bacteria.</p><p>Initially, on day 1, there is one bacterium with mass 1.</p><p>Every day, some number of bacteria will split (possibly zero or all). When a bacterium of mass m splits, it becomes two bacteria of mass m/2 each. For example, a bacterium of mass 3 can split into two bacteria of mass 1.5.</p><p>Also, every night, the mass of every bacteria will increase by one.</p><p>Phoenix is wondering if it is possible for the total mass of all the bacteria to be exactly n. If it is possible, he is interested in the way to obtain that mass using the minimum possible number of nights. Help him become the best scientist!</p><p>Example</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 0 2 </span><br><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><blockquote><p>考虑增量，设最小需要 k 天， 那么第 i 天共收益 (k - i + 1) * c[i] , c[i] 为第 i 天有多少细菌。</p><p>可以观察到：</p><p>1、已经存在的细菌，产生的收益已经固定。即如果一个细菌已经存在，那么一次性计算出所有收益。</p><p>2、第 i 天，新增加的细菌数量为 ( 0 ~ c[i-1] ) , 设新增 x 个，如果  x * (k - i + 1)  &lt;= n (n 为还需要多少),那么就新增。这样不会影响最后结果，因为可以选择后面不在新增（分裂）。</p><p>贪心：k 次循环，每次二分计算出当前最多可以分裂多少。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">sf(n);</span><br><span class="line">n--;sum=<span class="number">0</span>;</span><br><span class="line">db k = log2(n+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> tmp = (<span class="keyword">int</span>)k;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;tmp == n+<span class="number">2</span>) tmp--; <span class="comment">//天数</span></span><br><span class="line">pfn(tmp);</span><br><span class="line"><span class="keyword">if</span>(tmp==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>) &#123;</span><br><span class="line">pfc(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> last = <span class="number">1</span>;</span><br><span class="line">n -= tmp; </span><br><span class="line">fi(i,<span class="number">1</span>,tmp+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>,r = last,m,g;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">m = (l+r)/<span class="number">2</span>;</span><br><span class="line">g = m * (tmp-i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(g==n)&#123;</span><br><span class="line">r = m;<span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(g &lt; n )&#123;</span><br><span class="line">l = m+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">r = m<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r * (tmp-i+<span class="number">1</span>) &lt;= n)&#123;</span><br><span class="line">n -= r * (tmp-i+<span class="number">1</span>) ;</span><br><span class="line">last += r;</span><br><span class="line">pf(r);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">pfc(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">pfc(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">pfc(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Phoenix and Science</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
    <category term="二分" scheme="https://lscgx.github.io/tags/二分/"/>
    
  </entry>
  
  <entry>
    <title>CF1348C Phoenix and Distribution [ 贪心 ]</title>
    <link href="https://lscgx.github.io/2020/05/02/CF1348C/"/>
    <id>https://lscgx.github.io/2020/05/02/CF1348C/</id>
    <published>2020-05-02T05:35:25.000Z</published>
    <updated>2020-05-02T05:49:00.853Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1348/problem/C" target="_blank" rel="noopener">C. Phoenix and Distribution</a></p><p>Phoenix has a string s consisting of lowercase Latin letters. He wants to distribute all the letters of his string into k <strong>non-empty</strong> strings a1,a2,…,ak such that every letter of s goes to exactly one of the strings ai. The strings ai <strong>do not</strong> need to be substrings of s. Phoenix can distribute letters of s and rearrange the letters within each string ai however he wants.</p><p>For example, if s= abba and k=2, Phoenix may distribute the letters of his string in many ways, such as:</p><ul><li>ba and ba</li><li>a and abb</li><li>ab and ab</li><li>aa and bb</li></ul><p>But these ways are invalid:</p><ul><li>baa and ba</li><li>b and ba</li><li>baba and empty string (ai should be non-empty)</li></ul><p>Phoenix wants to distribute the letters of his string s into k strings a1,a2,…,ak to <strong>minimize</strong> the lexicographically maximum string among them, i. e. minimize max(a1,a2,…,ak). Help him find the optimal distribution and print the minimal possible value of max(a1,a2,…,ak).</p><p>String x is lexicographically less than string y if either x is a prefix of y and x≠y, or there exists an index i (1≤i≤min(|x|,|y|)) such that xi &lt; yi and for every j (1≤j&lt;i) xj=yj. Here |x|denotes the length of the string x.</p><p><strong>题意：</strong> 将一组字符方程 k 份，使得字典序最大的一组最小。</p><blockquote><p>可以观察到：</p><p>1、k 组的首字母应当最小，如果 k 组首字母有不同的。那么最大值就这个较大的字母，因为可以把其他所有字母加到别的组后面，并且不会比它大。</p><p>2、较大的字母应当放到末尾，且长度越大越好。</p><p>3、如果有两串字符相同，</p><ul><li>剩余未分配的字符相同，那么平均分到两组上面，是最优的</li><li>剩余未分配的字符不相同，显然只分配给一组是最优的，因为可以使得较大的字母位置更靠后。</li></ul><p>所以，可以这样贪心：</p><p>先从小到大排序，然后分配首字母，如果有不同的，直接输出最大的字母即可。</p><p>然后，后续分配只在当前所有字母加起来相等的组上分配，并且更新组数。</p><p>分配的时候，如果后续字母相同，则可以分配到各个相等的组上，否则只分配到第一组上。</p><p>最后，答案就是第一组。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k,l,cnt;</span><br><span class="line"><span class="keyword">char</span> a[MAX];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; res[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">sf(n);sf(k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">l = <span class="built_in">strlen</span>(a);</span><br><span class="line">sort(a,a+l);</span><br><span class="line">fi(i,<span class="number">0</span>,k) res[i].clear();</span><br><span class="line">fi(i,<span class="number">0</span>,k) res[i].pb(a[i]);</span><br><span class="line"><span class="keyword">if</span>(res[k<span class="number">-1</span>][<span class="number">0</span>] != res[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="built_in">putchar</span>(res[k<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>); <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = k,cnt=k;</span><br><span class="line"><span class="keyword">while</span>(j&lt;l)&#123;</span><br><span class="line">fi(i,<span class="number">0</span>,cnt)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=l) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(!i) res[i].pb(a[j++]);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] == a[j<span class="number">-1</span>] &amp;&amp; a[j] == a[l<span class="number">-1</span>] )&#123;</span><br><span class="line">res[i].pb(a[j]);</span><br><span class="line">j++;</span><br><span class="line">&#125;<span class="keyword">else</span> cnt = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fi(j,<span class="number">0</span>,res[<span class="number">0</span>].size())&#123;</span><br><span class="line"><span class="built_in">putchar</span>(res[<span class="number">0</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">pfc(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Phoenix and Distribution</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 p1064 金明的预算方案 [ dp dfs ]</title>
    <link href="https://lscgx.github.io/2020/04/29/%E6%B4%9B%E8%B0%B7p1064/"/>
    <id>https://lscgx.github.io/2020/04/29/%E6%B4%9B%E8%B0%B7p1064/</id>
    <published>2020-04-29T06:23:54.000Z</published>
    <updated>2020-04-29T06:37:00.186Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1064" target="_blank" rel="noopener">P1064 金明的预算方案</a></p><p><strong>题目描述</strong></p><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过<em>N</em>元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><p>主件 附件</p><p>电脑 打印机，扫描仪</p><p>书柜 图书</p><p>书桌 台灯，文具</p><p>工作椅 无</p><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N<em>元。于是，他把每件物品规定了一个重要度，分为5等：用整数 1-5 表示，第 5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过</em>N<em>元（可以等于N</em>元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第 j <em>件物品的价格为 v，重要度为 w_[j]，共选中了 k 件物品，编号依次为 j</em>1,<em>j</em>2,…,<em>j**k</em>，则所求的总和为：</p><p><em>v</em>[<em>j</em>1]×<em>w</em>[<em>j</em>1]+<em>v</em>[<em>j</em>2]×<em>w</em>[<em>j</em>2]+…+<em>v</em>[<em>j**k</em>]×<em>w</em>[<em>j**k</em>]。</p><p>请你帮助金明设计一个满足要求的购物单。</p><p><strong>输入格式</strong></p><p>第1行，为两个正整数，用一个空格隔开：</p><p>N m （其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第 j *行给出了编号为j-1的物品的基本数据，每行有3个非负整数</p><p>v p q （其中v<em>v</em>表示该物品的价格（v&lt;10000），p表示该物品的重要度（1-5），q<em>表示该物品是主件还是附件。如果q=0</em>，表示该物品为主件，如果q&gt;0，表示该物品为附件，<em>q</em>是所属主件的编号）</p><p><strong>输出格式</strong></p><p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure><blockquote><p>1、 对于一棵子树，给予空间 v , 选择树根的情况下，对子子树们跑 01 背包。</p><p>2、先求 dfs 序列，对于一个节点 x , </p><ul><li>如果选择 x ,那么他的子节点可以选择，d[i] 从 d[i-1] 直接转移而来</li><li>如果不选择 x，那么子节点不可选，只能从左兄弟转移而来，跑 dfs 的时候记录左兄弟节点 pre[i].</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; si;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfn(n) printf(<span class="meta-string">"%d\n"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(register int i=(s);i&lt;(t);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(i,s,t) for(register int i=(s)-1;i&gt;=(t);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,u[MAX],p[MAX],q,d[MAX],pre[MAX];</span><br><span class="line">vi v[MAX];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,f[<span class="number">100</span>][MAX]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=cnt;</span><br><span class="line">fi(i,<span class="number">0</span>,v[x].size())&#123;</span><br><span class="line">dfs(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">d[++cnt]=x;</span><br><span class="line">pre[cnt]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">sf(n);sf(m);</span><br><span class="line">u[<span class="number">0</span>]=<span class="number">0</span>;p[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">sf(u[i]);sf(p[i]);sf(q);</span><br><span class="line"><span class="keyword">if</span>(q) v[q].pb(i);</span><br><span class="line"><span class="keyword">else</span> v[<span class="number">0</span>].pb(i);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">fi(i,<span class="number">1</span>,cnt)</span><br><span class="line">fi(j,<span class="number">0</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=u[d[i]]) f[i][j]=max(f[pre[i]][j],f[i<span class="number">-1</span>][j-u[d[i]]] + u[d[i]] * p[d[i]]);</span><br><span class="line"><span class="keyword">else</span>  f[i][j] = f[pre[i]][j];</span><br><span class="line">&#125; </span><br><span class="line">pf(f[cnt<span class="number">-1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">金明的预算方案</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
    <category term="DFS" scheme="https://lscgx.github.io/tags/DFS/"/>
    
    <category term="noip" scheme="https://lscgx.github.io/tags/noip/"/>
    
  </entry>
  
  <entry>
    <title>CF1342C C. Yet Another Counting Problem [ lcm ]</title>
    <link href="https://lscgx.github.io/2020/04/27/CF1342C/"/>
    <id>https://lscgx.github.io/2020/04/27/CF1342C/</id>
    <published>2020-04-27T08:05:50.000Z</published>
    <updated>2020-04-27T08:23:46.612Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1342/problem/C" target="_blank" rel="noopener">C. Yet Another Counting Problem</a></p><p>You are given two integers a and b, and q queries. The i-th query consists of two numbers li and ri, and the answer to it is the number of integers x such that  $li≤x≤ri$, and $((x \bmod a)  \bmod b) \ne ((x \bmod b) \bmod a)$. Calculate the answer for each query.</p><p>Recall that y mod z is the remainder of the division of y by z. For example, 5 mod 3=2, 7 mod 8=7 , 9 mod 4=1, 9 mod 9=0.</p><p>Input</p><p>The first line contains one integer t (1≤t≤100) — the number of test cases. Then the test cases follow.</p><p>The first line of each test case contains three integers a, b and q (1≤a,b≤200; 1≤q≤500).</p><p>Then q lines follow, each containing two integers li and ri $(1≤li≤ri≤10^{18})$ for the corresponding query.</p><p>Output</p><p>For each test case, print q integers — the answers to the queries of this test case in the order they appear.</p><p>Example</p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4 6 5</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">1 5</span><br><span class="line">1 7</span><br><span class="line">1 9</span><br><span class="line">7 10 2</span><br><span class="line">7 8</span><br><span class="line">100 200</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 2 4 </span><br><span class="line">0 91</span><br></pre></td></tr></table></figure><blockquote><p> $((x \bmod a)  \bmod b) , ((x \bmod b) \bmod a)$ 的值以 lcm(a,b) 周期性变化。统计每一个周期中不一样的个数 cnt</p><p>对于一个数 x , (x/k) * cnt + f[x % k] = ans;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll l,r,a,b,q,f[<span class="number">50000</span>];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b / gcd(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;q); </span><br><span class="line">ll k =lcm(a,b);</span><br><span class="line">ll cnt =<span class="number">0</span>;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>((i%a)%b != (i%b)%a) &#123;</span><br><span class="line">cnt ++;</span><br><span class="line">f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> f[i]=f[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;l,&amp;r); </span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a==b) &#123;</span><br><span class="line">pfc(<span class="string">"0 "</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = ((r/k) * cnt + f[r%k]) - (((l<span class="number">-1</span>)/k) * cnt + f[(l<span class="number">-1</span>)%k]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">pfc(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C. Yet Another Counting Problem</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="数学" scheme="https://lscgx.github.io/tags/数学/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 p1103 [ dp ]</title>
    <link href="https://lscgx.github.io/2020/04/26/%E6%B4%9B%E8%B0%B7p1103/"/>
    <id>https://lscgx.github.io/2020/04/26/%E6%B4%9B%E8%B0%B7p1103/</id>
    <published>2020-04-26T09:00:05.000Z</published>
    <updated>2020-04-26T09:06:05.445Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1103" target="_blank" rel="noopener">P1103 书本整理</a></p><p><strong>题目描述</strong></p><p><code>Frank</code>是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以<code>Frank</code>首先将书按高度顺序排列在书架上。但是<code>Frank</code>发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉k本书，使得书架可以看起来整齐一点。</p><p>书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有4本书：</p><p>1×2<br>5×3<br>2×4<br>3×1<br>那么<code>Frank</code>将其排列整齐后是：</p><p>1×2<br>2×4<br>3×1<br>5×3<br>不整齐度就是2+3+2=7</p><p>已知每本书的高度都不一样，请你求出去掉k本书后的最小的不整齐度。</p><p><strong>输入格式</strong></p><p>第一行两个数字n和 <em>k</em>，代表书有几本，从中去掉几本。(1≤<em>n</em>≤100,1≤<em>k</em>&lt;<em>n</em>)</p><p>下面的n行，每行两个数字表示一本书的高度和宽度，均小于200。</p><p>保证高度不重复</p><p><strong>输出格式</strong></p><p>一行一个整数，表示书架的最小不整齐度。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 1</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>要求去掉k本书，即是保留 n - k 本书的最小代价。</p><p>设 $f[i][j]$ : 前 i 本书保留 j 本的代价。 $f[i][j]=min(f[i][j],f[k][j-1] + abs(a[k] - a[i]))$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,d[MAX],f[MAX][MAX],ans;</span><br><span class="line">pii p[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">sf(n);sf(k);</span><br><span class="line">k = n-k;</span><br><span class="line">fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">sf(p[i].ft);sf(p[i].sd);</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+n);</span><br><span class="line">mem(f,<span class="number">0x3f</span>);</span><br><span class="line">fi(i,<span class="number">0</span>,n) f[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">1</span>,n)</span><br><span class="line">fi(j,<span class="number">0</span>,i)</span><br><span class="line">fi(l,<span class="number">2</span>,min(i+<span class="number">1</span>,k)+<span class="number">1</span>)&#123;</span><br><span class="line">f[i][l]=min(f[i][l],f[j][l<span class="number">-1</span>]+<span class="built_in">abs</span>(p[i].sd-p[j].sd));</span><br><span class="line">&#125;</span><br><span class="line">ans = INF;</span><br><span class="line">fi(i,k<span class="number">-1</span>,n)</span><br><span class="line">ans = min(ans,f[i][k]);</span><br><span class="line">pf(ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">线性dp</summary>
    
    
    
    <category term="算法" scheme="https://lscgx.github.io/categories/算法/"/>
    
    <category term="题解" scheme="https://lscgx.github.io/categories/算法/题解/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 p1564 [ dp ]</title>
    <link href="https://lscgx.github.io/2020/04/26/%E6%B4%9B%E8%B0%B7p1564/"/>
    <id>https://lscgx.github.io/2020/04/26/%E6%B4%9B%E8%B0%B7p1564/</id>
    <published>2020-04-26T06:36:05.000Z</published>
    <updated>2020-04-26T06:40:10.267Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1564" target="_blank" rel="noopener">P1564 膜拜</a></p><p><strong>题目描述</strong></p><p>神牛有很多…当然…每个同学都有自己衷心膜拜的神牛.</p><p>某学校有两位神牛，神牛甲和神牛乙。新入学的 n 位同学们早已耳闻他们的神话。</p><p>所以，已经衷心地膜拜其中一位了。现在，老师要给他们分机房。但是，要么保证整个机房都是同一位神牛的膜拜者，或者两个神牛的膜拜者人数差不超过 m<em>。另外，现在 n</em> 位同学排成一排，老师只会把连续一段的同学分进一个机房。老师想知道，至少需要多少个机房。</p><p><strong>输入格式</strong></p><p>输入文件第一行包含两个整数 n 和 m。</p><p>第 2 到第 (n + 1) 行，每行一个非 1 即 2 的整数，第 (i + 1) 行的整数表示第 i 个同学崇拜的对象，1 表示甲，2 表示乙。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最小需要机房的数量。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>f[i] : 前 i  个同学最少需要多少个班级；</p><p>$f[i] = min(f[i],f[j]+1)  ,(0&lt;j&lt;i)$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">2500</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX],b[MAX],c[MAX],f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">sf(n);sf(m);</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>) &#123;</span><br><span class="line">sf(a[i]);</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;</span><br><span class="line">b[i] = b[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">c[i] = c[i<span class="number">-1</span>];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">c[i] = c[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">b[i] = b[i<span class="number">-1</span>];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">mem(f,<span class="number">0x3f</span>);</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">fi(j,<span class="number">0</span>,i)</span><br><span class="line"><span class="keyword">if</span>(f[j]+<span class="number">1</span>&lt;f[i]&amp;&amp;(<span class="built_in">abs</span>(b[i]-b[j] + c[i]- c[j])&lt;=m || b[i]==b[j] ||c[i]==c[j]))&#123;</span><br><span class="line">f[i]=f[j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pf(f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">线性dp</summary>
    
    
    
    <category term="算法" scheme="https://lscgx.github.io/categories/算法/"/>
    
    <category term="题解" scheme="https://lscgx.github.io/categories/算法/题解/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P5662 纪念品[ 背包 ]</title>
    <link href="https://lscgx.github.io/2020/04/24/%E6%B4%9B%E8%B0%B7p5662/"/>
    <id>https://lscgx.github.io/2020/04/24/%E6%B4%9B%E8%B0%B7p5662/</id>
    <published>2020-04-24T06:11:34.000Z</published>
    <updated>2020-04-24T06:37:26.431Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5662" target="_blank" rel="noopener">P5662 纪念品</a></p><p><strong>题目描述</strong></p><p>小伟突然获得一种超能力，他知道未来 T<em> 天 N</em> 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。</p><p>每天，小伟可以进行以下两种交易<strong>无限次</strong>：</p><ol><li>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；</li><li>卖出持有的任意一个纪念品，以当日价格换回金币。</li></ol><p>每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。</p><p><em>T</em> 天之后，小伟的超能力消失。因此他一定会在第 <em>T</em> 天卖出<strong>所有</strong>纪念品换回金币。</p><p>小伟现在有 M* 枚金币，他想要在超能力消失后拥有尽可能多的金币。</p><p><strong>输入格式</strong></p><p>第一行包含三个正整数 T, N, M，相邻两数之间以一个空格分开，分别代表未来天数 T<em>，纪念品数量 N</em>，小伟现在拥有的金币数量 M*。</p><p>接下来 T 行，每行包含 <em>N</em> 个正整数，相邻两数之间以一个空格分隔。第 i 行的 <em>N</em> 个正整数分别为 P_{i,1}，P_{i,2},……,P{i,j} 表示第 <em>i</em> 天第 <em>j</em> 种纪念品的价格。</p><p><strong>输出格式</strong></p><p>输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 1 100</span><br><span class="line">50</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">50</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">305</span><br></pre></td></tr></table></figure><p><strong>输入 #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 100</span><br><span class="line">10 20 15</span><br><span class="line">15 17 13</span><br><span class="line">15 25 16</span><br></pre></td></tr></table></figure><p><strong>输出 #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">217</span><br></pre></td></tr></table></figure><blockquote><p>考虑连续持有一件物品：</p><p>当日买入，未来第 x 天 卖出收益最大，考虑第二天：</p><ul><li><p>第二天（x=2）卖出，那么直接卖出即可</p></li><li><p>第二天 (x&gt;2) 之后卖出，第二天直接卖出的话收益为负，那么今天直接不买,第二天再买就好了</p></li><li><p>同上，第二天卖出收益为正，但是第 x 天卖出收益更大，可以观察出，第二天卖出再买回来，和第二天不卖，第 x 天卖出收益是一样的。</p><p>综上，只需要考虑临近两天的最大收益即可。</p></li></ul><p>对于连续两天，设当日买入价格为 “空间” ， 第二日与今日收益为 “价值”，就是完全背包问题。</p><p><del>虽然一开始完全没想到背包…</del></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fi(i,<span class="number">0</span>,t)&#123;</span><br><span class="line">mem(f,<span class="number">0</span>);</span><br><span class="line">fi(j,<span class="number">0</span>,n)</span><br><span class="line">fi(k,a[j][i],m+<span class="number">1</span>)</span><br><span class="line">f[k]=max(f[k],f[k-a[j][i]]+a[j][i+<span class="number">1</span>]-a[j][i]);</span><br><span class="line">m = max(m,f[m]+m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">完全背包</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>洛谷p1435 回文子串 [ lcs 区间dp ]</title>
    <link href="https://lscgx.github.io/2020/04/23/%E6%B4%9B%E8%B0%B7p1435%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>https://lscgx.github.io/2020/04/23/%E6%B4%9B%E8%B0%B7p1435%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-04-23T07:41:36.000Z</published>
    <updated>2020-04-23T07:46:22.621Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1435" target="_blank" rel="noopener">P1435 回文字串</a></p><p><strong>题目描述</strong></p><p>回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。</p><p>比如 “Ab3bd”插入2个字符后可以变成回文词“dAb3bAd”或“Adb3bdA”，但是插入少于2个的字符无法变成回文词。</p><p>注：此问题区分大小写</p><p><strong>输入格式</strong></p><p>一个字符串(0&lt;strlen&lt;=1000)</p><p><strong>输出格式</strong></p><p>有且只有一个整数，即最少插入字符数</p><p><strong>输入输出样例</strong></p><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ab3bd</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p>1、求正反数组的 lcs</p><p>2、$f[i][j]=max(f[i+1][j-1]+2,min(f[i+1][j],f[i][j-1])+1)$ </p><p>$f[i][j]$ 表示 i~j 成为回文串需要的最少插入次数。</p></blockquote>]]></content>
    
    
    <summary type="html">回文子串</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="动态规划" scheme="https://lscgx.github.io/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>CF1343E Weights Distributing[ 贪心 最短路 ]</title>
    <link href="https://lscgx.github.io/2020/04/22/CF1343E/"/>
    <id>https://lscgx.github.io/2020/04/22/CF1343E/</id>
    <published>2020-04-22T09:13:39.000Z</published>
    <updated>2020-04-22T09:23:52.550Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/E" target="_blank" rel="noopener">E. Weights Distributing</a></p><p>You are given an undirected unweighted graph consisting of n vertices and m edges (which represents the map of Bertown) and the array of prices p of length m. It is guaranteed that there is a path between each pair of vertices (districts).</p><p>Mike has planned a trip from the vertex (district) a to the vertex (district) b and then from the vertex (district)b to the vertex (district) c. He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (<strong>he pays each time he goes along the road</strong>). The list of prices that will be used pp is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.</p><p>You are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the <strong>minimum</strong> possible. <strong>Note that you cannot rearrange prices after the start of the trip</strong>.</p><p><strong>Example</strong></p><p>input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4 3 2 3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">7 9 1 5 7</span><br><span class="line">2 10 4 8 5 6 7 3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">4 2</span><br><span class="line">5 6</span><br><span class="line">1 7</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>Note</p><p>One of the possible solution to the first test case of the example:</p><p>You have to answer t independent test cases.</p><p><img src="f1d0f51cf563c458a58154af19f523d4cb7bafc0.png" alt="img"></p><blockquote><p> $a\rightarrow b \rightarrow c$ 可以观察出：</p><p>1、$a\rightarrow b \rightarrow c$ 在一条路径上</p><p>2、$a \rightarrow x , x \rightarrow b, b \rightarrow x, x\rightarrow c$  四段</p><p>枚举 x ，$ans = \sum sum[db[x]] + sum[da[x]+db[x]+dc[x]]$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,a,b,c,u,v,p[MAX];</span><br><span class="line"><span class="keyword">int</span> da[MAX],db[MAX],dc[MAX];</span><br><span class="line">ll ans,f[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[MAX],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">e[tot].to = v;</span><br><span class="line">e[tot].next = h[u];</span><br><span class="line">h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> d[])</span></span>&#123;</span><br><span class="line">d[s]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = h[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(d[v]==INF)&#123;</span><br><span class="line">d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">sf(n);sf(m);sf(a);sf(b);sf(c);</span><br><span class="line">fi(i,<span class="number">0</span>,m) sf(p[i]);</span><br><span class="line">mem(h,<span class="number">-1</span>);tot=<span class="number">0</span>;</span><br><span class="line">fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">sf(u);sf(v);</span><br><span class="line">addedge(u,v);</span><br><span class="line">addedge(v,u);</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+m);</span><br><span class="line">fi(i,<span class="number">0</span>,m) f[i+<span class="number">1</span>] = f[i]+p[i]; <span class="comment">//</span></span><br><span class="line">mem(da,<span class="number">0x3f</span>);mem(db,<span class="number">0x3f</span>);mem(dc,<span class="number">0x3f</span>);</span><br><span class="line">bfs(a,da);</span><br><span class="line">bfs(b,db);</span><br><span class="line">bfs(c,dc);</span><br><span class="line">ans = LINF;</span><br><span class="line">fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(da[i]+db[i]+dc[i]&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">ans = min(ans,f[db[i]]+f[da[i]+db[i]+dc[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">枚举..</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="图论" scheme="https://lscgx.github.io/tags/图论/"/>
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
    <category term="最短路" scheme="https://lscgx.github.io/tags/最短路/"/>
    
  </entry>
  
  <entry>
    <title>CF1343D Constant Palindrome Sum [ 贪心 尺取法 前缀和]</title>
    <link href="https://lscgx.github.io/2020/04/22/CF1343D/"/>
    <id>https://lscgx.github.io/2020/04/22/CF1343D/</id>
    <published>2020-04-22T07:48:52.000Z</published>
    <updated>2020-04-22T09:32:30.408Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/D" target="_blank" rel="noopener">CF1343D Constant Palindrome Sum</a></p><p>You are given an array a consisting of n integers (it is guaranteed that n is even, i.e. divisible by 2). All ai does not exceed some integer k.</p><p>Your task is to replace the <strong>minimum</strong> number of elements (replacement is the following operation: choose some index i from 1 to n and replace ai with some integer in range [1;k][1;k]) to satisfy the following conditions:</p><ul><li>after all replacements, all ai are positive integers not greater than k;</li><li>for all i from 1 to n/2 the following equation is true: ai+an−i+1=x, where x should be <strong>the same</strong> for all n2 pairs of elements.</li></ul><p>You have to answer t independent test cases.</p><blockquote><p>每一对数，当 $x \in [min(a_i,a_{n−i+1})+1;max(a_i,a_{n−i+1})+k] $, 至多只需要修改一个，否则需要修改两个；特别的，当 $x=a[i]+a[n-i+1]$ 时，无需修改；使用前缀和，$d[min(a_i,a_{n−i+1})+1]$ = -1; $d[max(a_i,a_{n−i+1})+k+1]=1$ 因为可能多个值相同所以用 $++,–$  .</p><p>对于 $x=a[i]+a[n-i+1]$   ,$d[a[i]+a[n-i-1]]–;  d[a[i]+a[n-i-1]+1]++; $</p><p>所以对于 i 需要修改 $d[max(a_i,a_{n−i+1})+k] - d[min(a_i,a_{n−i+1})+1]$ 次。</p><p>然后，从左到右扫描一遍</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k,a[MAX],d[MAX*<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">sf(t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">ans = INF;</span><br><span class="line">mem(d,<span class="number">0</span>);</span><br><span class="line">sf(n);sf(k);</span><br><span class="line">fi(i,<span class="number">0</span>,n) sf(a[i]);</span><br><span class="line">fi(i,<span class="number">0</span>,n/<span class="number">2</span>)&#123;</span><br><span class="line">d[<span class="number">0</span>]+=<span class="number">2</span>;</span><br><span class="line">d[min(a[i],a[n-i<span class="number">-1</span>])+<span class="number">1</span>]--;</span><br><span class="line">d[max(a[i],a[n-i<span class="number">-1</span>])+k+<span class="number">1</span>]++;</span><br><span class="line">d[a[i]+a[n-i<span class="number">-1</span>]]--;</span><br><span class="line">d[a[i]+a[n-i<span class="number">-1</span>]+<span class="number">1</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">fi(i,<span class="number">1</span>,k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">d[i]+=d[i<span class="number">-1</span>];</span><br><span class="line">ans = min(ans,d[i]);</span><br><span class="line">&#125;</span><br><span class="line">pfn(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CF1343D Constant Palindrome Sum [ 贪心 尺取法 ]</summary>
    
    
    
    <category term="题解" scheme="https://lscgx.github.io/categories/题解/"/>
    
    <category term="算法" scheme="https://lscgx.github.io/categories/题解/算法/"/>
    
    
    <category term="贪心" scheme="https://lscgx.github.io/tags/贪心/"/>
    
    <category term="尺取法" scheme="https://lscgx.github.io/tags/尺取法/"/>
    
    <category term="前缀和" scheme="https://lscgx.github.io/tags/前缀和/"/>
    
  </entry>
  
</feed>

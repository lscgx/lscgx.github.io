<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51nod 1081 字段求和</title>
    <url>/2019/03/06/1081%E5%AD%97%E6%AE%B5%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1081" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1081</a><br>给出一个长度为N的数组，进行Q次查询，查询从第i个元素开始长度为l的子段所有元素之和。<br>例如，1 3 7 9 -1，查询第2个元素开始长度为3的子段和，1 {3 7 9} -1。3 + 7 + 9 = 19，输出19。<br>输入<br>第1行：一个数N，N为数组的长度(2 &lt;= N &lt;= 50000)。<br>第2 至 N + 1行：数组的N个元素。(-10^9 &lt;= N[i] &lt;= 10^9)<br>第N + 2行：1个数Q，Q为查询的数量。<br>第N + 3 至 N + Q + 2行：每行2个数，i，l（1 &lt;= i &lt;= N，i + l &lt;= N)<br>输出<br>共Q行，对应Q次查询的计算结果。<br>输入样例<br>5<br>1<br>3<br>7<br>9<br>-1<br>4<br>1 2<br>2 2<br>3 2<br>1 5<br>输出样例<br>4<br>10<br>16<br>19</p>
<blockquote>
<p>线段树</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a, b, sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for (int (i) = (a); i &lt; (b); ++(i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repd(i,a,b) for (int (i) = (a); i &gt; (b); --(i))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50000+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,m,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m+1,r,rt&lt;&lt;1|1</span></span><br><span class="line">ll sum[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushPlus</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[rt]);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Build(lson);</span><br><span class="line">	Build(rson);</span><br><span class="line">	PushPlus(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">		<span class="keyword">return</span> sum[rt];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=m)</span><br><span class="line">		ans+=Query(L,R,lson);</span><br><span class="line">	<span class="keyword">if</span>(R&gt;m) </span><br><span class="line">		ans+=Query(L,R,rson);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,i,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	Build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;l);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Query(i,i+l<span class="number">-1</span>,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod-1384-全排列</title>
    <url>/2019/01/03/51nod-1384-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1384" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1384</a><br>给出一个字符串S（可能有重复的字符），按照字典序从小到大，输出S包括的字符组成的所有排列。例如：S = “1312”，</p>
<h3 id="字典序法"><a href="#字典序法" class="headerlink" title="字典序法"></a>字典序法</h3><blockquote>
<p>设P是集合{1，2，……n-1，n}的一个全排列：P=P1P2……Pj-1PjPj+1……Pn（1≤P1，P2，……，Pn≤n-1）<br>从排列的右端开始，找出第一个比右边数字小的数字的序号j，即&gt;  j=max{i|Pi&lt;Pi+1，i&gt;j}<br>在Pj的右边的数字中，找出所有比Pj大的数字中最小的数字Pk，即k=min{i|Pi&gt;Pj，i&gt;j}<br>交换Pi，Pk<br>再将排列右端的递减部分Pj+1Pj+2……Pn倒转，因为j右端的数字是降序，所以只需要其左边和右边的交换，直到中间，因此可以得到一个新的排列P’=P1P2……Pj-1PkPn……Pj+2Pj+1。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],len;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(r-l+<span class="number">1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">		swap(a[i+l],a[r-i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;len;k++)&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(a[k]+<span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	sort(a,a+len);</span><br><span class="line">	print(a,len);</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		i=len<span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">while</span>(a[i]&gt;=a[i+<span class="number">1</span>]&amp;&amp;i&gt;=<span class="number">-1</span>)i--;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		j=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(a[j]&gt;a[i]&amp;&amp;j&lt;len)j++;</span><br><span class="line">		swap(a[i],a[j<span class="number">-1</span>]);</span><br><span class="line">		reverse(a,i+<span class="number">1</span>,len<span class="number">-1</span>);</span><br><span class="line">		</span><br><span class="line">		print(a,len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); </span><br><span class="line">	len=<span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		a[i]=str[i]-<span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	permutation(a, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1076 两条不相交的线路</title>
    <url>/2019/02/20/51nod1076/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1076" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1076</a></p>
<p>给出一个无向图G的顶点V和边E。进行Q次查询，查询从G的某个顶点V[s]到另一个顶点V[t]，是否存在2条不相交的路径。（两条路径不经过相同的边）<br>（注，无向图中不存在重边，也就是说确定起点和终点，他们之间最多只有1条路）<br>输入<br>第1行：2个数M N，中间用空格分开，M是顶点的数量，N是边的数量。（2 &lt;= M &lt;= 25000, 1 &lt;= N &lt;= 50000)<br>第2 - N + 1行，每行2个数，中间用空格分隔，分别是N条边的起点和终点的编号。例如2 4表示起点为2，终点为4，由于是无向图，所以从4到2也是可行的路径。<br>第N + 2行，一个数Q，表示后面将进行Q次查询。(1 &lt;= Q &lt;= 50000)<br>第N + 3 - N + 2 + Q行，每行2个数s, t，中间用空格分隔，表示查询的起点和终点。<br>输出<br>共Q行，如果从s到t存在2条不相交的路径则输出Yes，否则输出No。<br>输入样例<br>4 4<br>1 2<br>2 3<br>1 3<br>1 4<br>5<br>1 2<br>2 3<br>3 1<br>2 4<br>1 4<br>输出样例<br>Yes<br>Yes<br>Yes<br>No<br>No</p>
<blockquote>
<p>学习了下tarjan。。。求有向图的强连通分量，求无向图时使回边不能指向父节点即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];</span><br><span class="line"><span class="keyword">int</span> index,top;</span><br><span class="line"><span class="keyword">int</span> scc;   <span class="comment">//强连通分量的个数 </span></span><br><span class="line"><span class="keyword">bool</span> InStack[MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];<span class="comment">//各个强连通分量包含点的个数</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; e[MAXM]; <span class="comment">//边表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	Low[u]=DFN[u]=++index;</span><br><span class="line">	Stack[top++]=u;</span><br><span class="line">	InStack[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> size=e[u].size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">		v=e[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span>(!DFN[v])&#123;</span><br><span class="line">			tarjan(v,u);</span><br><span class="line">			Low[u]=min(Low[u],Low[v]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(InStack[v])&#123;</span><br><span class="line">			Low[u]=min(Low[u],DFN[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Low[u]==DFN[u])&#123;</span><br><span class="line">		scc++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			v=Stack[--top];</span><br><span class="line">			InStack[v]=<span class="literal">false</span>;</span><br><span class="line">			Belong[v]=scc; <span class="comment">//标记属于哪一个强连通分量</span></span><br><span class="line">		<span class="comment">//	num[scc]++;</span></span><br><span class="line">		&#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(DFN,<span class="number">0</span>,<span class="keyword">sizeof</span>(DFN));</span><br><span class="line">	<span class="built_in">memset</span>(InStack,<span class="literal">false</span>,<span class="keyword">sizeof</span>(InStack));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	index=scc=top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!DFN[i])</span><br><span class="line">			tarjan(i,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m,n,q,x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		e[x].push_back(y);</span><br><span class="line">		e[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	solve(m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(Belong[x]==Belong[y]) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1099 任务执行顺序</title>
    <url>/2019/01/21/51nod1099/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1099" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1099</a></p>
<p>有N个任务需要执行，第i个任务计算时占R[i]个空间，而后会释放一部分，最后储存计算结果需要占据O[i]个空间（O[i] &lt; R[i]）。<br>例如：执行需要5个空间，最后储存需要2个空间。给出N个任务执行和存储所需的空间，问执行所有任务最少需要多少空间。<br>输入<br>第1行：1个数N，表示任务的数量。（2 &lt;= N &lt;= 100000)<br>第2 - N + 1行：每行2个数R[i]和O[i]，分别为执行所需的空间和存储所需的空间。(1 &lt;= O[i] &lt; R[i] &lt;= 10000)<br>输出<br>输出执行所有任务所需要的最少空间。<br>输入样例<br>20<br>14 1<br>2 1<br>11 3<br>20 4<br>7 5<br>6 5<br>20 7<br>19 8<br>9 4<br>20 10<br>18 11<br>12 6<br>13 12<br>14 9<br>15 2<br>16 15<br>17 15<br>19 13<br>20 2<br>20 1<br>输出样例<br>135</p>
<blockquote>
<p>考虑两个任务( R1,O1,R2,O2 ) , 任务 1 在前时，造成O1+R2 的代价，先执行任务 2 为O2 + R1 的代价。以 O1+R2  &gt; O2 + R1 排序统计。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000+10</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; a[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;&amp;a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;&amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.first+b.second&gt;a.second+b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">	sort(a,a+n,cmp);</span><br><span class="line">	ans=t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i].first&gt;ans-t)&#123;</span><br><span class="line">			ans=t+a[i].first;</span><br><span class="line">		&#125;</span><br><span class="line">		t+=a[i].second;</span><br><span class="line">		ans=max(ans,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1163 最高的奖励</title>
    <url>/2019/01/21/51nod1163/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1163" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1163</a></p>
<p>有N个任务，每个任务有一个最晚结束时间以及一个对应的奖励。在结束时间之前完成该任务，就可以获得对应的奖励。完成每一个任务所需的时间都是1个单位时间。有时候完成所有任务是不可能的，因为时间上可能会有冲突，这需要你来取舍。求能够获得的最高奖励。<br>输入<br>第1行：一个数N，表示任务的数量(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行，每行2个数，中间用空格分隔，表示任务的最晚结束时间E[i]以及对应的奖励W[i]。(1 &lt;= E[i] &lt;= 10^9，1 &lt;= W[i] &lt;= 10^9)<br>输出<br>输出能够获得的最高奖励。<br>输入样例<br>7<br>4 20<br>2 60<br>4 70<br>3 40<br>1 30<br>4 50<br>6 10<br>输出样例<br>230</p>
<blockquote>
<p> 同 2070 差不多</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 50000+10 </span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; a[MAX];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		p.push(-a[i].second);</span><br><span class="line">		ans+=-a[i].second;</span><br><span class="line">		<span class="keyword">if</span>(p.size()&gt;a[i].first)&#123;</span><br><span class="line">			ans-=p.top();</span><br><span class="line">			p.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,-ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1174 区间中最大的数</title>
    <url>/2019/03/06/51nod1174/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1174" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1174</a><br>给出一个有N个数的序列，编号0 - N - 1。进行Q次查询，查询编号i至j的所有数中，最大的数是多少。<br>例如: 1 7 6 3 1。i = 1, j = 3，对应的数为7 6 3，最大的数为7。（该问题也被称为RMQ问题）<br>输入<br>第1行：1个数N，表示序列的长度。(2 &lt;= N &lt;= 10000)<br>第2 - N + 1行：每行1个数，对应序列中的元素。(0 &lt;= S[i] &lt;= 10^9)<br>第N + 2行：1个数Q，表示查询的数量。(2 &lt;= Q &lt;= 10000)<br>第N + 3 - N + Q + 2行：每行2个数，对应查询的起始编号i和结束编号j。(0 &lt;= i &lt;= j &lt;= N - 1)<br>输出<br>共Q行，对应每一个查询区间的最大值。<br>输入样例<br>5<br>1<br>7<br>6<br>3<br>1<br>3<br>0 1<br>1 3<br>3 4<br>输出样例<br>7<br>7<br>3</p>
<blockquote>
<p>线段树</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10000+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,m,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">int</span> MAX[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushPlus</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	MAX[rt]=max(MAX[rt&lt;&lt;<span class="number">1</span>],MAX[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;MAX[rt]);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Build(lson);</span><br><span class="line">	Build(rson);</span><br><span class="line">	PushPlus(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">		<span class="keyword">return</span> MAX[rt];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=m)</span><br><span class="line">		ans=max(ans,Query(L,R,lson));</span><br><span class="line">	<span class="keyword">if</span>(R&gt;m) </span><br><span class="line">		ans=max(ans,Query(L,R,rson));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	Build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Query(i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1255 字典序最小的序列</title>
    <url>/2019/01/25/51nod1255/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1255" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1255</a></p>
<p>给出一个由a-z组成的字符串S，求他的一个子序列，满足如下条件：</p>
<p>1、包含字符串中所有出现过的字符各1个。<br>2、是所有满足条件1的串中，字典序最小的。</p>
<p>例如：babbdcc，出现过的字符为：abcd，而包含abcd的所有子序列中，字典序最小的为abdc。<br>输入<br>输入1行字符串S，所有字符均为小写，字符串的长度为L。(1 &lt;= L &lt;= 100000)。<br>输出<br>输出包含S中所有出现过的字符，每个字符各1个，并且字典序最小的S的子序列。<br>输入样例<br>babbdcc<br>输出样例<br>abdc</p>
<blockquote>
<p>从前往后遍历字符串，维护一个栈。如果当前字符串 c 小于栈顶且不在栈内，且栈顶字符在后面还有出现，则弹栈并将 c 入栈，依次循环直到不符合条件。<br>如果当前字符已经在栈内，则跳过。<br>如果 c 大于栈顶，且不在栈内，则入栈，否则跳过。<br>用两个数组维护字符还剩余的个数 和 是否已在栈内。<br>总结：入栈两种情况（+第一个字符）， 出栈一种，其余的跳过。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">char</span> a[MAX]; </span><br><span class="line"><span class="keyword">int</span>  t[<span class="number">150</span>],flag[<span class="number">150</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">27</span>],c;</span><br><span class="line"><span class="keyword">int</span> h=<span class="number">0</span>,l;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span>)&#123;</span><br><span class="line">		a[++k]=c;</span><br><span class="line">		t[c]++;</span><br><span class="line">	&#125;</span><br><span class="line">	a[++k]=<span class="string">'\0'</span>; s[<span class="number">0</span>]=<span class="number">150</span>;</span><br><span class="line">	l=<span class="built_in">strlen</span>(a);         <span class="comment">//strlen () 写在循环里会超时</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!h)&#123;</span><br><span class="line">			s[++h]=a[i];</span><br><span class="line">			flag[a[i]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag[a[i]])&#123;</span><br><span class="line">			t[a[i]]--;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( (a[i]&lt;s[h] &amp;&amp; !t[s[h]]) || a[i]&gt;s[h]  )&#123;</span><br><span class="line">			s[++h]=a[i];</span><br><span class="line">			flag[a[i]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;s[h] &amp;&amp; t[s[h]] )&#123;</span><br><span class="line">			flag[s[h]]=<span class="number">0</span>;</span><br><span class="line">			s[h]=a[i];</span><br><span class="line">			flag[a[i]]=<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(a[i]&lt;s[h<span class="number">-1</span>] &amp;&amp; t[s[h<span class="number">-1</span>]])&#123;</span><br><span class="line">				h--;</span><br><span class="line">				flag[s[h]]=<span class="number">0</span>;</span><br><span class="line">				s[h]=a[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		t[a[i]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	s[++h]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="built_in">puts</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1279 扔盘子</title>
    <url>/2019/01/18/51nod1279/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1279" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1279</a></p>
<p>有一口井，井的高度为N，每隔1个单位它的宽度有变化。现在从井口往下面扔圆盘，如果圆盘的宽度大于井在某个高度的宽度，则圆盘被卡住（恰好等于的话会下去）。<br>盘子有几种命运：1、掉到井底。2、被卡住。3、落到别的盘子上方。<br>盘子的高度也是单位高度。给定井的宽度和每个盘子的宽度，求最终落到井内的盘子数量。</p>
<p>如图井和盘子信息如下：<br>井：5 6 4 3 6 2 3<br>盘子：2 3 5 2 4</p>
<p>最终有4个盘子落在井内。<br>本题由 @javaman 翻译。<br>输入<br>第1行：2个数N, M中间用空格分隔，N为井的深度，M为盘子的数量(1 &lt;= N, M &lt;= 50000)。<br>第2 - N + 1行，每行1个数，对应井的宽度Wi(1 &lt;= Wi &lt;= 10^9)。<br>第N + 2 - N + M + 1行，每行1个数，对应盘子的宽度Di(1 &lt;= Di &lt;= 10^9)<br>输出<br>输出最终落到井内的盘子数量。<br>输入样例<br>7 5<br>5<br>6<br>4<br>3<br>6<br>2<br>3<br>2<br>3<br>5<br>2<br>4<br>输出样例<br>4</p>
<blockquote>
<p>统计每个井口可以到达的最小宽度，依次判断</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">50000</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,d,t,w,c[MAX],ans;<span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	t=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">		<span class="keyword">if</span>(w&lt;t)&#123;</span><br><span class="line">			t=w;</span><br><span class="line">		&#125;</span><br><span class="line">		c[i]=min(w,t);</span><br><span class="line">	&#125;</span><br><span class="line">	t=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d);	</span><br><span class="line">		<span class="keyword">while</span>(t&gt;=<span class="number">-1</span>&amp;&amp;c[t--]&lt;d);</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		ans++;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1344 走格子</title>
    <url>/2019/01/18/51nod1344/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1344" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1344</a></p>
<p>有编号1-n的n个格子，机器人从1号格子顺序向后走，一直走到n号格子，并需要从n号格子走出去。机器人有一个初始能量，每个格子对应一个整数A[i]，表示这个格子的能量值。如果A[i] &gt; 0，机器人走到这个格子能够获取A[i]个能量，如果A[i] &lt; 0，走到这个格子需要消耗相应的能量，如果机器人的能量 &lt; 0，就无法继续前进了。问机器人最少需要有多少初始能量，才能完成整个旅程。</p>
<p>例如：n = 5。{1，-2，-1，3，4} 最少需要2个初始能量，才能从1号走到5号格子。途中的能量变化如下3 1 0 3 7。<br>输入<br>第1行：1个数n，表示格子的数量。(1 &lt;= n &lt;= 50000)<br>第2 - n + 1行：每行1个数A[i]，表示格子里的能量值(-1000000000 &lt;= A[i] &lt;= 1000000000)<br>输出<br>输出1个数，对应从1走到n最少需要多少初始能量。<br>输入样例<br>5<br>1<br>-2<br>-1<br>3<br>4<br>输出样例<br>2<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>); </span><br><span class="line">	<span class="keyword">int</span> n,t;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>,temp=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">		<span class="keyword">if</span>(temp+t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			ans-=temp+t;</span><br><span class="line">			temp=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			temp+=t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1428 活动安排</title>
    <url>/2019/01/18/51nod1428/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1428" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1428</a></p>
<p>有若干个活动，第i个开始时间和结束时间是[Si,fi)，同一个教室安排的活动之间不能交叠，求要安排所有活动，最少需要几个教室？<br>输入<br>第一行一个正整数n (n &lt;= 10000)代表活动的个数。<br>第二行到第(n + 1)行包含n个开始时间和结束时间。<br>开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000<br>输出<br>一行包含一个整数表示最少教室的个数。<br>输入样例<br>3<br>1 2<br>3 4<br>2 9<br>输出样例<br>2</p>
<blockquote>
<p>如果要加入的活动开始时间小于已开始活动的最早结束时间，则新开一个教室</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX  10000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a[MAX];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span> &gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p.size()&amp;&amp;-p.top()&lt;=a[i].first)&#123;</span><br><span class="line">			p.pop();</span><br><span class="line">			p.push(-a[i].second);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			p.push(-a[i].second);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1432 独木舟</title>
    <url>/2019/01/18/51nod1432/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1432" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1432</a></p>
<p>n个人，已知每个人体重。独木舟承重固定，每只独木舟最多坐两个人，可以坐一个人或者两个人。显然要求总重量不超过独木舟承重，假设每个人体重也不超过独木舟承重，问最少需要几只独木舟？<br>输入<br>第一行包含两个正整数n (0&lt;n&lt;=10000)和m (0&lt;m&lt;=2000000000)，表示人数和独木舟的承重。<br>接下来n行，每行一个正整数，表示每个人的体重。体重不超过1000000000，并且每个人的体重不超过m。<br>输出<br>一行一个整数表示最少需要的独木舟数。<br>输入样例<br>3 6<br>1<br>2<br>3<br>输出样例<br>2</p>
<blockquote>
<p>从两边开始取，如果可以就拿否则下一个</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000+10 </span></span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX],ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	<span class="keyword">int</span> f=<span class="number">0</span>,e=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(f&lt;e)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[f]+a[e]&lt;=m)&#123;</span><br><span class="line">			f++;e--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			e--;</span><br><span class="line">		&#125;</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f==e)ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1455 变色DNA</title>
    <url>/2019/02/20/51nod1455/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1445" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1445</a></p>
<p>有一只特别的狼，它在每个夜晚会进行变色，研究发现它可以变成N种颜色之一，将这些颜色标号为0,1,2…N-1。研究发现这只狼的基因中存在一个变色矩阵，记为colormap，如果colormap[i][j]=’Y’则这只狼可以在某一个夜晚从颜色i变成颜色j（一晚不可以变色多次），如果colormap[i][j]=‘N’则不能在一个晚上从i变成j色。进一步研究发现，这只狼每次变色并不是随机变的，它有一定策略，在每个夜晚，如果它没法改变它的颜色，那么它就不变色，如果存在可改变的颜色，那它变为标号尽可能小的颜色（可以变色时它一定变色，哪怕变完后颜色标号比现在的大）。现在这只狼是颜色0，你想让其变为颜色N-1，你有一项技术可以改变狼的一些基因，具体说你可以花费1的代价，将狼的变色矩阵中的某一个colormap[i][j]=’Y’改变成colormap[i][j]=’N’。问至少花费多少总代价改变狼的基因，让狼按它的变色策略可以从颜色0经过若干天的变色变成颜色N-1。如果一定不能变成N-1，则输出-1.<br>输入<br>多组测试数据，第一行一个整数T，表示测试数据数量，1&lt;=T&lt;=5<br>每组测试数据有相同的结构构成：<br>每组数据第一行一个整数N,2&lt;=N&lt;=50。<br>之后有N行，每行N个字符，表示狼的变色矩阵，矩阵中只有‘Y’与‘N’两种字符，第i行第j列的字符就是colormap[i][j]。<br>输出<br>每组数据一行输出，即最小代价，无解时输出-1。<br>输入样例<br>3<br>3<br>NYN<br>YNY<br>NNN<br>8<br>NNNNNNNY<br>NNNNYYYY<br>YNNNNYYN<br>NNNNNYYY<br>YYYNNNNN<br>YNYNYNYN<br>NYNYNYNY<br>YYYYYYYN<br>6<br>NYYYYN<br>YNYYYN<br>YYNYYN<br>YYYNYN<br>YYYYNN<br>YYYYYN<br>输出样例<br>1<br>0<br>-1</p>
<blockquote>
<p>修改dij 的 low[] 数组的定义为，到 i 点所需要修改矩阵的次数<br>每次选择 i 点时，代价增加 k-&gt; 0~i-1 的边数<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> t,n,c[<span class="number">55</span>][<span class="number">55</span>],vis[<span class="number">55</span>],low[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		low[i]=INF;</span><br><span class="line">		vis[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	low[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> min=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;low[i]&lt;min)&#123;</span><br><span class="line">				min=low[i];</span><br><span class="line">				k=i;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		vis[k]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;low[k]+cnt&lt;low[i] &amp;&amp; c[k][i])&#123;</span><br><span class="line">				low[i]=low[k]+cnt;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(c[k][i]) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="keyword">char</span> cc=getchar();</span><br><span class="line">				<span class="keyword">if</span>(cc==<span class="string">'Y'</span>) c[i][j]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> c[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		dij(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,low[n<span class="number">-1</span>]==INF?<span class="number">-1</span>:low[n<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>51nod1475建设国家</title>
    <url>/2018/04/18/51nod1475%E5%BB%BA%E8%AE%BE%E5%9B%BD%E5%AE%B6/</url>
    <content><![CDATA[<h2 id="建设国家"><a href="#建设国家" class="headerlink" title="建设国家"></a>建设国家</h2><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1475" target="_blank" rel="noopener">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1475</a></p>
<a id="more"></a> 
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000+5</span></span><br><span class="line"><span class="keyword">int</span> n,h,dp[MAX][MAX]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">city</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> hi;</span><br><span class="line">	<span class="keyword">int</span> pi;</span><br><span class="line">&#125;c[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(city x,city y )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.hi==y.hi)&#123;</span><br><span class="line">		<span class="keyword">return</span> x.pi&gt;y.pi;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">return</span> x.hi&gt;y.hi;<span class="comment">//降序 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("yzhid.in","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;h);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;c[i].hi,&amp;c[i].pi);</span><br><span class="line">	sort(c+<span class="number">1</span>,c+<span class="number">1</span>+n,cmp);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tmax=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">			dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(j+c[i].hi&lt;=h &amp;&amp; dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i].pi&gt;dp[i][j] )&#123;</span><br><span class="line">				dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i].pi;</span><br><span class="line">				tmax=max(tmax,dp[i][j]+c[i+<span class="number">1</span>].pi);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,tmax);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1640 天气晴朗的算法</title>
    <url>/2019/02/18/51nod1640/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1640" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1640</a></p>
<p>这样阴沉的天气持续下去，我们不免担心起他的健康。</p>
<p>51nod魔法学校近日开展了主题为“天气晴朗”的魔法交流活动。</p>
<p>N名魔法师按阵法站好，之后选取N - 1条魔法链将所有魔法师的魔力连接起来，形成一个魔法阵。</p>
<p>魔法链是做法成功与否的关键。每一条魔法链都有一个魔力值V，魔法最终的效果取决于阵中所有魔法链的魔力值的和。</p>
<p>由于逆天改命的魔法过于暴力，所以我们要求阵中的魔法链的魔力值最大值尽可能的小，与此同时，魔力值之和要尽可能的大。</p>
<p>现在给定魔法师人数N，魔法链数目M。求此魔法阵的最大效果。<br>输入<br>两个正整数N，M。(1 &lt;= N &lt;= 10^5, N &lt;= M &lt;= 2 * 10^5)</p>
<p>接下来M行，每一行有三个整数A, B, V。(1 &lt;= A, B &lt;= N, INT_MIN &lt;= V &lt;= INT_MAX)</p>
<p>保证输入数据合法。<br>输出<br>输出一个正整数R，表示符合条件的魔法阵的魔力值之和。<br>输入样例<br>4 6<br>1 2 3<br>1 3 1<br>1 4 7<br>2 3 4<br>2 4 5<br>3 4 6<br>输出样例<br>12</p>
<blockquote>
<p>先用 kruskal 求出最小生成树，记录最大边值 。这个边就是最小的最大边。<br>然后再在小于此值的边里求最大生成树。就是逆着的 kruskal。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2</span> * MAXN;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> f[MAXN],n,m,u,v,w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;b) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> w&lt;b.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]==<span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	sort(edge,edge+m);</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> t,t1,t2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		t1=find(edge[i].u);</span><br><span class="line">		t2=find(edge[i].v);</span><br><span class="line">		<span class="keyword">if</span>(t1!=t2)&#123;</span><br><span class="line">			f[t1]=t2;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==n<span class="number">-1</span>)&#123;</span><br><span class="line">			t=i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(t&lt;=m&amp;&amp;edge[t].w==edge[t+<span class="number">1</span>].w)&#123;</span><br><span class="line">		t++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		t1=find(edge[i].u);</span><br><span class="line">		t2=find(edge[i].v);</span><br><span class="line">		<span class="keyword">if</span>(t1!=t2)&#123;</span><br><span class="line">			ans+=edge[i].w;</span><br><span class="line">			f[t1]=t2;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;edge[i].u,&amp;edge[i].v,&amp;edge[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,kruskal());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 1649 齐头并进</title>
    <url>/2019/02/20/51nod1649/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1649" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=1649</a><br>在一个叫奥斯汀的城市，有n个小镇（从1到n编号），这些小镇通过m条双向火车铁轨相连。当然某些小镇之间也有公路相连。为了保证每两个小镇之间的人可以方便的相互访问，市长就在那些没有铁轨直接相连的小镇之间建造了公路。在两个直接通过公路或者铁路相连的小镇之间移动，要花费一个小时的时间。</p>
<p>现在有一辆火车和一辆汽车同时从小镇1出发。他们都要前往小镇n，但是他们中途不能同时停在同一个小镇（但是可以同时停在小镇n）。火车只能走铁路，汽车只能走公路。</p>
<p>现在请来为火车和汽车分别设计一条线路；所有的公路或者铁路可以被多次使用。使得火车和汽车尽可能快的到达小镇n。即要求他们中最后到达小镇n的时间要最短。输出这个最短时间。(最后火车和汽车可以同时到达小镇n，也可以先后到达。)</p>
<p>样例解释：</p>
<p>在样例中，火车可以按照 1⟶3⟶4 行驶，汽车 1⟶2⟶4 按照行驶，经过2小时后他们同时到过小镇4。</p>
<p>输入<br>单组测试数据。<br>第一行有两个整数n 和 m (2≤n≤400, 0≤m≤n*(n-1)/2) ，表示小镇的数目和铁轨的数目。<br>接下来m行，每行有两个整数u 和 v，表示u和v之间有一条铁路。(1≤u,v≤n, u≠v)。<br>输入中保证两个小镇之间最多有一条铁路直接相连。<br>输出<br>输出一个整数，表示答案，如果没有合法的路线规划，输出-1。<br>输入样例<br>4 2<br>1 3<br>3 4<br>输出样例<br>2</p>
<blockquote>
<p>求两次最短路,有一条 1-&gt;n  的直达。所以不用考虑中间节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n,m,u,v,e[N][N];</span><br><span class="line"><span class="keyword">int</span> vis[N],low[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		low[i]=INF;</span><br><span class="line">		vis[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	low[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> min=INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;low[i]&lt;min)&#123;</span><br><span class="line">				min=low[i];</span><br><span class="line">				k=i;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		vis[k]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">if</span>(!vis[i]&amp;&amp;low[k]+<span class="number">1</span>&lt;low[i])&#123;</span><br><span class="line">				<span class="keyword">if</span>( (!flag &amp;&amp; e[k][i]==<span class="number">0</span>)||(flag&amp;&amp;e[k][i]) )</span><br><span class="line">					low[i]=low[k]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">		e[u][v]=<span class="number">1</span>;e[v][u]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    dij(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t=low[n];</span><br><span class="line">    dij(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t!=INF&amp;&amp;low[n]!=INF) <span class="built_in">printf</span>(<span class="string">"%d"</span>,max(t,low[n]));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 2070 最小罚款</title>
    <url>/2019/01/18/51nod2070/</url>
    <content><![CDATA[<p><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=2070" target="_blank" rel="noopener">https://www.51nod.com/Challenge/Problem.html#!#problemId=2070</a></p>
<p>小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者m元。先不要太高兴！因为这些钱还不一定都是你的？！接下来主持人宣布了比赛规则：</p>
<p>首先，比赛时间分为n个时段(n≤500)，它又给出了很多小游戏，每个小游戏都必须在规定期限ti前完成(1≤ti≤n)。如果一个游戏没能在规定期限前完成，则要从奖励费m元中扣去一部分钱wi，wi为自然数，不同的游戏扣去的钱是不一样的。现在你要设计方法，使得你能得到最多的奖励。<br>输入<br>输入共 4 行<br>第 1 行为 m ，表示一开始奖励给每位参赛者的钱；<br>第 2 行为 n，表示有 n 个小游戏；<br>第 3 行有 n 个数，分别表示游戏 1 到 n 的规定完成期限；<br>第 4 行有 n 个数，分别表示游戏 1 到 n 不能在规定期限前完成的扣款数。<br>输出<br>输出文件仅 1 行。表示小伟能赢取最多的钱。<br>输入样例<br>10000<br>7<br>4 2 4 3 1 4 6<br>70 60 50 40 30 20 10<br>输出样例<br>9950</p>
<blockquote>
<p>方法一：按截止时间排序<br>考虑两个游戏，如果完成时间都在规定期限之前，顺序是无所谓的。如果新加的游戏使得完成时间大于规定期限那么选择一个 wi 小的删去，可能是删掉新加入的游戏也可能是已加入的<br> 方法二：按收益排序<br> 对于两个游戏，首先尝试收益高的(截止时间 = t )，是否能安排上。如果 （ t-1 , t ）时间段可以用则安排上并标记，否则尝试 （t-2 , t-1）时间段，依序往下，如都已被占用 ，则放弃该活动。 不能安排的活动不能替代已安排的活动。<br> 过程中用并查集管理时间段。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500+10</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; a[MAX];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d\n%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].first);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].second);</span><br><span class="line">	sort(a,a+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		p.push(-a[i].second);</span><br><span class="line">		<span class="keyword">if</span>(p.size()&gt;a[i].first)&#123;</span><br><span class="line">			ans+=p.top();</span><br><span class="line">			p.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,m+ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; a[MAX];</span><br><span class="line"><span class="keyword">int</span> f[MAX],m,n,ans,t=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==f[x]? x :f[x] = find(f[x]);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; &amp;x, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt;&amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.second&gt;y.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].first);</span><br><span class="line">		<span class="keyword">if</span>(a[i].first &gt; n) f[a[i].first] =n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].second);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		f[i]=i;</span><br><span class="line">	sort(a,a+n,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t= find(a[i].first);</span><br><span class="line">		<span class="keyword">if</span>(t&gt;<span class="number">0</span>)	f[t] = f[t<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">else</span> ans+=a[i].second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,m-ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>STL</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>51 nod 2176 n 最大的质因数</title>
    <url>/2020/01/01/51nod2176/</url>
    <content><![CDATA[<p><a href="http://www.51nod.com/Challenge/Problem.html#problemId=2176" target="_blank" rel="noopener">http://www.51nod.com/Challenge/Problem.html#problemId=2176</a></p>
<blockquote>
<p>对于 n ，一直除去因子直到无法再除为止。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll t,n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">		k=<span class="number">2</span>; </span><br><span class="line">		<span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span>(n%k==<span class="number">0</span>) n/=k;</span><br><span class="line">			k++;</span><br><span class="line">			<span class="keyword">if</span>(k*k&gt;n&amp;&amp;n&gt;<span class="number">1</span>) k=n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,k<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>Assign Mice Holes</title>
    <url>/2020/01/08/AssignMiceHoles/</url>
    <content><![CDATA[<p><a href="https://practice.geeksforgeeks.org/problems/assign-mice-holes/0" target="_blank" rel="noopener">https://practice.geeksforgeeks.org/problems/assign-mice-holes/0</a></p>
<p>Given, N Mice and N holes are placed in a straight line. Each hole can accommodate only 1 mouse. A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x -1. Any of these moves consumes 1 minute. Write a program to assign mice to holes so that the time when the last mouse gets inside a hole is minimized.</p>
<p>Input:<br>First line of input contains a single integer T, which denotes the number of test cases. T test cases follows, first line of each test case contains a single integer N which denotes the number of mice and holes. Second line of each test case contains N space separated integers which denotes the position of mice initially. Third line of each test case also contains N space separated integers which denotes the position of holes.</p>
<p>Output:<br>For each test case in a new line print the minimum time required in which all the mice can get into the holes.<br>Example:<br>Input:<br>2<br>3<br>4 -4 2<br>4 0 5<br>8<br>-10 -79 -79 67 93 -85 -28 -94<br>-2 9 69 25 -31 23 50 78<br>Output:<br>4<br>102</p>
<blockquote>
<p>对洞和老鼠排序，每只老鼠选距离它最近的一个洞口。<br>可以证明这样选择不会造成更差的结果</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m[MAX],h[MAX],t,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]);</span><br><span class="line">		sort(m,m+n);</span><br><span class="line">		sort(h,h+n);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">            <span class="keyword">if</span> (ans &lt; <span class="built_in">abs</span>(m[i]-h[i])) </span><br><span class="line">                ans = <span class="built_in">abs</span>(m[i]-h[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1334C Circle of Monsters</title>
    <url>/2020/04/11/CF1334C/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1334/problem/C" target="_blank" rel="noopener"> Circle of Monsters</a></p>
<p>题意：n 个怪物站成一圈，有生命值 ai 和死亡后的自爆值 bi , 当一个怪物死亡后会自爆伤害下一个怪物，可以连锁反应。每一发子弹可以对怪物造成一点伤害，求最小代价杀光所有怪物。</p>
<blockquote>
<p>杀死第 i 个怪物需要 e[i] = min(0, a[i] - b[i-1]) 发子弹, 不考虑第一个那么所消耗的子弹 $\sum e[i]$ </p>
<p>然后枚举第一个点，取最小</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">ll e[MAX],a[MAX],b[MAX],ans,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		fi(i,<span class="number">0</span>,n)<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">		sum = <span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			e[i] = max(<span class="number">0l</span>l,a[i] - b[(i<span class="number">-1</span>+n)%n]);</span><br><span class="line">			sum += e[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ans = INF;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)</span><br><span class="line">			ans = min(ans,sum + a[i] - e[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1337C Linova and Kingdom [ 贪心 dfs ]</title>
    <url>/2020/04/16/CF1337C/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1337/problem/C" target="_blank" rel="noopener">C. Linova and Kingdom</a></p>
<p>There are n cities and n−1 two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from 1 to n, and the city 1 is the capital of the kingdom. So, the kingdom has a tree structure.</p>
<p>As the queen, Linova plans to choose <strong>exactly</strong> k cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.</p>
<p>A meeting is held in the capital once a year. To attend the meeting, each <strong>industry city</strong> sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).</p>
<p>Traveling in tourism cities is pleasant. For each envoy, his <em>happiness</em> is equal to the number of <strong>tourism cities</strong> on his path.</p>
<p>In order to be a queen loved by people, Linova wants to choose k cities which can maximize the sum of <em>happinesses</em> of all envoys. Can you calculate the maximum sum for her?</p>
<p><strong>input</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure>
<p><strong>output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><img src="/.io//d811810ac8e2c43cb201a3388ae50f1b3e17a687.png" alt="img"></p>
<blockquote>
<p>考虑例子，猜想优先选最深的节点 ？或首先选叶子节点？首先选叶子节点是有问题，比如</p>
<p><img src="/.io//graph.png" alt></p>
<p><strong>k=3</strong> , 可以看出先选叶子或者最深是不可行的。可以观察到：1. 每选一个分支节点，都会使得其所有子孙节点的收益 - 1。2、选择一个节点 u 的收益为 这点的深度 l[u] - sum[u] , sum[u] 为 u  所有子孙节点个数。</p>
<p>所以按照 l[u] - sum[u] 排序，依次选择即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,u,v;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX],color[MAX];</span><br><span class="line"><span class="keyword">int</span> l[MAX],fa[MAX];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to =v;</span><br><span class="line">	e[tot].next = h[u];</span><br><span class="line">	h[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i,sum;</span><br><span class="line">	node(<span class="keyword">int</span> _i,<span class="keyword">int</span> _sum)&#123;</span><br><span class="line">		i=_i;sum=_sum;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> l[i] - sum &lt; l[x.i] - x.sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		l[v]=l[u]+<span class="number">1</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		cnt += dfs(v) +<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q.push(node(u,cnt));</span><br><span class="line">	sum[u]=cnt;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	mem(h,<span class="number">-1</span>);mem(vis,<span class="number">0</span>);mem(color,<span class="number">0</span>);</span><br><span class="line">	sf(n);sf(k);</span><br><span class="line">	fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		sf(u);sf(v);</span><br><span class="line">		addedge(u,v); addedge(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	fa[<span class="number">1</span>]=<span class="number">-1</span>;l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(k &amp;&amp; !q.empty())&#123;</span><br><span class="line">		node t = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		color[t.i]=<span class="number">1</span>;</span><br><span class="line">		k--;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(color[i])</span><br><span class="line">			ans += l[i] - sum[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1339B Sorted Adjacent Differences</title>
    <url>/2020/04/13/CF1339B/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1339/problem/B" target="_blank" rel="noopener">B. Sorted Adjacent Differences</a></p>
<p>You have array of n numbers $a_{1}, a_{2}, \ldots, a_{n}$.</p>
<p>Rearrange these numbers to satisfy $|a_{1} - a_{2}| \le |a_{2} - a_{3}| \le \ldots \le |a_{n-1} - a_{n}|$, where |x| denotes absolute value of xx. It’s always possible to find such rearrangement.</p>
<p>Note that all numbers in a are not necessarily different. In other words, some numbers of a may be same.</p>
<p>You have to answer independent t test cases.</p>
<blockquote>
<p>题意：对数组排序使得前后两项之差的绝对值递增</p>
<p>Sort the list, and make an oscillation centered on middle element like picture below.</p>
<p><img src="/.io//789052e1f8c8408dbe8ed8a9a628b6d6aebb1b11.png" alt="img"></p>
<p>In this way, you will always achieve to make $|a_{i} - a_{i+1}| \le |a_{i+1} - a_{i+2}|$ for all ii. Time complexity is O(nlogn).</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t,n,a[MAX],b[MAX],l,r,cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		fi(i,<span class="number">0</span>,n) sf(a[i]);</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) l = n/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> l = n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">		r=l+<span class="number">1</span>;cnt=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l&gt;=<span class="number">0</span> || r &lt; n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)	b[cnt++]=a[l--];</span><br><span class="line">			<span class="keyword">else</span> b[cnt++]=a[r++];</span><br><span class="line">		&#125;</span><br><span class="line">		fi(i,<span class="number">1</span>,cnt) <span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]);</span><br><span class="line">		pfc(<span class="string">"\n"</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1339C Powered Addition[ 贪心 ]</title>
    <url>/2020/04/13/CF1339C/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1339/problem/C" target="_blank" rel="noopener">C. Powered Addition</a></p>
<p>You have an array a of length n. For every positive integer xx you are going to perform the following operation during the xx-th second:</p>
<ul>
<li>Select some distinct indices $i_{1}, i_{2}, \ldots, i_{k}$ which are between 1 and n inclusive, and add 2x−12x−1 to each corresponding position of a. Formally, $a_{i_{j}} := a_{i_{j}} + 2^{x-1}$ for j=1,2,…,k. <strong>Note that you are allowed to not select any indices at all.</strong></li>
</ul>
<p>You have to make a nondecreasing as fast as possible. Find the smallest number T such that you can make the array nondecreasing after at most T seconds.</p>
<p>Array a is nondecreasing if and only if $a_{1} \le a_{2} \le \ldots \le a_{n}$.</p>
<p>You have to answer t independent test cases.</p>
<blockquote>
<p>对于结果 b[i] , $b[i] &gt;= b[i-1] , b[i] &gt;= a[i] , b[i] = a[i] + \sum 2^S$(S 为数集)</p>
<p>显然要使时间最小，则 $b[i]-a[i]$ 最小。此时，最长时间即 S 的最大值，二进制上即最左边的 1 的位置。</p>
<p>令 $k = a[i] - b[i-1];$ 表示 b[i] 需要 k 即符合条件，k&gt;0 无需处理， 而 k 必然是可以由 x 个 2的次幂相加得到，对于每一位需要的时间即最左边 1 的位置 ，遍历每一位取最大值即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,ans,k,le,a[MAX],b[MAX],cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>) sf(a[i]);</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		b[<span class="number">0</span>] = -INF;</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			k = a[i] - b[i<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>(k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">				b[i] = a[i];</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				k = -k;</span><br><span class="line">				b[i] = a[i] + k;</span><br><span class="line">				cnt = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span>(k)&#123; <span class="comment">//求最左边 1 的位置</span></span><br><span class="line">					cnt ++;</span><br><span class="line">					<span class="keyword">if</span>(k&amp;<span class="number">1</span>) &#123;</span><br><span class="line">						le = cnt;</span><br><span class="line">					&#125; </span><br><span class="line">					k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">				&#125; </span><br><span class="line">				ans = max(ans,le);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pfn(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1339D Edge Weight Assignment [ 构造贪心 ]</title>
    <url>/2020/09/26/CF1339D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1339/problem/D" target="_blank" rel="noopener">CF1339D Edge Weight Assignment</a></p>
<p>You have unweighted tree of n vertices. You have to assign a <strong>positive</strong> weight to each edge so that the following condition would hold:</p>
<ul>
<li>For every two different leaves v1 and v2 of this tree, <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR" target="_blank" rel="noopener">bitwise XOR</a> of weights of all edges on the simple path between v1 and v2 has to be equal to 0.</li>
</ul>
<p>Note that you can put <strong>very large</strong> positive integers (like $10^{10}$).</p>
<p>It’s guaranteed that such assignment always exists under given constraints. Now let’s define f as <strong>the number of distinct weights</strong> in assignment.</p>
<p><img src="/.io//822324016e7a6837336849481ecbe0190b03dfa3.png" alt="img"></p>
<p>In this example, assignment is valid, because bitwise XOR of all edge weights between every pair of leaves is 0. ff value is 2 here, because there are 2 distinct edge weights(4 and 5).</p>
<p><img src="/.io//82d52d5070be134d11729e65fab0a8709aae6b3f.png" alt="img"></p>
<p>In this example, assignment is invalid, because bitwise XOR of all edge weights between vertex 1 and vertex 6 (3,4,5,4) is not 0.</p>
<p>What are the minimum and the maximum possible values of f for the given tree? Find and print both.</p>
<p>Input</p>
<p>The first line contains integer n ($3≤n≤10^5$) — the number of vertices in given tree.</p>
<p>The ii-th of the next n−1 lines contains two integers ai and bi ($1≤ai&lt;bi≤n$) — it means there is an edge between ai and bi. It is guaranteed that given graph forms tree of n vertices.</p>
<p>Output</p>
<p>Print two integers — the minimum and maximum possible value of f can be made from valid assignment of given tree. Note that it’s always possible to make an assignment under given constraints.</p>
<p>Examples</p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先找到一个度为 1 的点作为树根构造树。记录每个节点的深度 d[i] 和其到其最深的叶子节点的距离 l[i]</p>
<p>可以观察到：</p>
<p>对于可分配的最大值有</p>
<p>1、一个父亲节点的所有 $l[i] = 1$ 的子节点一共可以分配一个值（因为之前的路径上的值是已经分配好的，要想 XOR 为 0, 这里必须分配同一个值），其他的可以各自分配一个。有一个例外就是 当 $d[i] &lt;= 3$ 因为到根节点的距离 = 2，所以不分配新的值。</p>
<p>对于可分配的最小值有</p>
<p>1、如果根到某一个叶子节点的边数为偶数，则分配一个值足以。</p>
<p>2、如果为奇数，则最多需要三个。简单证明：$x = 3 + x’$  , $x 为奇数x’ 为偶数$ 偶数分配一个值，三个奇数需要三个值，总的下来需要三个值。</p>
<p>所以可以这样判断，对于所有不为根的叶子节点如果有奇数，则可分配的最小值为 3，否则 为1。2 的话显然可以用 1 替换。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,sz[MAX],rt=<span class="number">0</span>,vis[MAX],l[MAX],d[MAX],_min=<span class="number">1</span>,_max=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to = v;</span><br><span class="line">	e[tot].next = head[u];</span><br><span class="line">	head[u] = tot++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">		d[v] = d[u]+<span class="number">1</span>;</span><br><span class="line">		l[u] = max(l[u],dfs(v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> l[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ++l[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> zo = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(l[v] == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(zo &amp;&amp; d[v]&gt;<span class="number">3</span>)&#123;</span><br><span class="line">				zo = <span class="number">0</span>;</span><br><span class="line">				_max ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(l[v]&gt;<span class="number">0</span>) _max++;</span><br><span class="line">		dfs2(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in","r",stdin);</span></span><br><span class="line">	mem(head,<span class="number">-1</span>);mem(sz,<span class="number">0</span>);mem(vis,<span class="number">0</span>);mem(l,<span class="number">0</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		sf(a);sf(b);</span><br><span class="line">		addedge(a,b);addedge(b,a);</span><br><span class="line">		sz[a]++;sz[b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(sz[i]==<span class="number">1</span>) &#123;</span><br><span class="line">			rt = i; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	d[rt] = <span class="number">1</span>;</span><br><span class="line">	dfs(rt);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(sz[i] == <span class="number">1</span> &amp;&amp; i != rt &amp;&amp; (d[i]<span class="number">-1</span>) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			_min = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	dfs2(rt);</span><br><span class="line">	pf(_min);pfc(<span class="string">" "</span>);pfn(_max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1342C C. Yet Another Counting Problem [ lcm ]</title>
    <url>/2020/04/27/CF1342C/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1342/problem/C" target="_blank" rel="noopener">C. Yet Another Counting Problem</a></p>
<p>You are given two integers a and b, and q queries. The i-th query consists of two numbers li and ri, and the answer to it is the number of integers x such that  $li≤x≤ri$, and $((x \bmod a)  \bmod b) \ne ((x \bmod b) \bmod a)$. Calculate the answer for each query.</p>
<p>Recall that y mod z is the remainder of the division of y by z. For example, 5 mod 3=2, 7 mod 8=7 , 9 mod 4=1, 9 mod 9=0.</p>
<p>Input</p>
<p>The first line contains one integer t (1≤t≤100) — the number of test cases. Then the test cases follow.</p>
<p>The first line of each test case contains three integers a, b and q (1≤a,b≤200; 1≤q≤500).</p>
<p>Then q lines follow, each containing two integers li and ri $(1≤li≤ri≤10^{18})$ for the corresponding query.</p>
<p>Output</p>
<p>For each test case, print q integers — the answers to the queries of this test case in the order they appear.</p>
<p>Example</p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 6 5</span><br><span class="line">1 1</span><br><span class="line">1 3</span><br><span class="line">1 5</span><br><span class="line">1 7</span><br><span class="line">1 9</span><br><span class="line">7 10 2</span><br><span class="line">7 8</span><br><span class="line">100 200</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 2 4 </span><br><span class="line">0 91</span><br></pre></td></tr></table></figure>
<blockquote>
<p> $((x \bmod a)  \bmod b) , ((x \bmod b) \bmod a)$ 的值以 lcm(a,b) 周期性变化。统计每一个周期中不一样的个数 cnt</p>
<p>对于一个数 x , (x/k) * cnt + f[x % k] = ans;</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll l,r,a,b,q,f[<span class="number">50000</span>];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*b / gcd(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;q); </span><br><span class="line">		ll k =lcm(a,b);</span><br><span class="line">		ll cnt =<span class="number">0</span>;</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>((i%a)%b != (i%b)%a) &#123;</span><br><span class="line">				cnt ++;</span><br><span class="line">				f[i]=f[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> f[i]=f[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;l,&amp;r); </span><br><span class="line">			ll ans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(a==b) &#123;</span><br><span class="line">				pfc(<span class="string">"0 "</span>);<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans = ((r/k) * cnt + f[r%k]) - (((l<span class="number">-1</span>)/k) * cnt + f[(l<span class="number">-1</span>)%k]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1343D Constant Palindrome Sum [ 贪心 尺取法 前缀和]</title>
    <url>/2020/04/22/CF1343D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/D" target="_blank" rel="noopener">CF1343D Constant Palindrome Sum</a></p>
<p>You are given an array a consisting of n integers (it is guaranteed that n is even, i.e. divisible by 2). All ai does not exceed some integer k.</p>
<p>Your task is to replace the <strong>minimum</strong> number of elements (replacement is the following operation: choose some index i from 1 to n and replace ai with some integer in range [1;k][1;k]) to satisfy the following conditions:</p>
<ul>
<li>after all replacements, all ai are positive integers not greater than k;</li>
<li>for all i from 1 to n/2 the following equation is true: ai+an−i+1=x, where x should be <strong>the same</strong> for all n2 pairs of elements.</li>
</ul>
<p>You have to answer t independent test cases.</p>
<blockquote>
<p>每一对数，当 $x \in [min(a_i,a_{n−i+1})+1;max(a_i,a_{n−i+1})+k] $, 至多只需要修改一个，否则需要修改两个；特别的，当 $x=a[i]+a[n-i+1]$ 时，无需修改；使用前缀和，$d[min(a_i,a_{n−i+1})+1]$ = -1; $d[max(a_i,a_{n−i+1})+k+1]=1$ 因为可能多个值相同所以用 $++,–$  .</p>
<p>对于 $x=a[i]+a[n-i+1]$   ,$d[a[i]+a[n-i-1]]–;  d[a[i]+a[n-i-1]+1]++; $</p>
<p>所以对于 i 需要修改 $d[max(a_i,a_{n−i+1})+k] - d[min(a_i,a_{n−i+1})+1]$ 次。</p>
<p>然后，从左到右扫描一遍</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k,a[MAX],d[MAX*<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ans = INF;</span><br><span class="line">		mem(d,<span class="number">0</span>);</span><br><span class="line">		sf(n);sf(k);</span><br><span class="line">		fi(i,<span class="number">0</span>,n) sf(a[i]);</span><br><span class="line">		fi(i,<span class="number">0</span>,n/<span class="number">2</span>)&#123;</span><br><span class="line">			d[<span class="number">0</span>]+=<span class="number">2</span>;</span><br><span class="line">			d[min(a[i],a[n-i<span class="number">-1</span>])+<span class="number">1</span>]--;</span><br><span class="line">			d[max(a[i],a[n-i<span class="number">-1</span>])+k+<span class="number">1</span>]++;</span><br><span class="line">			d[a[i]+a[n-i<span class="number">-1</span>]]--;</span><br><span class="line">			d[a[i]+a[n-i<span class="number">-1</span>]+<span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(i,<span class="number">1</span>,k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">			d[i]+=d[i<span class="number">-1</span>];</span><br><span class="line">			ans = min(ans,d[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		pfn(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>尺取法</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1343E Weights Distributing[ 贪心 最短路 ]</title>
    <url>/2020/04/22/CF1343E/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1343/problem/E" target="_blank" rel="noopener">E. Weights Distributing</a></p>
<p>You are given an undirected unweighted graph consisting of n vertices and m edges (which represents the map of Bertown) and the array of prices p of length m. It is guaranteed that there is a path between each pair of vertices (districts).</p>
<p>Mike has planned a trip from the vertex (district) a to the vertex (district) b and then from the vertex (district)b to the vertex (district) c. He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (<strong>he pays each time he goes along the road</strong>). The list of prices that will be used pp is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.</p>
<p>You are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the <strong>minimum</strong> possible. <strong>Note that you cannot rearrange prices after the start of the trip</strong>.</p>
<p><strong>Example</strong></p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 3 2 3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">7 9 1 5 7</span><br><span class="line">2 10 4 8 5 6 7 3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">4 2</span><br><span class="line">5 6</span><br><span class="line">1 7</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>One of the possible solution to the first test case of the example:</p>
<p>You have to answer t independent test cases.</p>
<p><img src="/.io//f1d0f51cf563c458a58154af19f523d4cb7bafc0.png" alt="img"></p>
<blockquote>
<p> $a\rightarrow b \rightarrow c$ 可以观察出：</p>
<p>1、$a\rightarrow b \rightarrow c$ 在一条路径上</p>
<p>2、$a \rightarrow x , x \rightarrow b, b \rightarrow x, x\rightarrow c$  四段</p>
<p>枚举 x ，$ans = \sum sum[db[x]] + sum[da[x]+db[x]+dc[x]]$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,a,b,c,u,v,p[MAX];</span><br><span class="line"><span class="keyword">int</span> da[MAX],db[MAX],dc[MAX];</span><br><span class="line">ll ans,f[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> h[MAX],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to = v;</span><br><span class="line">	e[tot].next = h[u];</span><br><span class="line">	h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> d[])</span></span>&#123;</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = h[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(d[v]==INF)&#123;</span><br><span class="line">				d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);sf(m);sf(a);sf(b);sf(c);</span><br><span class="line">		fi(i,<span class="number">0</span>,m) sf(p[i]);</span><br><span class="line">		mem(h,<span class="number">-1</span>);tot=<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">			sf(u);sf(v);</span><br><span class="line">			addedge(u,v);</span><br><span class="line">			addedge(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p,p+m);</span><br><span class="line">		fi(i,<span class="number">0</span>,m) f[i+<span class="number">1</span>] = f[i]+p[i]; <span class="comment">//</span></span><br><span class="line">		mem(da,<span class="number">0x3f</span>);mem(db,<span class="number">0x3f</span>);mem(dc,<span class="number">0x3f</span>);</span><br><span class="line">		bfs(a,da);</span><br><span class="line">		bfs(b,db);</span><br><span class="line">		bfs(c,dc);</span><br><span class="line">		ans = LINF;</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(da[i]+db[i]+dc[i]&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">			ans = min(ans,f[db[i]]+f[da[i]+db[i]+dc[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1348C Phoenix and Distribution [ 贪心 ]</title>
    <url>/2020/05/02/CF1348C/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1348/problem/C" target="_blank" rel="noopener">C. Phoenix and Distribution</a></p>
<p>Phoenix has a string s consisting of lowercase Latin letters. He wants to distribute all the letters of his string into k <strong>non-empty</strong> strings a1,a2,…,ak such that every letter of s goes to exactly one of the strings ai. The strings ai <strong>do not</strong> need to be substrings of s. Phoenix can distribute letters of s and rearrange the letters within each string ai however he wants.</p>
<p>For example, if s= abba and k=2, Phoenix may distribute the letters of his string in many ways, such as:</p>
<ul>
<li>ba and ba</li>
<li>a and abb</li>
<li>ab and ab</li>
<li>aa and bb</li>
</ul>
<p>But these ways are invalid:</p>
<ul>
<li>baa and ba</li>
<li>b and ba</li>
<li>baba and empty string (ai should be non-empty)</li>
</ul>
<p>Phoenix wants to distribute the letters of his string s into k strings a1,a2,…,ak to <strong>minimize</strong> the lexicographically maximum string among them, i. e. minimize max(a1,a2,…,ak). Help him find the optimal distribution and print the minimal possible value of max(a1,a2,…,ak).</p>
<p>String x is lexicographically less than string y if either x is a prefix of y and x≠y, or there exists an index i (1≤i≤min(|x|,|y|)) such that xi &lt; yi and for every j (1≤j&lt;i) xj=yj. Here |x|denotes the length of the string x.</p>
<p><strong>题意：</strong> 将一组字符方程 k 份，使得字典序最大的一组最小。</p>
<blockquote>
<p>可以观察到：</p>
<p>1、k 组的首字母应当最小，如果 k 组首字母有不同的。那么最大值就这个较大的字母，因为可以把其他所有字母加到别的组后面，并且不会比它大。</p>
<p>2、较大的字母应当放到末尾，且长度越大越好。</p>
<p>3、如果有两串字符相同，</p>
<ul>
<li>剩余未分配的字符相同，那么平均分到两组上面，是最优的</li>
<li>剩余未分配的字符不相同，显然只分配给一组是最优的，因为可以使得较大的字母位置更靠后。</li>
</ul>
<p>所以，可以这样贪心：</p>
<p>先从小到大排序，然后分配首字母，如果有不同的，直接输出最大的字母即可。</p>
<p>然后，后续分配只在当前所有字母加起来相等的组上分配，并且更新组数。</p>
<p>分配的时候，如果后续字母相同，则可以分配到各个相等的组上，否则只分配到第一组上。</p>
<p>最后，答案就是第一组。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k,l,cnt;</span><br><span class="line"><span class="keyword">char</span> a[MAX];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; res[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);sf(k);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">		l = <span class="built_in">strlen</span>(a);</span><br><span class="line">		sort(a,a+l);</span><br><span class="line">		fi(i,<span class="number">0</span>,k) res[i].clear();</span><br><span class="line">		fi(i,<span class="number">0</span>,k) res[i].pb(a[i]);</span><br><span class="line">		<span class="keyword">if</span>(res[k<span class="number">-1</span>][<span class="number">0</span>] != res[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(res[k<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">""</span>); <span class="keyword">continue</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> j = k,cnt=k;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;l)&#123;</span><br><span class="line">			fi(i,<span class="number">0</span>,cnt)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=l) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span>(!i) res[i].pb(a[j++]);</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span>(a[j] == a[j<span class="number">-1</span>] &amp;&amp; a[j] == a[l<span class="number">-1</span>] )&#123;</span><br><span class="line">						res[i].pb(a[j]);</span><br><span class="line">						j++;</span><br><span class="line">					&#125;<span class="keyword">else</span> cnt = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(j,<span class="number">0</span>,res[<span class="number">0</span>].size())&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(res[<span class="number">0</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1348D Phoenix and Science [ 贪心+二分 ]</title>
    <url>/2020/05/02/CF1348D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1348/problem/D" target="_blank" rel="noopener">D. Phoenix and Science</a></p>
<p>Phoenix has decided to become a scientist! He is currently investigating the growth of bacteria.</p>
<p>Initially, on day 1, there is one bacterium with mass 1.</p>
<p>Every day, some number of bacteria will split (possibly zero or all). When a bacterium of mass m splits, it becomes two bacteria of mass m/2 each. For example, a bacterium of mass 3 can split into two bacteria of mass 1.5.</p>
<p>Also, every night, the mass of every bacteria will increase by one.</p>
<p>Phoenix is wondering if it is possible for the total mass of all the bacteria to be exactly n. If it is possible, he is interested in the way to obtain that mass using the minimum possible number of nights. Help him become the best scientist!</p>
<p>Example</p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 0 2 </span><br><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考虑增量，设最小需要 k 天， 那么第 i 天共收益 (k - i + 1) * c[i] , c[i] 为第 i 天有多少细菌。</p>
<p>可以观察到：</p>
<p>1、已经存在的细菌，产生的收益已经固定。即如果一个细菌已经存在，那么一次性计算出所有收益。</p>
<p>2、第 i 天，新增加的细菌数量为 ( 0 ~ c[i-1] ) , 设新增 x 个，如果  x * (k - i + 1)  &lt;= n (n 为还需要多少),那么就新增。这样不会影响最后结果，因为可以选择后面不在新增（分裂）。</p>
<p>贪心：k 次循环，每次二分计算出当前最多可以分裂多少。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		n--;sum=<span class="number">0</span>;</span><br><span class="line">		db k = log2(n+<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">int</span> tmp = (<span class="keyword">int</span>)k;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1</span>&lt;&lt;tmp == n+<span class="number">2</span>) tmp--; <span class="comment">//天数</span></span><br><span class="line">		pfn(tmp);</span><br><span class="line">		<span class="keyword">if</span>(tmp==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>) &#123;</span><br><span class="line">			pfc(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> last = <span class="number">1</span>;</span><br><span class="line">		n -= tmp; </span><br><span class="line">		fi(i,<span class="number">1</span>,tmp+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> l = <span class="number">1</span>,r = last,m,g;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">				m = (l+r)/<span class="number">2</span>;</span><br><span class="line">				g = m * (tmp-i+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(g==n)&#123;</span><br><span class="line">					r = m;<span class="keyword">break</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(g &lt; n )&#123;</span><br><span class="line">					l = m+<span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					r = m<span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(r * (tmp-i+<span class="number">1</span>) &lt;= n)&#123;</span><br><span class="line">				n -= r * (tmp-i+<span class="number">1</span>) ;</span><br><span class="line">				last += r;</span><br><span class="line">				pf(r);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				pfc(<span class="string">"0"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			pfc(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1359D Yet Another Yet Another Task [ dp ]</title>
    <url>/2020/05/31/CF1359D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1359/problem/D" target="_blank" rel="noopener">D. Yet Another Yet Another Task</a></p>
<p>题意：一个数列，找字段和去除段内最大值后最大的区间；</p>
<blockquote>
<p>枚举最大值 _max，对于有比 _max 大的区间都不考虑，在此基础上求最大字段和</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a[MAX],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n) sf(a[i]);</span><br><span class="line">	fi(_max,<span class="number">1</span>,<span class="number">31</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> em=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp= a[i]&gt;_max?-INF:a[i];</span><br><span class="line">			em=max(em,<span class="number">0</span>)+tmp;</span><br><span class="line">			res=max(res,em);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = max(ans,res-_max);</span><br><span class="line">	&#125;</span><br><span class="line">	pfn(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1363E Tree Shuffling [ dfs ]</title>
    <url>/2020/06/04/CF1363E/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1363/problem/E" target="_blank" rel="noopener">CF1363E Tree Shuffling</a></p>
<p>题意：Ashish has a tree consisting of n nodes numbered 1 to n rooted at node 1. The ii-th node in the tree has a cost a[i], and binary digit b[i] is written in it. He wants to have binary digit c[i] written in the i-th node in the end.</p>
<p>To achieve this, he can perform the following operation any number of times:</p>
<p>Select any k nodes from the subtree of any node u, and shuffle the digits in these nodes as he wishes, incurring a cost of k⋅a[u]. Here, he can choose k ranging from 1 to the size of the subtree of u.</p>
<p>He wants to perform the operations in such a way that every node finally has the digit corresponding to its target.</p>
<p>Help him find the minimum total cost he needs to spend so that after all the operations, every node u has digit c[u] written in it, or determine that it is impossible.</p>
<p><img src="/.io//02ed56cecf6dea5880ad08c321cf503b04888bd7.png" alt="img"></p>
<p>Examples</p>
<p>input1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 0 1</span><br><span class="line">20 1 0</span><br><span class="line">300 0 1</span><br><span class="line">4000 0 0</span><br><span class="line">50000 1 0</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure>
<p>output1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>input2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">10000 0 1</span><br><span class="line">2000 1 0</span><br><span class="line">300 0 1</span><br><span class="line">40 0 0</span><br><span class="line">1 1 0</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure>
<p>output2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>显然可以观察到： 当一个节点拥有 0 需要 1 时，可以看作整体拥有一个 “0” 资源，对于 1 同理；</p>
<p>所以只有当两个相等是才是有解的。</p>
<p>可以观察到，当在某一个节点 u 操作时</p>
<p>1、此时的代价应为 u 到root 路径上最小代价，此时有两种方法，一是提前计算出在某节点操作的最小代价；二是将操作推迟到最小处再执行</p>
<p>2、当节点 u 的子节点操作后，该节点 u 所拥有的 0/1 个数是变化的，可以在递归回溯的时候更新</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,u,v;</span><br><span class="line">vi g[MAX];</span><br><span class="line">ll a[MAX],b[MAX],c[MAX],vis[MAX],fa[MAX],m[MAX],ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,ll _min)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,g[u].size())&#123;</span><br><span class="line">		<span class="keyword">int</span> v=g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		m[v]=min(m[v],_min);</span><br><span class="line">		dfs(v,m[v]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">pii <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	pii cnt;</span><br><span class="line">	<span class="keyword">if</span>(b[u]!=c[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[u]) cnt.first++;</span><br><span class="line">		<span class="keyword">else</span> cnt.second++;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,g[u].size())&#123;</span><br><span class="line">		<span class="keyword">int</span> v=g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">		pii res= dfs2(v);</span><br><span class="line">		cnt.first+=res.first;</span><br><span class="line">		cnt.second+=res.second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[u]&lt;=m[u])&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp =  min(cnt.first, cnt.second);</span><br><span class="line">		ans += <span class="number">2</span>*tmp*a[u];</span><br><span class="line">		cnt.first-=tmp;</span><br><span class="line">		cnt.second-=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in","r",stdin);</span></span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line">		m[i]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		sf(u);sf(v);</span><br><span class="line">		g[u].pb(v);	g[v].pb(u);</span><br><span class="line">	&#125;</span><br><span class="line">	mem(vis,<span class="number">0</span>);mem(fa,<span class="number">0</span>);</span><br><span class="line">	dfs(<span class="number">1</span>,a[<span class="number">1</span>]);</span><br><span class="line">	pii res=dfs2(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(res.first||res.second)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"-1"</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1365D Solve The Maze [ dfs ]</title>
    <url>/2020/09/26/CF1365D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1365/problem/D" target="_blank" rel="noopener">CF1365D Solve The Maze </a></p>
<p>Vivek has encountered a problem. He has a maze that can be represented as an n×m grid. Each of the grid cells may represent the following:</p>
<ul>
<li>Empty — ‘.’</li>
<li>Wall — ‘#’</li>
<li>Good person  — ‘G’</li>
<li>Bad person — ‘B’</li>
</ul>
<p>The only escape from the maze is at cell (n,m)(n,m).</p>
<p>A person can move to a cell only if it shares a side with their current cell and does not contain a wall. Vivek wants to block some of the empty cells by replacing them with walls in such a way, that all the good people are able to escape, while none of the bad people are able to. A cell that initially contains ‘G’ or ‘B’ <strong>cannot be blocked</strong> and <strong>can be travelled through</strong>.</p>
<p>Help him determine if there exists a way to replace some (zero or more) empty cells with walls to satisfy the above conditions.</p>
<p><strong>It is guaranteed that the cell (n,m) is empty.</strong> Vivek can also block this cell.</p>
<p>Input</p>
<p>The first line contains one integer t (1≤t≤100) — the number of test cases. The description of the test cases follows.</p>
<p>The first line of each test case contains two integers n, m (1≤n,m≤50)— the number of rows and columns in the maze.</p>
<p>Each of the next n lines contain mm characters. They describe the layout of the maze. If a character on a line equals ‘.’, the corresponding cell is empty. If it equals ‘#’, the cell has a wall. ‘G’ corresponds to a good person and ‘B’ corresponds to a bad person.</p>
<p>Output</p>
<p>For each test case, print “Yes” if there exists a way to replace some empty cells with walls to satisfy the given conditions. Otherwise print “No”</p>
<p>You may print every letter in any case (upper or lower).</p>
<p>Example</p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 1</span><br><span class="line">.</span><br><span class="line">1 2</span><br><span class="line">G.</span><br><span class="line">2 2</span><br><span class="line">#B</span><br><span class="line">G.</span><br><span class="line">2 3</span><br><span class="line">G.#</span><br><span class="line">B#.</span><br><span class="line">3 3</span><br><span class="line">#B.</span><br><span class="line">#..</span><br><span class="line">GG.</span><br><span class="line">2 2</span><br><span class="line">#B</span><br><span class="line">B.</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题意：一个网格上有好人有坏人，放置一些墙，使得只有好人能到达 （n,m）</p>
<p>可以观察到：</p>
<p>1、好人G 到达终点的路径上不能出现坏人 B, 显然。</p>
<p>2、坏人旁边不能有好人</p>
<p>所以可以这样处理：</p>
<p>1、先判断所有的好人是否可以不经过坏人到达终点，不可以则输出 “NO”。</p>
<p>2、然后处理所有坏人，将每一个坏人周围为 “.” 的全改为 “#” ，“B” 不处理，但是如果有 “G” 则不可行。因为经过上一步的处理，所有的好人都是不经过坏人到达终点的，所以此坏人B也是可以到达终点。</p>
<p>3、再次判断是否所有的好人能否都到达终点。</p>
<p>需要优化的地方是: 对于已经判断可以到达的点，后续再次经过时，可直接跳出。另 dfs 也需即时跳出。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">50</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,gx[<span class="number">3000</span>],gy[<span class="number">3000</span>],bx[<span class="number">3000</span>],by[<span class="number">3000</span>],gl,bl;</span><br><span class="line"><span class="keyword">int</span> vis[MAX][MAX],rev[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,ok=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ok) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==n &amp;&amp; y==m) &#123;</span><br><span class="line">		ok = <span class="number">1</span>;	<span class="keyword">return</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tx = x + aw[i][<span class="number">0</span>],ty = y + aw[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; vis[tx][ty] != key&amp;&amp;a[tx][ty]!=<span class="string">'#'</span>&amp;&amp;a[tx][ty]!=<span class="string">'B'</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(rev[tx][ty]) &#123;</span><br><span class="line">				ok =<span class="number">1</span> ;<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			vis[tx][ty]=key; </span><br><span class="line">			dfs(tx,ty,key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in","r",stdin);</span></span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);sf(m);</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">		gl=bl=<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">			fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]==<span class="string">'G'</span>) &#123;</span><br><span class="line">					gx[gl] = i; gy[gl++] = j;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'B'</span>)&#123;</span><br><span class="line">					bx[bl] = i;by[bl++] = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		mem(vis,<span class="number">0</span>);mem(rev,<span class="number">0</span>);</span><br><span class="line">		fi(i,<span class="number">0</span>,gl)&#123;</span><br><span class="line">			ok=<span class="number">0</span>;</span><br><span class="line">			dfs(gx[i],gy[i],i+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(ok) &#123;</span><br><span class="line">				cnt++;rev[gx[i]][gy[i]] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt!=gl)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bl==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ok =<span class="number">1</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,bl)&#123;</span><br><span class="line">			ok = <span class="number">1</span>;</span><br><span class="line">			fi(j,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> tx = bx[i] + aw[j][<span class="number">0</span>],ty = by[i] + aw[j][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(judge(tx,ty) )&#123;</span><br><span class="line">					<span class="keyword">if</span>(a[tx][ty]==<span class="string">'.'</span>) a[tx][ty] = <span class="string">'#'</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(a[tx][ty]==<span class="string">'G'</span>)&#123;</span><br><span class="line">						ok =<span class="number">0</span> ;<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!ok) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!ok) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		mem(vis,<span class="number">0</span>);mem(rev,<span class="number">0</span>);</span><br><span class="line">		fi(i,<span class="number">0</span>,gl)&#123;</span><br><span class="line">			ok=<span class="number">0</span>;</span><br><span class="line">			dfs(gx[i],gy[i],i+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(ok) &#123;cnt++;rev[gx[i]][gy[i]] = <span class="number">1</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt!=gl)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="keyword">continue</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1370D D. Odd-Even Subsequence [ 二分 ]</title>
    <url>/2020/06/21/CF1370D/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1370/problem/D" target="_blank" rel="noopener">D. Odd-Even Subsequence</a></p>
<p>题意： 对于数列 a , 找出数列的子序列 s , 使得 $min(max(s_1, s_3,       s_5, \ldots), max(s_2, s_4, s_6, \ldots))$ 最小。</p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 4</span><br><span class="line">5 3 50 2 4 5</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，奇偶交替是一定的，所以可以选择一个奇下标元素后再选择偶的。</p>
<p>假定最小元素在奇序列中，</p>
<p>二分答案，遍历原序列 a，观察是否可以组成长度 &gt; k 满足所有元素都小于 x 的子序列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,k,a[MAX],l=INF,r=<span class="number">0</span>,ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			cnt ++;</span><br><span class="line">			flag = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=x)&#123;</span><br><span class="line">				cnt ++;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(n);sf(k);</span><br><span class="line">	fi(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">		sf(a[i]);</span><br><span class="line">		l = min(l,a[i]);</span><br><span class="line">		r = max(r,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(f(m,<span class="number">0</span>) || f(m,<span class="number">1</span>))&#123;</span><br><span class="line">			ans = m;</span><br><span class="line">			r = m<span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			l = m+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1433F F. Zero Remainder Sum [dp]</title>
    <url>/2020/10/22/CF1433F/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1433/problem/F" target="_blank" rel="noopener">F. Zero Remainder Sum</a></p>
<p>You are given a matrix a of size n×m consisting of integers.</p>
<p>You can choose <strong>no more than</strong> $\left\lfloor\frac{m}{2}\right\rfloor$ elements in <strong>each row</strong>. Your task is to choose these elements in such a way that their sum is <strong>divisible by</strong> k and this sum is the <strong>maximum</strong>.</p>
<p>In other words, you can choose no more than a half (rounded down) of elements in each row, you have to find the maximum sum of these elements divisible by k.</p>
<p>Note that you can choose zero elements (and the sum of such set is 00).</p>
<p>Input</p>
<p>The first line of the input contains three integers n, mm and k (1≤n,m,k≤70) — the number of rows in the matrix, the number of columns in the matrix and the value of k. The next n lines contain mm elements each, where the j-th element of the i-th row is $a_{i,j} (1≤a_{i,j}≤70)$.</p>
<p>Output</p>
<p>Print one integer — the maximum sum divisible by k you can obtain.</p>
<p>Examples</p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 3 4</span><br><span class="line">5 2 2 2</span><br><span class="line">7 1 1 4</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题意：一个矩阵每一行至多选择$\left\lfloor\frac{m}{2}\right\rfloor$ 个数，且最后总和 sum 能被 k 整除。</p>
<p>设 $d[i][j][c][r]$ 表示取到第（i，j）个元素，第 i 行取了 c 个时，余数为 r 时的最大值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">70</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,a[MAX][MAX],d[MAX][MAX][MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);sf(k);</span><br><span class="line">	fi(i,<span class="number">0</span>,n) fi(j,<span class="number">0</span>,m) sf(a[i][j]);</span><br><span class="line">	mem(d,<span class="number">-0x3f</span>);</span><br><span class="line">	d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n) fi(j,<span class="number">0</span>,m) fi(c,<span class="number">0</span>,m/<span class="number">2</span>+<span class="number">1</span>) fi(r,<span class="number">0</span>,k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d[i][j][c][r]==-INF) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(j==m<span class="number">-1</span>)&#123;</span><br><span class="line">			d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][r] = max(d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][r],d[i][j][c][r]);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			d[i][j+<span class="number">1</span>][c][r] = max(d[i][j+<span class="number">1</span>][c][r],d[i][j][c][r]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(c&lt;(m/<span class="number">2</span>))&#123;</span><br><span class="line">			<span class="keyword">int</span> t = (r+a[i][j])%k;</span><br><span class="line">			<span class="keyword">if</span>(j==m<span class="number">-1</span>)&#123;</span><br><span class="line">				d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][t] = max(d[i+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][t] ,d[i][j][c][r]+a[i][j]);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				d[i][j+<span class="number">1</span>][c+<span class="number">1</span>][t] = max(d[i][j+<span class="number">1</span>][c+<span class="number">1</span>][t],d[i][j][c][r]+a[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pfn(d[n][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Largest Permutation</title>
    <url>/2020/01/15/LargestPermutation/</url>
    <content><![CDATA[<p><a href="https://practice.geeksforgeeks.org/problems/largest-permutation/0" target="_blank" rel="noopener">https://practice.geeksforgeeks.org/problems/largest-permutation/0</a><br>Given a permutation of first n natural numbers as an array and an integer k. Print the lexicographically largest permutation after at most k swaps.</p>
<p>Input:<br>The first line of input contains an integer T denoting the number of test cases. Each test case contains two integers n and k where n denotes the number of elements in the array a[]. Next line contains space separated n elements in the array a[].</p>
<p>Output:<br>Print space separated n integers which form the largest permutation after at most k swaps.</p>
<p>Constraints:<br>1&lt;=T&lt;=100<br>1&lt;=n&lt;=1000<br>1&lt;=a[i]&lt;=1000<br>1&lt;=k&lt;=100 0</p>
<p>Example:<br>Input:<br>2<br>5 3<br>4 5 2 1 3<br>3 1<br>2 1 3<br>Output:<br>5 4 3 2 1<br>3 1 2 </p>
<blockquote>
<p>每次交换选择最大的到最前面。一次交换后可能影响后面的交换。<br>将数组从大到小排序 记录为 b[ ]，与原数组对比，相同则不需交换。否则 对应的a[ i ] , b[ i ]交换。另需一个数组记录下标。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,a[MAX],k,b[MAX],c[MAX],tmp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);sf(k);</span><br><span class="line">		fi(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">			sf(a[i]);</span><br><span class="line">			b[i] = a[i];</span><br><span class="line">			c[a[i]] =i;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(b,b+n,cmp);</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] != b[i])&#123;</span><br><span class="line">				tmp=a[i];</span><br><span class="line">				a[c[b[i]]] = a[i];</span><br><span class="line">				a[i] = b[i];</span><br><span class="line">				swap(c[tmp],c[b[i]]);</span><br><span class="line">				k--;</span><br><span class="line">				<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			pf(a[i]);pfc(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pfc(<span class="string">"\n"</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Swaps for Bracket Balancing</title>
    <url>/2020/01/08/MinimumSwapsforBracketBalancing/</url>
    <content><![CDATA[<p><a href="https://practice.geeksforgeeks.org/problems/minimum-swaps-for-bracket-balancing/0" target="_blank" rel="noopener">https://practice.geeksforgeeks.org/problems/minimum-swaps-for-bracket-balancing/0</a></p>
<p>You are given a string of 2N characters consisting of N ‘[‘ brackets and N ‘]’ brackets. A string is considered balanced if it can be represented in the for S2[S1] where S1 and S2 are balanced strings. We can make an unbalanced string balanced by swapping adjacent characters. Calculate the minimum number of swaps necessary to make a string balanced.</p>
<p>Input:</p>
<p>The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. The first line of each test case contains an integer N denoting the length of the string.</p>
<p>The second line of each test case contains the string consisting of ‘[‘ and ‘]’.</p>
<p>Output:</p>
<p>Print the minimum number of swaps to make the string balanced for each test case in a new line.</p>
<blockquote>
<p>Example:<br>Input  : []][][<br>Output : 2<br>First swap: Position 3 and 4<br>[][]][<br>Second swap: Position 5 and 6<br>[][][]<br>Input  : [[][]]<br>Output : 0<br>String is already balanced.</p>
</blockquote>
<blockquote>
<p>方法一：每碰到一个 ‘ ] ‘ ，抵消左侧的一个 ‘ [ ‘ ,如果左侧没有 ，则抵消右侧的，此时需要要 swap ,sum +=  pos(‘ [ ‘) -pos (‘ ] ‘)。但是此时 应回到交换后的 ‘ [ ‘ 重新开始，因为可能已影响到交换前 ‘ ] ‘ 之后符号的决策。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="comment">// Function to calculate swaps required </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">swapCount</span><span class="params">(<span class="built_in">string</span> s)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Keep track of '[' </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) </span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) </span><br><span class="line">            pos.push_back(i); </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// To count number of encountered '[' </span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;     <span class="comment">// To track position of next '[' in pos </span></span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// To store result </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Increment count and move p to next position </span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            ++count; </span><br><span class="line">            ++p; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) </span><br><span class="line">            --count; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// We have encountered an unbalanced part of string </span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// Increment sum by number of swaps required </span></span><br><span class="line">            <span class="comment">// i.e. position of next '[' - current position </span></span><br><span class="line">            sum += pos[p] - i; </span><br><span class="line">            swap(s[i], s[pos[p]]); </span><br><span class="line">            ++p; </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// Reset count to 1 </span></span><br><span class="line">            count = <span class="number">1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;swapCount(s)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法二：记录 ‘ ] ‘ 不匹配的个数 imbalance，遇见 ‘ [ ‘ 时，优先配对最远的 ‘ ] ‘,且  imbalance –，依序往下。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">swapCount</span><span class="params">(<span class="built_in">string</span> s)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    <span class="comment">// stores total number of Left and Right  </span></span><br><span class="line">    <span class="comment">// brackets encountered </span></span><br><span class="line">    <span class="keyword">int</span> countLeft = <span class="number">0</span>, countRight = <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// swap stores the number of swaps required </span></span><br><span class="line">    <span class="comment">//imbalance maintains the number of imbalance pair </span></span><br><span class="line">    <span class="keyword">int</span> swap = <span class="number">0</span> , imbalance = <span class="number">0</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; s.length(); i++)  </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)  </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// increment count of Left bracket </span></span><br><span class="line">            countLeft++;  </span><br><span class="line">            <span class="keyword">if</span>(imbalance &gt; <span class="number">0</span>)  </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// swaps count is last swap count + total  </span></span><br><span class="line">                <span class="comment">// number imbalanced brackets </span></span><br><span class="line">                swap += imbalance;  </span><br><span class="line">                <span class="comment">// imbalance decremented by 1 as it solved </span></span><br><span class="line">                <span class="comment">// only one imbalance of Left and Right </span></span><br><span class="line">                imbalance--;      </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">']'</span> )  </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// increment count of Right bracket </span></span><br><span class="line">            countRight++;  </span><br><span class="line">            <span class="comment">// imbalance is reset to current difference  </span></span><br><span class="line">            <span class="comment">// between Left and Right brackets </span></span><br><span class="line">            imbalance = (countRight-countLeft);  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> swap; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;swapCount(s)&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum product subset of an array</title>
    <url>/2020/01/09/Minimumproductsubsetofanarray/</url>
    <content><![CDATA[<p><a href="https://www.geeksforgeeks.org/minimum-product-subset-array/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/minimum-product-subset-array/</a></p>
<p>Given an array a, we have to find minimum product possible with the subset of elements present in the array. The minimum product can be single element also.</p>
<p>Examples:</p>
<p>Input : a[] = { -1, -1, -2, 4, 3 }<br>Output : -24<br>Explanation : Minimum product will be ( -2 <em> -1 </em> -1 <em> 4 </em> 3 ) = -24</p>
<p>Input : a[] = { -1, 0 }<br>Output : -1<br>Explanation : -1(single element) is minimum product possible</p>
<p>Input : a[] = { 0, 0, 0 }<br>Output : 0</p>
<blockquote>
<ol>
<li>如果有偶数个负数且没有零，则结果为除最大负数之外的所有值的乘积。</li>
<li>如果有奇数个负数而没有零，那么结果就是所有乘积。</li>
<li>如果只有零和正，没有负，则结果为0。例外情况是，当没有负数且所有其他元素为正时，我们的结果应为第一个最小正数</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> max_neg=-INF,min_pos=INF,count_neg=<span class="number">0</span>,count_zero=<span class="number">0</span>,prod=<span class="number">1</span>,t,n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">0</span>) &#123;</span><br><span class="line">			count_zero++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(t&lt;<span class="number">0</span>) &#123;</span><br><span class="line">			count_neg++; </span><br><span class="line">			max_neg = max(max_neg, t); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;<span class="number">0</span>)	min_pos = min(min_pos, t);  </span><br><span class="line">		prod*=t;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (count_zero == n ||(count_neg == <span class="number">0</span> &amp;&amp; count_zero &gt; <span class="number">0</span>)) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (count_neg == <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,min_pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(count_neg &amp; <span class="number">1</span>) &amp;&amp; count_neg != <span class="number">0</span>) </span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d"</span>,prod / max_neg);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,prod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>PIPI的炼金术 [ 二分 ]</title>
    <url>/2020/04/04/PIPI%E7%9A%84%E7%82%BC%E9%87%91%E6%9C%AF/</url>
    <content><![CDATA[<p><a href="http://pipioj.online/problem.php?cid=1021&amp;pid=5" target="_blank" rel="noopener">PIPI的炼金术</a></p>
<p><strong>题目描述</strong></p>
<p>PIPI身为一名化学砖家，通过他不懈的努力，终于研究出了炼金术：2Al+2Cu＝2Au+Cl2↑<br>已知PIPI共有n件材料，每件材料的属性由只含有小写字母的字符串表示。PIPI可以将任意数量(但数量必须大于0)的材料放在一起炼制，只要这些材料每个字符的出现次数为偶数，即可炼金成功。比如PIPI共有2件材料，材料1的属性为：aab，材料2的属性为b。如果材料1和材料2放在一起炼制，a字符一共出现两次，b字符一共出现两次，每个字符出现次数均为偶数，因此可以炼金成功。<br>PIPI想知道，他有多少种炼金成功的方案？</p>
<p><strong>输入</strong></p>
<p>第一行输入一个正整数n，n&lt;=35。<br>接下来n行，每行一个字符串，表示材料的属性，0&lt;字符串长度&lt;=10^5。</p>
<p><strong>输出</strong></p>
<p>输出PIPI炼金成功的方案数。</p>
<p><strong>样例输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aab</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<p><strong>样例输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于每一个材料，用 26 位表示 26 个字母的奇偶性（只有奇偶影响结果），然后枚举所有的子集，判断是否可行，累加答案就可。</p>
<p>但是 n 很大，然后二分，但是子集可能覆盖两部分，对于第一部分，记录所有的状态，遍历第二部分的时候如果状态有与第一部分的状态相同，则答案累加（因为异或运算，相同值异或为0 ）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans,c[<span class="number">36</span>][<span class="number">50</span>],d[<span class="number">36</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">36</span>][MAX];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span>(y &amp; (<span class="number">1</span>&lt;&lt;i)) </span><br><span class="line">			res ^= d[i];</span><br><span class="line">	num[res]++;</span><br><span class="line">	ans += res ? <span class="number">0</span> :<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n-n/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span>(y &amp; (<span class="number">1</span>&lt;&lt;i)) </span><br><span class="line">			res ^= d[i + n/<span class="number">2</span>];</span><br><span class="line">	ans += num[res];</span><br><span class="line">	ans += res ? <span class="number">0</span> :<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]);</span><br><span class="line">		<span class="keyword">int</span> l=<span class="built_in">strlen</span>(a[i]);</span><br><span class="line">		fi(j,<span class="number">0</span>,l) c[i][a[i][j]-<span class="string">'a'</span>]++;</span><br><span class="line">		fi(j,<span class="number">0</span>,<span class="number">26</span>)</span><br><span class="line">			<span class="keyword">if</span>(c[i][j] &amp; <span class="number">1</span>) </span><br><span class="line">				d[i] |= (<span class="number">1</span>&lt;&lt;(j));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="built_in">pow</span>(<span class="number">2</span>,n/<span class="number">2</span>)<span class="number">-1</span>,y=x;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(y) calc(y);</span><br><span class="line">		y = (y<span class="number">-1</span>) &amp; x;</span><br><span class="line">	&#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">		</span><br><span class="line">	x=<span class="built_in">pow</span>(<span class="number">2</span>,n-n/<span class="number">2</span>)<span class="number">-1</span>,y=x;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(y) calc2(y);</span><br><span class="line">		y = (y<span class="number">-1</span>) &amp; x;</span><br><span class="line">	&#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">	</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>PIPI的生化危机 [ bfs + 二分 ]</title>
    <url>/2020/03/28/PIPI%E7%9A%84%E7%94%9F%E5%8C%96%E5%8D%B1%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="http://pipioj.online/problem.php?cid=1020&amp;pid=2" target="_blank" rel="noopener">PIPI的生化危机</a></p>
<p><strong>题目描述：</strong></p>
<p>浣熊市爆发了生化危机，PIPI作为上班迟到的一名新警察，被困在警察局了，他希望能从警察局前往安全屋避难。<br>已知浣熊市是个n<em>m的区域，每块格子的类型有以下几种：
</em>：表示第0秒时该地点有病毒，且每过1秒病毒就会往上/下/左/右四个方向扩散一格，被病毒新侵占的格子又会按照此规则继续扩散。<br>S：表示警察局，也就是PIPI一开始所在的地方。<br>T：表示安全屋，任何病毒都不能扩散到安全屋，这也是PIPI要到达的地方。<br>#：表示该地点已被摧毁，病毒无法扩散到该地点，同时PIPI也无法移动到该地点。<br>.： 表示空地。<br>以上类型中，如无特别说明的，均能被病毒扩散到。<br>PIPI每秒可以往上/下/左/右四个方向移动一格，由于PIPI希望能在警察局搜集到足够多的物资，所以他想保证自己在逃亡之旅上不会被病毒感染的情况下，尽可能的在警察局待得久。<br>请问PIPI在警察局最多能待多少秒？</p>
<blockquote>
<p>emmm  首先根据病毒，计算所有点被感染的时刻，将所有点压入队列跑 bfs  (<strong><del>不要每个点都跑一次！！</del></strong>) </p>
<p>T到哭… 然后二分的时候注意边界（可能you时候不太需要QAQ）！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,ans,ex,ey,fx,fy,te[MAX][MAX],aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX]; </span><br><span class="line"><span class="keyword">int</span> vis[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,d;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _d)&#123;</span><br><span class="line">		x=_x;y=_y;d=_d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;virus;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!virus.empty())&#123;</span><br><span class="line">		node t=virus.front();</span><br><span class="line">		virus.pop();</span><br><span class="line">		te[t.x][t.y]=min(te[t.x][t.y],t.d);</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx=t.x + aw[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> ty=t.y + aw[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; !vis[tx][ty] &amp;&amp; a[tx][ty]!=<span class="string">'#'</span> &amp;&amp; a[tx][ty]!=<span class="string">'T'</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(te[t.x][t.y] + <span class="number">1</span> &lt; te[tx][ty]) &#123;</span><br><span class="line">					virus.push(node(tx,ty,te[t.x][t.y]+<span class="number">1</span>));</span><br><span class="line">					vis[tx][ty] =<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//start on d time</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(node(fx,fy,d));</span><br><span class="line">	vis[fx][fy]=d;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(t.x==ex&amp;&amp;t.y==ey) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx=t.x + aw[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> ty=t.y + aw[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; vis[tx][ty]!=d &amp;&amp; a[tx][ty]!=<span class="string">'#'</span>&amp;&amp;t.d+<span class="number">1</span>&lt;te[tx][ty])&#123;</span><br><span class="line">				vis[tx][ty]=d;</span><br><span class="line">				q.push(node(tx,ty,t.d+<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	mem(te,<span class="number">0x3f</span>);<span class="comment">//time</span></span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j]==<span class="string">'*'</span>)&#123;</span><br><span class="line">				virus.push(node(i,j,<span class="number">1</span>));</span><br><span class="line">				vis[i][j]=<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'T'</span>)&#123;</span><br><span class="line">				ex=i;ey=j;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="string">'S'</span>)&#123;</span><br><span class="line">				fx=i;fy=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	mem(vis,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=te[fx][fy]<span class="number">-1</span>;<span class="comment">//!!!! te[fx][fy]时刻走已经晚了！ </span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(isok(m))&#123;</span><br><span class="line">			ans = m;</span><br><span class="line">			l = m+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Policemen catch thieves</title>
    <url>/2020/01/07/Policemencatchthieves/</url>
    <content><![CDATA[<p><a href="https://www.geeksforgeeks.org/policemen-catch-thieves/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/policemen-catch-thieves/</a><br>Given an array of size n that has the following specifications:</p>
<ol>
<li>Each element in the array contains either a policeman or a thief.</li>
<li>Each policeman can catch only one thief.</li>
<li>A policeman cannot catch a thief who is more than K units away from the policeman.</li>
</ol>
<p>We need to find the maximum number of thieves that can be caught.</p>
<blockquote>
<p>Examples:<br>Input : arr[] = {‘P’, ‘T’, ‘T’, ‘P’, ‘T’},<br>            k = 1.<br>Output : 2.<br>Here maximum 2 thieves can be caught, first<br>policeman catches first thief and second police-<br>man can catch either second or third thief.<br>Input : arr[] = {‘T’, ‘T’, ‘P’, ‘P’, ‘T’, ‘P’},<br>            k = 2.<br>Output : 3.<br>Input : arr[] = {‘P’, ‘T’, ‘P’, ‘T’, ‘T’, ‘P’},<br>            k = 3.<br>Output : 3.</p>
</blockquote>
<blockquote>
<p><strong>focusing on just the allotment works</strong><br>1) Get the lowest index of policeman p and thief t. Make an allotment<br>  if |p-t| &lt;= k and increment to the next p and t found.<br>2) Otherwise increment min(p, t) to the next p or t found.<br>3) Repeat above two steps until next p and t are found.<br>4) Return the number of allotments made </p>
</blockquote>
<blockquote>
<p>分析：考虑 P1 P2 , P1 在 P2 之前，如果 P1 与 一个 T  配对。<br>1）如果 T 在 P2 左侧区域 ，两种结果：<br>P2 左侧无 T 可选，此 T 更适合 P1 （即使选择 P2 对结果不造成影响）；P2 有 T 可选 ，P1 对 P2 不造成影响；<br>2）如果 T 在 P2 右侧，造成 P2 无 T 可选， 则选 P1 or P2 等同；若 P2 可选 则不影响； </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns maximum number of thieves that can </span></span><br><span class="line"><span class="comment">// be caught. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">policeThief</span><span class="params">(<span class="keyword">char</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; thi; </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pol; </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// store indices in the vector </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">'P'</span>) </span><br><span class="line">            pol.push_back(i); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == <span class="string">'T'</span>) </span><br><span class="line">            thi.push_back(i); </span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// track lowest current indices of </span></span><br><span class="line">    <span class="comment">// thief: thi[l], police: pol[r] </span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (l &lt; thi.size() &amp;&amp; r &lt; pol.size()) &#123; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// can be caught </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(thi[l] - pol[r]) &lt;= k) &#123; </span><br><span class="line">            res++; </span><br><span class="line">            l++; </span><br><span class="line">            r++; </span><br><span class="line">        &#125; </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// increment the minimum index </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (thi[l] &lt; pol[r]) </span><br><span class="line">            l++; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r++; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Raju and coins</title>
    <url>/2020/01/14/Rajuandcoins/</url>
    <content><![CDATA[<p><a href="https://practice.geeksforgeeks.org/problems/raju-and-coins/0" target="_blank" rel="noopener">https://practice.geeksforgeeks.org/problems/raju-and-coins/0</a></p>
<p>Raju always like to collect coins. Raju has already managed to collect n different types of coins a1,a2….an . One day he went into the sale and find out that the sale consists of 109 types of coins where i-th type of coin costs i dollars. He decided to buy some more different types of coins given that he does not have that type of coin already. But he has only k dollars to spend.<br>So help him to choose the type of coins.</p>
<p>Input:</p>
<p>The first line will contain test cases T. Then T Test cases follow. Each of the test cases will contain two integers n, k   the number of types of coins that Raju already has and the money he has respectively. The next line contains n distinct integers a1,a2…an the types of coins that Raju already has.</p>
<p>Output:</p>
<p>Print a single integer denoting the number of different types of coins that Raju can buy so that the number of different coins in his collection is maximum. Cost should not exceed k.</p>
<p>Constraints:</p>
<p>1&lt;=T&lt;=27<br>1&lt;=n&lt;=100000<br>1&lt;=k&lt;=109<br>1&lt;=ai&lt;=109</p>
<p>Example:</p>
<p>Input<br>2<br>4 14<br>4 6 12 8<br>3 7<br>1 3 4</p>
<p>Output<br>4<br>2</p>
<blockquote>
<p>用一个数组记录下一个，可选的硬币的位置</p>
</blockquote>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;(n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfn(n) printf(<span class="meta-string">"%d\n"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(s,t) for(i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fj(s,t) for(j=s;j&lt;t;j++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,k,g,ans,nl[MAX],last,cnt,a[MAX],i,j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		mem(nl,<span class="number">0</span>);</span><br><span class="line">		ans=<span class="number">0</span>;cnt=<span class="number">0</span>;</span><br><span class="line">		sf(n);sf(k);</span><br><span class="line">		fi(<span class="number">0</span>,n) &#123;</span><br><span class="line">			sf(a[i]);	</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		last =<span class="number">0</span>; </span><br><span class="line">		fi(<span class="number">0</span>,n) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &gt; last +<span class="number">1</span>)</span><br><span class="line">				fj(last+<span class="number">1</span>,a[i])</span><br><span class="line">					nl[cnt++] =j;</span><br><span class="line">			last=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		nl[cnt++] =a[n<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		fi(<span class="number">0</span>,cnt)&#123;</span><br><span class="line">			<span class="keyword">if</span>(k &gt;= nl[i]) &#123;</span><br><span class="line">				k-=nl[i];ans ++;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i==cnt) </span><br><span class="line">			<span class="keyword">while</span>(k)&#123;</span><br><span class="line">				<span class="keyword">if</span>(k&gt;=i) &#123;</span><br><span class="line">					k-=i;</span><br><span class="line">					ans ++;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		pfn(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot:TestRestTemplate、RestTemplate</title>
    <url>/2018/03/28/Spring-boot-TestRestTemplate/</url>
    <content><![CDATA[<h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate用于去调用远程的 REST services 时， Spring Boot 不会自动提供RestTemplate bean,但是会 auto-configure a RestTemplateBuilder, which can be used to create RestTemplate instances when needed.</p>
<h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	RestTemplateService(RestTemplateBuilder restTemplateBuilder) &#123;</span><br><span class="line">		<span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">		<span class="comment">//添加拦截器</span></span><br><span class="line">		<span class="keyword">this</span>.restTemplate.getInterceptors().add(<span class="keyword">new</span> TokenInterceptor());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//get </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">someRestCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://127.0.0.1:9999/"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">someJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://127.0.0.1:9999/bean"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//post</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		MultiValueMap&lt;String, String&gt; map= <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">		map.add(<span class="string">"variable"</span>,<span class="string">"a post variable"</span>);</span><br><span class="line">		HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">		HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = <span class="keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(map, headers);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.postForObject(<span class="string">"http://127.0.0.1:9999/post"</span>,entity,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="string">"howdy!"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/res"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Response <span class="title">res</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> Response();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/v/&#123;variable&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPathVariable</span><span class="params">(@PathVariable String variable )</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> variable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@PostMapping</span>(<span class="string">"/post"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">(Date date,String variable)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> variable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 上传文件</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> GeneralException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(</span><br><span class="line">			value=<span class="string">"/upload"</span>,</span><br><span class="line">			method=RequestMethod.POST,</span><br><span class="line">			consumes= &#123;</span><br><span class="line">					MediaType.APPLICATION_JSON_VALUE,</span><br><span class="line">					MediaType.MULTIPART_FORM_DATA_VALUE</span><br><span class="line">			&#125;)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> GeneralException </span>&#123;</span><br><span class="line">		Storage storage=StorageFactory.getStorage(config.getStorageClass());</span><br><span class="line">		<span class="keyword">if</span> (storage==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> GeneralException(<span class="string">"F105"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;MultipartFile&gt; files= ((MultipartHttpServletRequest) request).getFiles(<span class="string">"file"</span>);</span><br><span class="line">		checkFileTypes(files);<span class="comment">//检查文件类型</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;files.size();++i) &#123;</span><br><span class="line">			MultipartFile file=files.get(i);</span><br><span class="line">			<span class="keyword">if</span>(!file.isEmpty()) &#123;</span><br><span class="line">				storage.store(file);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h3><p>测试用的RestTemplate，如果使用了@SpringBootTest，会自动配置一个TestRestTemplate，可直接使用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">webEnvironment</span> </span>= WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoControllerTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		assertThat(body).isEqualTo(<span class="string">"howdy!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPathVariableTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"/v/this is a variable"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		assertThat(body).isEqualTo(<span class="string">"this is a variable"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		MultiValueMap&lt;String, String&gt; map= <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">		map.add(<span class="string">"date"</span>,<span class="string">"2018-09-09"</span>);</span><br><span class="line">		map.add(<span class="string">"variable"</span>,<span class="string">"a post variable"</span>);</span><br><span class="line">		</span><br><span class="line">		HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">		HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = <span class="keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(map, headers);</span><br><span class="line">		String body = <span class="keyword">this</span>.restTemplate.postForObject(<span class="string">"/post"</span>,entity,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		assertThat(body).isEqualTo(<span class="string">"a post variable"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFileUpload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String path=<span class="string">"C:/Users/dy040/Pictures/mm.jpg"</span>;</span><br><span class="line">		File file=<span class="keyword">new</span> File(path);</span><br><span class="line">		FileSystemResource resource =<span class="keyword">new</span> FileSystemResource(file);</span><br><span class="line">		MultiValueMap&lt;String, Object&gt; map= <span class="keyword">new</span> LinkedMultiValueMap&lt;String, Object&gt;();</span><br><span class="line">		map.add(<span class="string">"file"</span>,resource);	</span><br><span class="line"><span class="comment">//		HttpHeaders headers = new HttpHeaders();</span></span><br><span class="line"><span class="comment">//		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span></span><br><span class="line"><span class="comment">//		HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt;(map, headers);	</span></span><br><span class="line">		String body = <span class="keyword">this</span>.restTemplate.postForObject(<span class="string">"/upload"</span>,map,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		assertThat(body).isEqualTo(<span class="string">"success"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@TestConfiguration</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(<span class="number">1000</span>).setReadTimeout(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>T128953出题 [ 背包 贪心 ]</title>
    <url>/2020/04/19/T128953%E5%87%BA%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P6433" target="_blank" rel="noopener">p6433「EZEC-1」出题</a></p>
<p><strong>题目背景</strong></p>
<p>你是一个毒瘤出题人。</p>
<p><strong>题目描述</strong></p>
<p>已知你有 <em>n</em> 道毒瘤题，已经出好了题面，但数据还没出好。你还剩下 <em>m</em> 的时间，每道题的毒瘤程度为 <em>a**i</em>，出数据的时间是 x*<em>i</em>，你有 k* 个老师，每个老师珂以把一道题的毒瘤程度翻倍（每道题目最多被翻倍一次）。你的父母由于坚决反对你出公开赛，抢走了你的一道题，现在老师和父母的行动你都可以控制，但每位老师和父母的行为必须执行，请问你要怎么做，才能使出的题毒瘤程度之和最大？</p>
<p><strong>输入格式</strong></p>
<p>第一行三个整数：n,m,k。</p>
<p>接下来 n<em> 行，每行 2 个整数，分别是 </em>a<strong>i<em>,</em>x</strong>i*。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，最大的毒瘤程度之和。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 10 1</span><br><span class="line">6 9</span><br><span class="line">7 2</span><br><span class="line">1 8</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 20 2</span><br><span class="line">5 3 </span><br><span class="line">9 7</span><br><span class="line">2 6</span><br><span class="line">7 8</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">38</span><br></pre></td></tr></table></figure>
<p><strong>输入 #3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6 2</span><br><span class="line">5 4</span><br><span class="line">3 3</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.luogu.com.cn/blog/pigstd/chu-ti-ren" target="_blank" rel="noopener">题解</a></p>
<p>用 $dp[i][j]$ 表示用 <em>i</em> 时间，使用 j 次翻倍后可以得到的最大毒瘤值</p>
<p>如果所有时间和 小于等于 m，就是一个贪心…<del>比赛的时候想大于是贪心，菜哭</del></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,a[MAX],x[MAX],ans=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>][MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	sf(n);sf(m);sf(k);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(a[i]);sf(x[i]);</span><br><span class="line">		sum += x[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum&lt;=m)&#123;</span><br><span class="line">		sort(a,a+n,cmp);</span><br><span class="line">		fi(i,<span class="number">0</span>,k) ans += a[i]*<span class="number">2</span>;</span><br><span class="line">        fi(i,k,n<span class="number">-1</span>) ans += a[i];</span><br><span class="line">		pf(ans); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fd(j,m+<span class="number">1</span>,x[i])&#123;</span><br><span class="line">			f[j][<span class="number">0</span>]=max(f[j][<span class="number">0</span>],f[j-x[i]][<span class="number">0</span>]+a[i]);</span><br><span class="line">			ans = max(ans,f[j][<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">1</span>;h&lt;=min(k,i+<span class="number">1</span>);h++)&#123;</span><br><span class="line">				f[j][h] =max(f[j][h],max(f[j-x[i]][h] + a[i],f[j-x[i]][h<span class="number">-1</span>] + <span class="number">2</span>*a[i])); </span><br><span class="line">				ans = max(ans,f[j][h]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA 10859 [ 树形dp ]</title>
    <url>/2020/03/31/UVA10859/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/UVA10859" target="_blank" rel="noopener">UVA10859 Placing Lampposts</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个<em>n</em>个点m条边的无向无环图，在尽量少的节点上放灯，使得所有边都与灯相邻（被灯照亮）。</p>
<p>在灯的总数最小的前提下，被两盏灯同时照亮的边数应该尽可能大。</p>
<p><strong>输入格式</strong></p>
<p>第一行输入T*,为数据组数。</p>
<p>每组数据第一行输入n<em>,</em>m，分别为该组数据中图的点数和边数。</p>
<p>以下m<em>行，输入各边的两端点</em> u<em>,</em>v。</p>
<p><strong>输入格式</strong></p>
<p>输出共<em>T</em>行。</p>
<p>对每组数据，一行输出三个数，最小灯数、被两盏灯同时照亮的边数、只被一盏灯照亮的边数。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 3</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">5 4</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">0 4</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 2</span><br><span class="line">1 0 4</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>一般来说，如果有两个需要优化的量 $v_1$ 和 $v_2$ ,首先要求满足 $v_1$最小，在 $v_1$相同的情况下 $v_2$最小，则可以把二者组合成一个量  $M \times v_1+ v_2$,其中 $M$ 是一个比 “ $v_2$的最大理论值和 $v_2$的最小理论值之差”  还要大的数。这样只要两个解的 $v_1$不同， 则不管 $v_2$相差多少，都是 $v_1$起决定性作用。（抄自白书）</strong> </p>
<p>本题 $d[i][1/0]$ 表示以$i$ 为根节点的子树，放与不放灯时的最小 $x$ ( $x= M \times v_1+ v_2$)值 ,</p>
<p>如果父节点放灯，才允许子节点不放灯（要放灯最少所以选择不放） ，$d[i][1] =  \sum d[k][0]$   $k$ 是 $i$ 的子节点，如果 $i$  不是根 结果 +1 。</p>
<p>如果父节点不放灯，子节点必须放灯 ，$d[i][0] =  \sum d[k][1] + M$  , 此时 如果 $i$  不是根 结果 +1 。</p>
<p>因为 $i$  和其父节点只有一盏灯照亮。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,m,u,v,vis[MAX][<span class="number">2</span>],ans,d[MAX][<span class="number">2</span>];</span><br><span class="line">vi g[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[i][j]) <span class="keyword">return</span> d[i][j];</span><br><span class="line">	vis[i][j]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;ans = d[i][j];<span class="comment">// ans,d[i][j] "绑定"</span></span><br><span class="line">	ans =<span class="number">2000</span>;</span><br><span class="line">	fi(k,<span class="number">0</span>,g[i].size())	</span><br><span class="line">		<span class="keyword">if</span>(g[i][k]!=fa)</span><br><span class="line">			ans += dp(g[i][k],<span class="number">1</span>,i);</span><br><span class="line">	<span class="keyword">if</span>(!j &amp;&amp; fa&gt;=<span class="number">0</span>) ans ++;</span><br><span class="line">	<span class="keyword">if</span>(j||fa&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		fi(k,<span class="number">0</span>,g[i].size())</span><br><span class="line">			<span class="keyword">if</span>(g[i][k]!=fa)</span><br><span class="line">				sum+=dp(g[i][k],<span class="number">0</span>,i);</span><br><span class="line">		<span class="keyword">if</span>(fa&gt;=<span class="number">0</span>) sum++;</span><br><span class="line">		ans = min(ans,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);sf(m);</span><br><span class="line">		fi(i,<span class="number">0</span>,n) g[i].clear();</span><br><span class="line">		fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">			sf(u);sf(v);</span><br><span class="line">			g[u].pb(v);g[v].pb(u);</span><br><span class="line">		&#125;</span><br><span class="line">		mem(vis,<span class="number">0</span>);</span><br><span class="line">		ans =<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)</span><br><span class="line">			<span class="keyword">if</span>(!vis[i][<span class="number">0</span>])</span><br><span class="line">				ans += dp(i,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,ans/<span class="number">2000</span>,m-ans%<span class="number">2000</span>,ans%<span class="number">2000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CF 1328E Tree Queries [ LCA DFS ]</title>
    <url>/2020/03/30/cf1328E/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/problemset/problem/1328/E" target="_blank" rel="noopener">Tree Queries</a></p>
<p>题意： 给出树上的一些点，判断这些点中某些是否可以连成一条到根的路径，并且剩余的点到这条路径的距离为 1 . 原文：</p>
<p>You are given m queries. The i-th query consists of the set of ki distinct vertices vi[1],vi[2],…,vi[ki]. Your task is to say if there is a path from the root to some vertex u such that each of the given k vertices is either belongs to this path or has the distance 1 to some vertex of this path.</p>
<p><strong>Example</strong></p>
<p>input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">7 8</span><br><span class="line">7 9</span><br><span class="line">9 10</span><br><span class="line">4 3 8 9 10</span><br><span class="line">3 2 4 6</span><br><span class="line">3 2 1 5</span><br><span class="line">3 4 8 2</span><br><span class="line">2 6 10</span><br><span class="line">3 5 4 7</span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<p><img src="/.io//1.png" alt="1"></p>
<blockquote>
<p><strong>思路一</strong>：选出深度最深的点 v ，显然所有的点要么属于 v 到根节点的路径，要么到这条路径的距离为 1. 可以先找出这条路径，在这条路径上的点去除; 对于剩下的点 ki ,求 ki ，v 的最近公共祖先 u,  如果 ki  到 u 的距离 = 1，那么这点是符合的，依次判断。</p>
<p><strong>思路二</strong>：（膜大佬代码orz）同思路一用 lca ,但是不求路径。对于所有的 ki , 根据深度排序。如果要符合题目要求，相邻的 ki, kj 的 lca 只能为  ki ,kj, ki 的父节点，kj 的父节点四种情况之一。否则就不符合。</p>
<p><strong>思路三</strong>： (官方题解)  因为不在路径（最深的点到根节点的路径）上的点到路径上的距离只能等于 1， 所以如果这样的点直接用它的父节点替代，然后再判断所有点是否都在路径上即可。</p>
<p>如何判断所有的点是否都在一条路径上？</p>
<ul>
<li><p>路径上相邻的点 u,v , lca(u ,v) = u or v ,(有点像思路一)</p>
</li>
<li><p>跑一边 dfs 记录所有点第一次访问的时间 tin, 和最后一次访问的时间 tout ,</p>
<p>如果  $tin_v≤tin_u  ,tout_u≤tout_v  $     u 是 v  的祖先节点。如果所有的点都是最深的节点的父节点，那么所有点都在一条路径上 。</p>
</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,u,v,flag;</span><br><span class="line"><span class="keyword">int</span> anc[MAX][<span class="number">22</span>],l[MAX],k,tmp;</span><br><span class="line">vi g[MAX],ki;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	fi(i,<span class="number">0</span>,g[u].size())&#123;</span><br><span class="line">		<span class="keyword">int</span> v=g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">		l[v]=l[u]+<span class="number">1</span>;</span><br><span class="line">		anc[v][<span class="number">0</span>]=u;</span><br><span class="line">		fi(j,<span class="number">1</span>,<span class="number">20</span>) anc[v][j]=<span class="number">-1</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l[p]&lt;l[q]) swap(p,q);  <span class="comment">//p 深 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) &#123; <span class="comment">//p q 同深度</span></span><br><span class="line">		<span class="keyword">if</span>(anc[p][i]!=<span class="number">-1</span> &amp;&amp; l[anc[p][i]]&gt;=l[q])</span><br><span class="line">			p=anc[p][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==q) <span class="keyword">return</span> p;<span class="comment">//  返回两者离祖先的最近距离 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(anc[p][i]!=<span class="number">-1</span>&amp;&amp;anc[p][i]!=anc[q][i])&#123;</span><br><span class="line">			p=anc[p][i];q=anc[q][i];   <span class="comment">//向上</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> anc[p][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> l[a]&lt;l[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in","r",stdin);</span></span><br><span class="line">	mem(anc,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		sf(u);sf(v);</span><br><span class="line">		g[u].pb(v);</span><br><span class="line">		g[v].pb(u);</span><br><span class="line">	&#125;</span><br><span class="line">	l[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	fi(j,<span class="number">1</span>,<span class="number">20</span>)</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)	<span class="keyword">if</span>(anc[i][j<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">			anc[i][j]=anc[anc[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]; </span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(k);</span><br><span class="line">		ki.clear();</span><br><span class="line">		fi(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">			sf(tmp);</span><br><span class="line">			ki.pb(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(all(ki),cmp);</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">			<span class="keyword">int</span> u= ki[i<span class="number">-1</span>],v=ki[i];</span><br><span class="line">			<span class="keyword">int</span> w=lca(u,v);</span><br><span class="line">			<span class="keyword">if</span>(w!=u&amp;&amp;w!=v&amp;&amp;w!=anc[u][<span class="number">0</span>]&amp;&amp;w!=anc[v][<span class="number">0</span>])&#123;</span><br><span class="line">				flag=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) pfc(<span class="string">"NO\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> pfc(<span class="string">"YES\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题解代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, d;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tin, tout;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> par = <span class="number">-1</span>, <span class="keyword">int</span> dep = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">	p[v] = par;</span><br><span class="line">	d[v] = dep;</span><br><span class="line">	tin[v] = T++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> to : g[v]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (to == par) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(to, v, dep + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	tout[v] = T++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnc</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tin[v] &lt;= tin[u] &amp;&amp; tout[u] &lt;= tout[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line">	freopen(<span class="string">"input.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//	freopen("output.txt", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	T = <span class="number">0</span>;</span><br><span class="line">	p = d = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">	tin = tout = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">	g = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		--x, --y;</span><br><span class="line">		g[x].push_back(y);</span><br><span class="line">		g[y].push_back(x);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(k)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : v) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; it;</span><br><span class="line">			--it;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">int</span> u = v[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it : v) <span class="keyword">if</span> (d[u] &lt; d[it]) u = it;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : v) &#123;</span><br><span class="line">			<span class="keyword">if</span> (it == u) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (p[it] != <span class="number">-1</span>) it = p[it];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it : v) ok &amp;= isAnc(it, u);</span><br><span class="line">		<span class="keyword">if</span> (ok) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>CF</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code>$ hexo &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;
`&lt;/pre&gt;

More info: [Writing](https://hexo.io/docs/writing.html)

### Run server

&lt;pre&gt;`$ hexo &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt;
`&lt;/pre&gt;

More info: [Server](https://hexo.io/docs/server.html)

### Generate static files

&lt;pre&gt;`&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;hexo generate
`&lt;/pre&gt;

More info: [Generating](https://hexo.io/docs/generating.html)

### Deploy to remote sites

&lt;pre&gt;`&lt;span class=&quot;hljs-variable&quot;&gt;$ &lt;/span&gt;hexo deploy
</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>huffmancodes</title>
    <url>/2020/01/07/huffmancodes/</url>
    <content><![CDATA[<p><a href="https://www.geeksforgeeks.org/huffman-decoding/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/huffman-decoding/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to map each character its huffman value </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; codes; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// to store the frequency of character of the input data </span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; freq; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// A Huffman tree node </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinHeapNode</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">char</span> data;             <span class="comment">// One of the input characters </span></span><br><span class="line">    <span class="keyword">int</span> freq;             <span class="comment">// Frequency of the character </span></span><br><span class="line">    MinHeapNode *left, *right; <span class="comment">// Left and right child </span></span><br><span class="line">  </span><br><span class="line">    MinHeapNode(<span class="keyword">char</span> data, <span class="keyword">int</span> freq) </span><br><span class="line">    &#123; </span><br><span class="line">        left = right = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">this</span>-&gt;data = data; </span><br><span class="line">        <span class="keyword">this</span>-&gt;freq = freq; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function for the priority queue </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compare</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(MinHeapNode* l, MinHeapNode* r)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (l-&gt;freq &gt; r-&gt;freq); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function to print characters along with </span></span><br><span class="line"><span class="comment">// there huffman value </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCodes</span><span class="params">(struct MinHeapNode* root, <span class="built_in">string</span> str)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data != <span class="string">'$'</span>) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; root-&gt;data &lt;&lt; <span class="string">": "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>; </span><br><span class="line">    printCodes(root-&gt;left, str + <span class="string">"0"</span>); </span><br><span class="line">    printCodes(root-&gt;right, str + <span class="string">"1"</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function to store characters along with </span></span><br><span class="line"><span class="comment">// there huffman value in a hash table, here we </span></span><br><span class="line"><span class="comment">// have C++ STL map </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">storeCodes</span><span class="params">(struct MinHeapNode* root, <span class="built_in">string</span> str)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data != <span class="string">'$'</span>) </span><br><span class="line">        codes[root-&gt;data]=str; </span><br><span class="line">    storeCodes(root-&gt;left, str + <span class="string">"0"</span>); </span><br><span class="line">    storeCodes(root-&gt;right, str + <span class="string">"1"</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// STL priority queue to store heap tree, with respect </span></span><br><span class="line"><span class="comment">// to their heap root node value </span></span><br><span class="line">priority_queue&lt;MinHeapNode*, <span class="built_in">vector</span>&lt;MinHeapNode*&gt;, compare&gt; minHeap; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// function to build the Huffman tree and store it </span></span><br><span class="line"><span class="comment">// in minHeap </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCodes</span><span class="params">(<span class="keyword">int</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MinHeapNode</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">top</span>;</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator v=freq.begin(); v!=freq.end(); v++) </span><br><span class="line">        minHeap.push(<span class="keyword">new</span> MinHeapNode(v-&gt;first, v-&gt;second)); </span><br><span class="line">    <span class="keyword">while</span> (minHeap.size() != <span class="number">1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        left = minHeap.top(); </span><br><span class="line">        minHeap.pop(); </span><br><span class="line">        right = minHeap.top(); </span><br><span class="line">        minHeap.pop(); </span><br><span class="line">        top = <span class="keyword">new</span> MinHeapNode(<span class="string">'$'</span>, left-&gt;freq + right-&gt;freq); </span><br><span class="line">        top-&gt;left = left; </span><br><span class="line">        top-&gt;right = right; </span><br><span class="line">        minHeap.push(top); </span><br><span class="line">    &#125; </span><br><span class="line">    storeCodes(minHeap.top(), <span class="string">""</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// utility function to store map each character with its </span></span><br><span class="line"><span class="comment">// frequency in input string </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcFreq</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.size(); i++) </span><br><span class="line">        freq[str[i]]++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>STL</tag>
        <tag>代码段</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 3278 Catch That Cow</title>
    <url>/2019/01/11/poj3278/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=3278" target="_blank" rel="noopener">http://poj.org/problem?id=3278</a><br>Description</p>
<p>Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.</p>
<ul>
<li>Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute</li>
<li>Teleporting: FJ can move from any point X to the point 2 × X in a single minute.</li>
</ul>
<p>If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?</p>
<p>Input</p>
<p>Line 1: Two space-separated integers: N and K<br>Output</p>
<p>Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.</p>
<blockquote>
<p>设d[ ][0/1/2] 分别为正向，跳跃，逆向行走时的最小值<br>N 是 可以小于 K 的，此时直接输出 abs( n-i ) 即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF INT_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 200000+10 </span></span><br><span class="line"><span class="keyword">int</span> d[MAX][<span class="number">3</span>],n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"file/in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="comment">//freopen("file/out1","w",stdout);</span></span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k))&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;k) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">abs</span>(n-k));</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=<span class="number">2</span>*k;i++)&#123;</span><br><span class="line">			d[i][<span class="number">0</span>]=MAX;</span><br><span class="line">			d[i][<span class="number">1</span>]=MAX;</span><br><span class="line">			d[i][<span class="number">2</span>]=MAX;</span><br><span class="line">		&#125;</span><br><span class="line">		d[n][<span class="number">0</span>]=<span class="number">0</span>;d[n][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		d[n][<span class="number">2</span>]=<span class="number">0</span>;d[<span class="number">2</span>*n][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;n/<span class="number">2</span>;i--)&#123;</span><br><span class="line">			d[i][<span class="number">2</span>]=d[i+<span class="number">1</span>][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">			d[i*<span class="number">2</span>][<span class="number">1</span>]=d[i][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">			d[i][<span class="number">0</span>]=min(d[i<span class="number">-1</span>][<span class="number">0</span>],d[i<span class="number">-1</span>][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">			d[i][<span class="number">2</span>]=min(d[i+<span class="number">1</span>][<span class="number">2</span>],d[i+<span class="number">1</span>][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">			d[i*<span class="number">2</span>][<span class="number">1</span>]=min(min(d[i][<span class="number">0</span>],d[i][<span class="number">2</span>]),d[i][<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,min(d[k][<span class="number">0</span>],min(d[k][<span class="number">1</span>],d[k][<span class="number">2</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>test_11</title>
    <url>/2018/02/24/test-11/</url>
    <content><![CDATA[<p><img src="http://www.gx8899.com/uploads/allimg/2017100509/4y4onjbnbgy.jpg" alt="png"><br><a id="more"></a></p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h3 id="标题3-1"><a href="#标题3-1" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4-1"><a href="#标题4-1" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><blockquote>
<p>quote<br>quote<br>quote</p>
<h4 id="标题4-2"><a href="#标题4-2" class="headerlink" title="标题4"></a>标题4</h4><blockquote>
<p>quote in quote</p>
<ol>
<li>list1</li>
<li>list2</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.<blockquote>
<ol>
<li>list1</li>
<li>list2</li>
</ol>
</blockquote>
</li>
<li><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>Suspendisse id sem consectetuer libero luctus adipiscing.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include&lt;cstdio&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>alert(‘233333’);</p>
</li>
</ul>
<hr>
<hr>
<hr>
<p><em>emphasize</em></p>
<p><code>printf(&quot;%d&quot;,a)</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include&lt;cstdio&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> os.getenv(<span class="string">'USER'</span>) != <span class="string">''</span>:</span><br><span class="line">  sys.stdin = open(<span class="string">'in'</span>, <span class="string">'r'</span>)</span><br><span class="line">  sys.stdout = open(out<span class="string">', '</span>w<span class="string">')</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> InputStream in;</span><br><span class="line">  <span class="keyword">static</span> PrintStream out;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getProperty(<span class="string">"ONLINE_JUDGE"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      out = System.out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      String file = <span class="string">"whatasha"</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file + <span class="string">".in"</span>));</span><br><span class="line">        out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file + <span class="string">".out"</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// replace System.&#123;in,out&#125; with &#123;in,out&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> InputStream in = java.lang.System.in;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> PrintStream out = java.lang.System.out;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> PrintStream err = java.lang.System.err;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">    java.lang.System.exit(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (java.lang.System.getProperty(<span class="string">"ONLINE_JUDGE"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String file = <span class="string">"whatasha"</span>;</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file + <span class="string">".in"</span>));</span><br><span class="line">        out = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file + <span class="string">".out"</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>test</tag>
        <tag>MARKDOWN</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/01/28/test-laptop-yzhid/</url>
    <content><![CDATA[<p>emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>test-mathematical</title>
    <url>/2018/02/26/test-mathematical/</url>
    <content><![CDATA[<p>$$a+b=c$$<br>$$ X  \mathop{\rightarrow}^{ P} Y$$<br>$ X  \mathop{\rightarrow}^{ P} Y$<br>$$E_1 \times E_2 \equiv E_2 \times E_1<br>E_1 \bowtie E_2 \equiv E_2 \bowtie E_1<br>E_1 \mathop{\bowtie}_{F} E_2 \equiv E_2 \mathop{\bowtie}_{F}E_1 $$<br>$$\cos 2\theta = \cos^2 \theta - \sin^2 \theta = 2 \cos^2 \theta$$<br>$$ \sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6} $$<br>$$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$<br>$$<br>f(n) =<br>\begin{cases}<br>n/2,  &amp; \text{if $n$ is even} \<br>3n+1, &amp; \text{if $n$ is odd}<br>\end{cases}<br>$$<br><a id="more"></a></p>
<hr>
<p>$$ R \cup S={t|t \in R \wedge t \in S }$$<br>$$ \bowtie _{a+b}^{} 23333$$<br> $$ {\begin{matrix}R \bowtie  S  \ a \theta  b \end{matrix}} $$<br>$$ \sum _{k=1}^{n} $$</p>
<p> $${\begin{matrix}R\ \bowtie \ S\a\ \theta \ b\end{matrix}} $$<br> $$ {\begin{matrix}R \bowtie S\a \theta  b\end{matrix}} $$<br>$$\mathop{ R \bowtie S}_{a \theta  b} = { \mathop{t_rt_s}^{ \frown} | t_r \in R  \wedge t \in S \wedge t_r[A] \theta t_s[B]}$$<br>⋉ ▷ ⋊<br>$$<br>\usepackage{wasysym}<br>R \bowtie S<br> \Bowtie<br>$$</p>
<p>$$R \under{\bowtie}_{233} S$$</p>
<p>在Unicode中，左外连接符号 :   ⟕ &#10197;<br>在Unicode中，右外连接符号是 ⟖ &#10198;<br>在Unicode中，全外连接符号是 ⟗ &#10199;</p>
<p>$$R  \times S ={r  \cup s| r  \in R, s  \in S }$$<br>$${\displaystyle X\times Y=\left{\left(x,y\right)\mid x\in X\land y\in Y\right}}。$$<br>$$R  \times S ={ \usepackage{t_r, t_s} t_r \frown  t_s | t_r \in R, t_s  \in S }$$<br>$$\overline{a+b+c+d} $$<br>$$ \usepackage{a,b}$$<br>$$ \frown{a,b}$$<br>$$ t_r^\frown t_s $$<br>设关系模式$R(A_1,A_2…A_n)$,它的一个关系为R。t $\in$ R 表示 <strong>t</strong> 是R的一个元组。$t[A_i]$则表示元组 <strong>t</strong> 中相应于属性$A_i$的一个分量。</p>
<p>$$\sigma_F(R)$$</p>
<hr>
<p>$$<br>\begin{equation}<br>\begin{split}<br>\frac{\partial^2 f}{\partial{x^2}} &amp;= \frac{\partial(\Delta_x f(i,j))}{\partial x} = \frac{\partial(f(i+1,j)-f(i,j))}{\partial x} \<br>&amp;= \frac{\partial f(i+1,j)}{\partial x} - \frac{\partial f(i,j)}{\partial x} \<br>&amp;= f(i+2,j) -2f(f+1,j) + f(i,j)<br>\end{split}<br>\nonumber<br>\end{equation}<br>$$</p>
<hr>
<p>$$<br>\begin{equation}<br>\sum_{i=0}^n F_i \cdot \phi (H, p_i) - \sum_{i=1}^n a_i \cdot ( \tilde{x_i}, \tilde{y_i}) + b_i \cdot ( \tilde{x_i}^2 , \tilde{y_i}^2 )<br>\end{equation}<br>$$<br>$$<br>\begin{equation}<br>\beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i))<br>\end{equation}<br>$$</p>
<hr>
<p>$$<br>\begin{equation}<br>\sum_{i=0}^n F_i \cdot \phi (H, p_i) - \sum_{i=1}^n a_i \cdot ( \tilde{x_i}, \tilde{y_i}) + b_i \cdot ( \tilde{x_i}^2 , \tilde{y_i}^2 )<br>\nonumber<br>\end{equation}<br>$$<br>$$<br>\begin{equation}<br>\beta^*(D) = \mathop{argmin} \limits_{\beta} \lambda {||\beta||}^2 + \sum_{i=1}^n max(0, 1 - y_i f_{\beta}(x_i))<br>\end{equation}<br>$$</p>
<hr>
<p>$$<br>\begin{equation}<br>\sum_{i=0}^n F_i \cdot \phi (H, p_i) - \sum_{i=1}^n a_i \cdot ( \tilde{x_i}, \tilde{y_i}) + b_i \cdot ( \tilde{x_i}^2 , \tilde{y_i}^2 ) \tag{1.2.3}<br>\end{equation}<br>$$</p>
<hr>
<p>$$<br>\left(<br>    \begin{array}{c}<br>      s \<br>      t<br>    \end{array}<br>\right)<br>=<br>\left(<br>    \begin{array}{cc}<br>      cos(b) &amp; -sin(b) \<br>      sin(b) &amp; cos(b)<br>    \end{array}<br>\right)<br>\left(<br>    \begin{array}{c}<br>      x \<br>      y<br>    \end{array}<br>\right)<br>$$</p>
<hr>
<p>$$<br>\left[<br>    \begin{array}{cc|c}<br>      1&amp;2&amp;3\<br>      4&amp;5&amp;6<br>    \end{array}<br>\right]<br>$$</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/01/28/test/</url>
    <content><![CDATA[<p><img src="/.io//1.PNG" alt="enter description here"></p>
<p>233333333333333333<br><img src="/.io//1.PNG" alt="enter description here"><br></p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>uva11572 Unique Snowflakes [ 尺取法 ]</title>
    <url>/2020/04/02/uva11572/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/UVA11572" target="_blank" rel="noopener">uva11572 Unique Snowflakes</a></p>
<p><a href="https://www.luogu.com.cn/blog/Nero-Yuzurizaki/chi-qu-fa-xiao-jie" target="_blank" rel="noopener">参考这里</a></p>
<p>题意：求没有重复数字的最长区间</p>
<blockquote>
<p>首先向右延申 (r++)，当有重复发生时，更新答案，l ++ &amp; 删除直到重复元素，然后继续 r++ 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,a[MAX],ans,l,r;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">			sf(a[i]); </span><br><span class="line">		ans=<span class="number">1</span>,l=<span class="number">1</span>,r=<span class="number">2</span>;  </span><br><span class="line">	    cnt.clear(); </span><br><span class="line">	    cnt[a[l]]++,cnt[a[r]]++;</span><br><span class="line">	    <span class="keyword">for</span> (;r&lt;=n;)&#123;</span><br><span class="line">		    <span class="keyword">while</span> (cnt[a[r]]&gt;<span class="number">1</span>) cnt[a[l++]]--;</span><br><span class="line">		    ans=max(ans,r&gt;n?r-l:r-l+<span class="number">1</span>);</span><br><span class="line">		    cnt[a[++r]]++;</span><br><span class="line">	    &#125;</span><br><span class="line">		pfn(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>尺取法</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>windows-回收站($Recycle.Bin)</title>
    <url>/2018/05/03/windows-%E5%9B%9E%E6%94%B6%E7%AB%99/</url>
    <content><![CDATA[<h3 id="Recycle-Bin文件夹"><a href="#Recycle-Bin文件夹" class="headerlink" title="$Recycle.Bin文件夹"></a>$Recycle.Bin文件夹</h3><p>Windows在每个盘符(volume)下都有一个名为$Recycle.Bin的隐藏文件夹</p>
<a id="more"></a> 
<img src="/.io//05/03/windows-回收站/c.png" title="c volume">
<img src="/.io//05/03/windows-回收站/f.png" title="f volume">
<p>$Recycle.Bin文件夹为每个用户都建立一个子文件夹( 私有的回收站 )，如下：<br><img src="/.io//05/03/windows-回收站/recyclebin.png" title="f volume"><br>子文件夹名为用户的SID(WIN7 以上)</p>
<h4 id="SID"><a href="#SID" class="headerlink" title="SID"></a>SID</h4><p>SID ”S-1-5-21-3548966769-4075873859-2225452062-1001“中，“s”表示Security identifier of  the user or group.”1”表示revision level,”5” 表示 authority level，”21-3…062” 表示 the domain or local computer identifier. “1001” 表示 Relative Id of User or Group.<br>可以在 \HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList 下查看用户的 SID，如下<br><img src="/.io//05/03/windows-回收站/regedit.png" title="f volume"></p>
<h4 id="用户私有-bin"><a href="#用户私有-bin" class="headerlink" title="用户私有 bin"></a>用户私有 bin</h4><img src="/.io//05/03/windows-回收站/userbin.png" title="userbin">
<p>一般的删除两个文件，bin中会出现两个文件：$R\&lt;FileID>.\&lt;ext>,$I\&lt;FileID>.\&lt;ext>。<br>$R\&lt;FileID>.\&lt;ext> 包含了被删除文件的content，$I\&lt;FileID>.\&lt;ext>为被删除文件的metadata，包括删除时间、路径、大小。<br><img src="/.io//05/03/windows-回收站/userbinr.png" title="userbin"></p>
<h5 id="R-lt-FileID-lt-ext"><a href="#R-lt-FileID-lt-ext" class="headerlink" title="$R\&lt;FileID>.\&lt;ext>"></a>$R\&lt;FileID>.\&lt;ext></h5><img src="/.io//05/03/windows-回收站/content.png" title="userbin">
<h5 id="I-lt-FileID-lt-ext"><a href="#I-lt-FileID-lt-ext" class="headerlink" title="$I\&lt;FileID>.\&lt;ext>"></a>$I\&lt;FileID>.\&lt;ext></h5><img src="/.io//05/03/windows-回收站/userbini.png" title="userbin">
<h3 id="Restoring-A-File"><a href="#Restoring-A-File" class="headerlink" title="Restoring A File"></a>Restoring A File</h3><h4 id="1、被删除文件的文件夹被删除"><a href="#1、被删除文件的文件夹被删除" class="headerlink" title="1、被删除文件的文件夹被删除"></a>1、被删除文件的文件夹被删除</h4><p>将重新建立原文件夹，若原文件夹删除后又重建，文件回复至现文件夹。</p>
<h4 id="2、删除文件夹"><a href="#2、删除文件夹" class="headerlink" title="2、删除文件夹"></a>2、删除文件夹</h4><p>对文件夹和文件夹里的各个文件都建立 $R\&lt;FileID>.\&lt;ext> 和 $I\&lt;FileID>.\&lt;ext> 文件。</p>
<h4 id="3、重复删除同一文件"><a href="#3、重复删除同一文件" class="headerlink" title="3、重复删除同一文件"></a>3、重复删除同一文件</h4><p>文件删除还原再删除 $R\&lt;FileID>.\&lt;ext> 和 $I\&lt;FileID>.\&lt;ext> 文件 是不同的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【1】<a href="https://pdfs.semanticscholar.org/db62/a02a2f90c569200bf37ead369221e04393d8.pdf" target="_blank" rel="noopener">https://pdfs.semanticscholar.org/db62/a02a2f90c569200bf37ead369221e04393d8.pdf</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows-回收站文件恢复</title>
    <url>/2018/05/08/windows-%E5%9B%9E%E6%94%B6%E7%AB%99%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<blockquote>
<p>windows 回收站的文件被 “彻底删除” 后，如果在回收站清空前，系统有对之前的数据建立 shadow copy，可恢复至之前版本。。。</p>
</blockquote>
<h3 id="volume-shadow-copy-service"><a href="#volume-shadow-copy-service" class="headerlink" title="volume shadow copy service"></a>volume shadow copy service</h3><p>The process of creating backup copy is konwn as  taking a “volume snapshot” and the actual backup copy of data is known as  a “shadow volume”.<br>就是磁盘某时刻的数据备份，，，win10 提供的备份功能（和本文讲的不同。。。），如下图<br><img src="/.io//05/08/windows-回收站文件恢复/win10备份.png" title="win10备份.png"></p>
<h3 id="vssadmin"><a href="#vssadmin" class="headerlink" title="vssadmin"></a>vssadmin</h3><p>“vssadmin list shadows”  显示已有 “shadow copy”。<br><img src="/.io//05/08/windows-回收站文件恢复/vssadmin.png" title="vssadmin.png"><br>标注的为卷应副本名。</p>
<h3 id="symbolic-link"><a href="#symbolic-link" class="headerlink" title="symbolic link"></a>symbolic link</h3><p>shadow volume 不是windows file-tree structure 的一部分不能被用户直接访问，，可通过建立 symbolic link（NTFS才可），，，<br><img src="/.io//05/08/windows-回收站文件恢复/mklink.png" title="mklink.png"><br>注意图中末尾的 “\” ,否则是看不到文件的。。。<br>可以看到 c 盘的之前版本文件，，</p>
<h4 id="回收站的怎么看？"><a href="#回收站的怎么看？" class="headerlink" title="回收站的怎么看？"></a>回收站的怎么看？</h4><p>   <a href="https://lscgx.github.io/2018/05/03/windows-%E5%9B%9E%E6%94%B6%E7%AB%99/">Windows 回收站</a></p>
<h3 id="参cong考zhe资chao料de"><a href="#参cong考zhe资chao料de" class="headerlink" title="参cong考zhe资chao料de"></a>参cong考zhe资chao料de</h3><p>【1】<a href="https://www.semanticscholar.org/paper/Shadow-Volume-Trash%3A-%24Recycle.Bin-Forensics-for-7-Leschke/7c5d730b14d04830d62ded6f98e0d88dc55c2700" target="_blank" rel="noopener">https://www.semanticscholar.org/paper/Shadow-Volume-Trash%3A-%24Recycle.Bin-Forensics-for-7-Leschke/7c5d730b14d04830d62ded6f98e0d88dc55c2700</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>元素的重复次数</title>
    <url>/2020/01/21/%E5%85%83%E7%B4%A0%E7%9A%84%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>Given a sorted array arr[] and a number x, write a function that counts the occurrences of x in arr[]. Expected time complexity is O(Logn)<br>Examples:</p>
<p>  Input: arr[] = {1, 1, 2, 2, 2, 2, 3,},   x = 2<br>  Output: 4 // x (or 2) occurs 4 times in arr[]</p>
<blockquote>
<p>对有序数组，找到元素 x 的左右边界即可。<br>注意二分的时候，左右的访问顺序</p>
</blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAX],x; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">first</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;l) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> m= (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(( m == <span class="number">0</span> || x &gt; a[m<span class="number">-1</span>]) &amp;&amp; a[m] == x) </span><br><span class="line">      	<span class="keyword">return</span> m; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;a[m])  <span class="comment">//先右边</span></span><br><span class="line">		<span class="keyword">return</span> first(a,m+<span class="number">1</span>,r,x);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> first(a,l,m<span class="number">-1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">last</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;l) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> m= (l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(( m == n<span class="number">-1</span> || x &lt; a[m+<span class="number">1</span>]) &amp;&amp; a[m] == x) </span><br><span class="line">      	<span class="keyword">return</span> m; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x&lt;a[m]) </span><br><span class="line">		<span class="keyword">return</span> last(a,l,m<span class="number">-1</span>,x);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> last(a,m+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	sf(x);</span><br><span class="line">	pf(last(a,<span class="number">0</span>,n,x) - first(a,<span class="number">0</span>,n,x) +<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>加括号</title>
    <url>/2020/01/29/%E5%8A%A0%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p><a href="https://practice.geeksforgeeks.org/problems/boolean-parenthesization/0" target="_blank" rel="noopener">https://practice.geeksforgeeks.org/problems/boolean-parenthesization/0</a></p>
<p>Given a boolean expression with following symbols.</p>
<p>Symbols<br>    ‘T’ —&gt; true<br>    ‘F’ —&gt; false</p>
<p>And following operators filled between symbols</p>
<p>Operators<br>    &amp;   —&gt; boolean AND<br>    |   —&gt; boolean OR<br>    ^   —&gt; boolean XOR</p>
<p>Count the number of ways we can parenthesize the expression so that the value of expression evaluates to true.</p>
<p>For Example:<br>The expression is “T | T &amp; F ^ T”, it evaluates true<br>in 4 ways ((T|T)&amp;(F^T)), (T|(T&amp;(F^T))), (((T|T)&amp;F)^T)<br>and (T|((T&amp;F)^T)).</p>
<blockquote>
<p>dp[ i ][ j ][ 0/1 ] 表示字符 i - j  区间内取 true 的个数和取 false 的个数。状态转移： dp[ i ][ j ][ ? ]  += dp[ i ][ h ][ ? ] * dp[ h+1 ][ j ][ ? ], 其中 “ ？”根据具体情况而定。<br>按照字符长度由下向上。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfs(n) scanf(<span class="meta-string">"%s"</span>,n);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1003</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,ans,dp[MAX][MAX][<span class="number">2</span>],xl,yl;</span><br><span class="line"><span class="keyword">char</span> x[MAX],y[MAX],a[MAX],tmp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mem(dp,<span class="number">0</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,xl)</span><br><span class="line">		<span class="keyword">if</span>(x[i]==<span class="string">'T'</span>) &#123;</span><br><span class="line">			dp[i][i][<span class="number">0</span>]=<span class="number">1</span>;dp[i][i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i][i][<span class="number">0</span>]=<span class="number">0</span>;dp[i][i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	fi(k,<span class="number">1</span>,xl)</span><br><span class="line">		fi(i,<span class="number">0</span>,xl-k )&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+k;</span><br><span class="line">			fi(h,i,j)&#123;</span><br><span class="line">				<span class="keyword">int</span> t1,t2,t3,t4;</span><br><span class="line">				t1=dp[i][h][<span class="number">0</span>] * dp[h+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">				t2=dp[i][h][<span class="number">0</span>] * dp[h+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">				t3=dp[i][h][<span class="number">1</span>] * dp[h+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">				t4=dp[i][h][<span class="number">1</span>] * dp[h+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">switch</span>(y[h])&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">'|'</span>: </span><br><span class="line">						dp[i][j][<span class="number">0</span>] += t1 + t2 + t3;</span><br><span class="line">						dp[i][j][<span class="number">1</span>] += t4;<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">						dp[i][j][<span class="number">0</span>] += t1;</span><br><span class="line">						dp[i][j][<span class="number">1</span>] += t2 + t3 + t4; <span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">'^'</span>: </span><br><span class="line">					    dp[i][j][<span class="number">0</span>] += t2 + t3;</span><br><span class="line">						dp[i][j][<span class="number">1</span>] += t1 + t4; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i][j][<span class="number">0</span>]%=MOD;dp[i][j][<span class="number">1</span>]%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		xl=<span class="number">0</span>,yl=<span class="number">0</span>;</span><br><span class="line">		sf(n);</span><br><span class="line">		sfs(a);</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			tmp=a[i];</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="string">'T'</span> || tmp==<span class="string">'F'</span>) x[xl++] = tmp;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="string">'|'</span> || tmp==<span class="string">'&amp;'</span> || tmp==<span class="string">'^'</span>) y[yl++] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		f();</span><br><span class="line">		pf(dp[<span class="number">0</span>][xl<span class="number">-1</span>][<span class="number">0</span>]);pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>质因子分解 - PollardRho</title>
    <url>/2020/01/05/%E5%90%88%E6%95%B0%E5%88%86%E8%A7%A3PollardRho/</url>
    <content><![CDATA[<p><a href="https://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/</a></p>
<blockquote>
<p>Pollard’s Rho Algorithm for Prime Factorization</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++ program to find a prime factor of composite using </span></span><br><span class="line"><span class="comment">Pollard's Rho algorithm */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="comment">//微妙级随机数种子（ t=1 时），t = 1000 为毫秒级</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">micro_srand</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    srand((tv.tv_sec * t ) + (tv.tv_usec / t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function to calculate (base^exponent)%modulus */</span></span><br><span class="line"><span class="function">lli <span class="title">power</span><span class="params">(lli base, <span class="keyword">int</span> exponent,lli modulus)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/* initialize result */</span></span><br><span class="line">	lli result = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (exponent &gt; <span class="number">0</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">/* if y is odd, multiply base with result */</span></span><br><span class="line">		<span class="keyword">if</span> (exponent &amp; <span class="number">1</span>) </span><br><span class="line">			result = (result * base) % modulus; </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* exponent = exponent/2 */</span></span><br><span class="line">		exponent = exponent &gt;&gt; <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* base = base * base */</span></span><br><span class="line">		base = (base * base) % modulus; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This function is called for all k trials. It returns </span></span><br><span class="line"><span class="comment">// false if n is composite and returns false if n is </span></span><br><span class="line"><span class="comment">// probably prime. </span></span><br><span class="line"><span class="comment">// d is an odd number such that d*2&lt;sup&gt;r&lt;/sup&gt; = n-1 </span></span><br><span class="line"><span class="comment">// for some r &gt;= 1 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miillerTest</span><span class="params">(lli d, lli n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// Pick a random number in [2..n-2] </span></span><br><span class="line">	<span class="comment">// Corner cases make sure that n &gt; 4 </span></span><br><span class="line">	lli a = <span class="number">2</span> + rand() % (n - <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute a^d % n </span></span><br><span class="line">	lli x = power(a, d, n); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == n<span class="number">-1</span>) </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Keep squaring x while one of the following doesn't </span></span><br><span class="line">	<span class="comment">// happen </span></span><br><span class="line">	<span class="comment">// (i) d does not reach n-1 </span></span><br><span class="line">	<span class="comment">// (ii) (x^2) % n is not 1 </span></span><br><span class="line">	<span class="comment">// (iii) (x^2) % n is not n-1 </span></span><br><span class="line">	<span class="keyword">while</span> (d != n<span class="number">-1</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		x = (x * x) % n; </span><br><span class="line">		d *= <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">1</span>)	 <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">		<span class="keyword">if</span> (x == n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return composite </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// It returns false if n is composite and returns true if n </span></span><br><span class="line"><span class="comment">// is probably prime. k is an input parameter that determines </span></span><br><span class="line"><span class="comment">// accuracy level. Higher value of k indicates more accuracy. </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(lli n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">// Corner cases </span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">1</span> || n == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find r such that n = 2^d * r + 1 for some r &gt;= 1 </span></span><br><span class="line">	lli d = n - <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span> (d % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">		d /= <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate given nber of 'k' times </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">		<span class="keyword">if</span> (!miillerTest(d, n)) </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* method to return prime divisor for n */</span></span><br><span class="line"><span class="function">lli  <span class="title">PollardRho</span><span class="params">(lli n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">/* initialize random seed */</span></span><br><span class="line">	micro_srand(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* no prime divisor for 1 */</span></span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> n; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* even number means one of the divisors is 2 */</span></span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果是素数返回 </span></span><br><span class="line">	<span class="keyword">if</span>(isPrime(n,<span class="number">1</span>)) <span class="keyword">return</span> n;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we will pick from the range [2, N) */</span></span><br><span class="line">	lli x = (rand()%(n<span class="number">-2</span>))+<span class="number">2</span>; </span><br><span class="line">	lli y = x; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the constant in f(x). </span></span><br><span class="line"><span class="comment">	* Algorithm can be re-run with a different c </span></span><br><span class="line"><span class="comment">	* if it throws failure for a composite. */</span></span><br><span class="line">	lli c = (rand()%(n<span class="number">-1</span>))+<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize candidate divisor (or result) */</span></span><br><span class="line">	lli d = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* until the prime factor isn't obtained. </span></span><br><span class="line"><span class="comment">	If n is prime, return n */</span></span><br><span class="line">	<span class="keyword">while</span> (d==<span class="number">1</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="comment">/* Tortoise Move: x(i+1) = f(x(i)) */</span></span><br><span class="line">		x = (power(x, <span class="number">2</span>, n) + c + n)%n; </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Hare Move: y(i+1) = f(f(y(i))) */</span></span><br><span class="line">		y = (power(y, <span class="number">2</span>, n) + c + n)%n; </span><br><span class="line">		y = (power(y, <span class="number">2</span>, n) + c + n)%n; </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check gcd of |x-y| and n */</span></span><br><span class="line">		d = __gcd(<span class="built_in">abs</span>(x-y), n); </span><br><span class="line"></span><br><span class="line">		<span class="comment">/* retry if the algorithm fails to find prime factor </span></span><br><span class="line"><span class="comment">		* with chosen x and c */</span></span><br><span class="line">		<span class="keyword">if</span> (d==n) <span class="keyword">return</span> PollardRho(n); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> d; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* driver function */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	lli n,ans[<span class="number">100</span>],t,cnt=<span class="number">0</span>; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">		t=PollardRho(n);</span><br><span class="line">		<span class="keyword">if</span>(isPrime(t,<span class="number">1</span>)) &#123;</span><br><span class="line">			ans[cnt++]=t;</span><br><span class="line">			n/=t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(ans,ans+cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Pollard’s Rho</tag>
        <tag>Miiller Rabin</tag>
        <tag>素数测试</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>同余</title>
    <url>/2018/03/15/%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<h3 id="日期的星期数"><a href="#日期的星期数" class="headerlink" title="日期的星期数"></a>日期的星期数</h3><h4 id="闰年？"><a href="#闰年？" class="headerlink" title="闰年？"></a>闰年？</h4><blockquote>
<p>被4整除，世纪数被4整除。闰年366天，2月29天。</p>
</blockquote>
<h4 id="y年m月d日，星期数？"><a href="#y年m月d日，星期数？" class="headerlink" title="y年m月d日，星期数？"></a>y年m月d日，星期数？</h4><p>用C 代表世纪数，0~6代表星期几。<br>为计算方便从3月1日开始计算，相当于把3月看成1月。现在y年m月d日变为Y年M月D日，有如下关系：<br>$$M=(m-3)mod12+1$$<br>$$Y=y-\lfloor m/11 \rfloor$$<br>由于$365\equiv 1(mod7)$,3月1日的星期数每过一个平年+1,每过一个闰年+2，设1600年3月1日的星期数为$w_{1600}$，y年3月1日(Y年3月1日)的星期数为$w_{Y}$，设y=Y=100C+X,从1600年到 Y 年要经过100C+X-1600年，星期数应加：<br>$$100C+X-1600\equiv 2C+X-3(mod 7)$$<br>每4年有一个闰年，有<br>$$\lfloor(100C+X-1600)/4\rfloor=25C+ \lfloor X/4\rfloor-400$$<br>个闰年，考虑到世纪年，应从这个数中减去C-16,再加$\lfloor  (C-16)/4\rfloor= \lfloor C/4\rfloor-4$。因此：<br>$$w_Y\equiv  w_{1600}+(2C+X+3)+(25C+\lfloor X/4\rfloor-400)-(C-16)+(\lfloor C/4\rfloor-4)$$<br>$$\equiv w_{1600}-2C+X +\lfloor X/4\rfloor +\lfloor C/4\rfloor(mod7)$$<br>已知2004年3月1日是星期一，代入上式，<br>$$1\equiv w_{1600}-2\times30+4+\lfloor 4/4\rfloor+\lfloor 20/4\rfloor\equiv w_{1600}+5(mod7)$$<br>得$w_{1600}=3$,于是，得到<br>$$w_Y\equiv 3-2C +X+\lfloor X/4\rfloor+\lfloor C/4\rfloor(mod7) \tag{1}$$<br>接下来计算从当年3月1日到每个月1号的天数，除每个月+30天外，3、5、7、8、10、12、1月有31天，应另外加的天数 z 如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">M</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">z</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>z 可表示成<br>$$z=\left{<br>\begin{array}{lcl}<br>\lfloor M/2\rfloor      &amp;      &amp; {1 \leqslant M \leqslant 6}\<br>\lfloor (M+1)/2\rfloor    &amp;      &amp; {7 \leqslant M \leqslant 11}\<br>\lfloor (M+1)/2\rfloor +1    &amp;      &amp; {M=12}\<br>\end{array} \right.$$<br>$$ =\lfloor (M+\lfloor M/7\rfloor)/2\rfloor+\lfloor M/12\rfloor  $$<br>因此，M月d日应在 $w_Y$ 上加<br>$$30(M-1)+\lfloor (M+\lfloor M/7 \rfloor)/2\rfloor +\lfloor M/12 \rfloor+d-1$$<br>$$=2M+\lfloor (M+\lfloor M/7 \rfloor)/2\rfloor+\lfloor M/12 \rfloor+d-3(mod 7) \tag{2}$$<br>最后将 (1)(2)两式合并，得到y年m月d日的星期数计算公式如下：<br>$$w\equiv  X+\lfloor X/4\rfloor+\lfloor C/4\rfloor-2C+2M+\lfloor (M+\lfloor M/7 \rfloor)/2\rfloor+\lfloor M/12 \rfloor+d(mod7)$$<br>其中 $M=(m-3)mod12+1,Y=y-\lfloor M/11\rfloor=100C+X$<br>例如，中华人民共和国成立月1949年10月1日，C=19,X=49,M=8,d=1<br>$$w\equiv 49+\lfloor 49/4\rfloor+\lfloor 19/4\rfloor-2 \times19+2 \times 8+\lfloor (8+\lfloor 8/7\rfloor)/2\rfloor +\lfloor 8/12\rfloor+1 \equiv 6(mod7)$$</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>《离散数学》</li>
</ol>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>寻找顶点</title>
    <url>/2020/01/26/%E5%AF%BB%E6%89%BE%E9%A1%B6%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec01.pdf" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec01.pdf</a></p>
<blockquote>
<p>一维数组：如果a[ mid ] &lt; a[ mid - 1 ] ,递归搜索左边，右边类似<br>a[ mid ] &gt; a[ mid - 1 ]  &amp;&amp; a[ mid ] &gt; a[ mid + 1 ]  时，即是一个顶点。</p>
</blockquote>
<blockquote>
<p>二维数组：<br>1）搜索中间列的最大值 MAX，判断与其左右的关系。<br>2）左右取大的一边继续搜索。转1）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> a[][MAX],<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> &amp;_max)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index=<span class="number">-1</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(a[i][m] &gt; _max)&#123;</span><br><span class="line">			_max=a[i][m];</span><br><span class="line">			index=i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> index;	</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> a[][MAX],<span class="keyword">int</span> rows,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _max = -INF,m=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> max_index=getMax(a,rows,m,_max);</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span> || m == r) <span class="keyword">return</span> _max;</span><br><span class="line">	<span class="keyword">if</span>(a[max_index][m<span class="number">-1</span>] &gt; _max) <span class="keyword">return</span> bs(a,rows,l,m<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span>  bs(a,rows,m+<span class="number">1</span>,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m,a[MAX][MAX];</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fi(j,<span class="number">0</span>,m)</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">	pf(bs(a,n,<span class="number">0</span>,m<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>小镇购物 [ bfs ]</title>
    <url>/2020/04/02/%E5%B0%8F%E9%95%87%E8%B4%AD%E7%89%A9/</url>
    <content><![CDATA[<p><strong>题目描述</strong></p>
<p>CSU镇上有n个商店，n个商店有m条双向小路相连，在这n个商店里共有k种不同商品，每个商店只有一种商品，每条路的权重都为1。现问你从每个商店出发，买够k种商品中的s种商品所需的最小代价,每个商店可以同时派出多个人买不同商品，买够即可。</p>
<p><strong>输入格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入包含多组测试用例。 </span><br><span class="line">对于每一组输入包含四个数字n ,m, k,s (1&lt;=n&lt;=m&lt;=1e5 , 1&lt;=s&lt;=k&lt;=min(n,100)) </span><br><span class="line">分别代表商店数，小路数，商品种数，需要的商品数。 </span><br><span class="line">接下来n个数 a1,a2...an (1&lt;=ai&lt;=k),ai代表第i个商店的商品编号。 </span><br><span class="line">接下来m行小路(u,v),u≠v,代表商店u和v之间有小路连接。</span><br></pre></td></tr></table></figure>
<p><strong>输出格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出n个数字，第i个数字代表从商店i出发买够s种商品所需的最小代价。</span><br></pre></td></tr></table></figure>
<p><strong>输入样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5 4 3</span><br><span class="line">1 2 4 3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">4 5</span><br><span class="line">7 6 3 2</span><br><span class="line">1 2 3 3 2 2 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">2 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2 2 2 3 </span><br><span class="line">1 1 1 2 2 1 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很明显是道 bfs , 但是要跑 n 遍 bfs ？ 考虑到数据 1e5 ,显然要超时的。。多源 bfs 常见处理就是，把一些点一起压入队列跑 bfs,避免频繁跑 bfs。题目要求的是，每一个点跑够 s 个不同的商品，点很多，而商品很少，所以可以先求每个商品到各个点的最小距离，这样一次可以将多个点（同商品）压入队列中，符合上面提到的处理方法。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>  n,m,k,s,x,y,a[MAX],dis[MAX][<span class="number">105</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> h[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].next=h[u];</span><br><span class="line">    h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(a[i] == x) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">            dis[i][x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.front();</span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v][x]==<span class="number">-1</span>)&#123;</span><br><span class="line">                dis[v][x]=dis[t][x]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen("in","r",stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(~sf(n))&#123;</span><br><span class="line">        sf(m);sf(k);sf(s);</span><br><span class="line">        fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">            sf(a[i]);</span><br><span class="line">        mem(h,<span class="number">-1</span>);</span><br><span class="line">        mem(dis,<span class="number">-1</span>);</span><br><span class="line">        fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">            sf(x);sf(y);</span><br><span class="line">            addedge(x,y);addedge(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        fi(i,<span class="number">1</span>,k+<span class="number">1</span>)</span><br><span class="line">            bfs(i);</span><br><span class="line">        fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">            sort(dis[i]+<span class="number">1</span>,dis[i]+<span class="number">1</span>+k);</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            fi(j,<span class="number">1</span>,s+<span class="number">1</span>)&#123;</span><br><span class="line">                cnt += dis[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            pf(cnt);pfc(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pfc(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 1196 银河英雄传说 [ 带权并查集 ]</title>
    <url>/2020/02/29/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<blockquote>
<p>对带权并查集的诠释是这样的：在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1196" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1196</a></p>
<p>题意：一条序列，两条指令。合并指令为 <code>M i j</code>，含义为第 <em>i</em> 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 <em>j</em> 号战舰所在的战舰队列的尾部。询问指令：<code>C i j</code>。该指令意思是，询问电脑，杨威利的第 <em>i</em> 号战舰与第 <em>j</em> 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">M 2 3</span><br><span class="line">C 1 2</span><br><span class="line">M 2 4</span><br><span class="line">C 4 2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用 dis 表示到根的距离。<code>M i j</code> 指令将 i 所在的根接到 j 所在队列的尾部，j 不一定是尾部（之前一直接 j …菜哭）所以需要 sum 数组记录一个队列集合的大小。dis[ fa ] += sum[ fb ] 就是合并后到根的距离。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">30000</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> t,a,b;</span><br><span class="line"><span class="keyword">char</span> cmd;</span><br><span class="line"><span class="keyword">int</span> f[MAX],dis[MAX],sum[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]!=x)&#123;</span><br><span class="line">		<span class="keyword">int</span> i=f[x];</span><br><span class="line">		f[x]=find(f[x]);</span><br><span class="line">		dis[x]+=dis[i];</span><br><span class="line">		sum[x]=sum[f[x]]; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,MAX)&#123;</span><br><span class="line">		f[i]=i;sum[i]=<span class="number">1</span>;dis[i]=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"\n%c %d%d"</span>,&amp;cmd,&amp;a,&amp;b);</span><br><span class="line">		<span class="keyword">int</span> fa=find(a);</span><br><span class="line">		<span class="keyword">int</span> fb=find(b);</span><br><span class="line">		<span class="keyword">if</span>(cmd==<span class="string">'M'</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">				f[fa]=fb; <span class="comment">//接到尾部 ...b 不一定是尾部 </span></span><br><span class="line">				dis[fa] += sum[fb]; <span class="comment">//更新路径 </span></span><br><span class="line">				sum[fa] += sum[fb]; <span class="comment">//更新集合大小 </span></span><br><span class="line">				sum[fb]  = sum[fa];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmd==<span class="string">'C'</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">				pfc(<span class="string">"-1\n"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				pf(<span class="built_in">abs</span>(dis[b]-dis[a])<span class="number">-1</span>);</span><br><span class="line">				pfc(<span class="string">"\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font color="#eb1eb0">更多：</font></strong></p>
<p><a href="https://blog.csdn.net/yjr3426619/article/details/82315133" target="_blank" rel="noopener">带权并查集介绍</a></p>
<p><a href="https://www.luogu.com.cn/blog/XTZORZ/solution-p2024" target="_blank" rel="noopener">洛谷p2024食物链</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-关系代数</title>
    <url>/2018/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>关系代数是一种抽象的查询语言，它用于对关系的运算来表达查询。<br>关系代数的运算按运算符的不同分为传统的集合运算和专门的关系运算两类。</p>
</blockquote>
<a id="more"></a>
<ol>
<li>集合运算和关系运算的不同<ul>
<li>传统的集合运算将关系看成元组的集合，其运算是从关系的“水平”方向进行，即行的角度来进行。而专门的关系运算不仅涉及行而且涉及列。</li>
<li>比较运算符和逻辑运算符专门辅助关系运算。</li>
<li>笛卡尔积定义不同<ul>
<li>集合论中的笛卡儿积定义：<br>$${\displaystyle X\times Y=\left{\left(x,y\right)\mid x\in X\land y\in Y\right}}$$</li>
<li>关系运算中的笛卡儿积定义：<br>$$R  \times S ={r  \cup s| r \in R, s  \in S }$$<br>或者<br>$$R  \times S ={  \mathop{t_rt_s}^{ \frown} | t_r \in R, t_s  \in S }$$(课本定义)</li>
</ul>
</li>
</ul>
</li>
<li>关系运算<br>包括选择、投影、连接、除等。<ul>
<li>选择：在关系R中选出满足规定条件的诸元组（即从<strong>行</strong>的角度进行的运算 ）。记作：<br>$$\sigma_F(R)={ t | t \in R  \wedge F(t)=’true’ }$$<br>( /ˈsɪɡmə/)<br>F是一个逻辑表达式。</li>
<li>投影：从R中选出若干属性列组成新的关系（即从<strong>列</strong>的角度进行的运算）。记作：<br>$$ \Pi_A(R) ={t[A] | t \in R}$$<br>投影之后不仅取消原关系中的某些列而且会取消某些元组，因为取消某些列后可能出现重复的行，应取消在这些行。</li>
<li>连接($\theta 连接$)，从连个关系的笛卡儿积中选择属性间满足一定条件的元组。记作:<br>$$\mathop{ R \bowtie S}_{a \theta  b} = { \mathop{t_rt_s}^{ \frown} | t_r \in R  \wedge t \in S \wedge t_r[A] \theta t_s[B]}$$<br>A 和 B 为 R 和 S 上可比较的属性组，$\theta$为比较运算符。<br>连接运算从R和S的笛卡儿积 R $\times$ S 中选取  R 关系在 A 属性组上的值和 S 关系在 B 属性组上的值满足比较关系 $\theta$ 的元组。<ul>
<li>自然连接和等值连接<br>等值连接即$\theta$为 <strong>=</strong>的连接。两者的区别在于自然连接取消重复列。<br>两个关系R和S在做自然连接时，取公共属性上值相等的元组构成新的关系，可能产生悬浮元组（双方公共属性不相等的元组）。由此引出<strong>外连接、左外连接和右外连接</strong>。顾名思义，外连接(R &#10199; S )保留双方的悬浮元组，左外连接(R &#10197; S)保留 R 的，右外连接(R &#10198; S)保留 S 的。</li>
</ul>
</li>
<li>除运算(同时从<strong>行和列</strong>角度进行的运算)<br>设关系 R 除以关系 S 的结果为关系 T,则 <strong>T 包含所有在R但是不在 S 中的属性和值，且 T 的元组和 S 的元组的所有组合都在 R 中</strong>。<br>给定关系 R(X, Y) 和 S(Y, Z),其中X，Y，Z为属性组。R中的 Y 与 S 中的 Y 可以有不同的属性名，但必须出自相同的域集。<br>R 与  S 的除运算得到一个新的关系P(X),P 是 R 中满足下列条件的元组在 X 属性列上的投影：元组在 X 上的分量值 x 的象集 $Y_x$ 包含 S 在 Y 上投影的集合。记作：<br>$$R \div S= {t_r[X]|t_r \in R \wedge  \Pi_y(S) \subseteq Y_x}$$<br>其中 $Y_x$ 为 x 在 R 中的象集，$x=t_r[X]$。<br>[例子]查询选修了所有课程的学生学号和姓名。<br>$$\Pi_{Sno,Cno}(SC) \div \Pi_{Cno}(Course)\bowtie \Pi_{Sno,Sname}(Student)$$</li>
</ul>
</li>
<li><p>关系代数表达式等价替换规则。<br>设 E 是关系代数表达式。<br>(1)交换律</p>
<ul>
<li>连接、笛卡儿积的交换律<br>$$E_1 \times E_2 \equiv E_2 \times E_1$$<br>$$E_1 \bowtie E_2 \equiv E_2 \bowtie E_1$$<br>$$E_1 \mathop{\bowtie}_{F} E_2 \equiv E_2 \mathop{\bowtie}_{F}E_1 $$<br>F 是连接运算的条件。</li>
<li>选择与投影操作的交换律<br>$$\sigma_{F}(\Pi_{A_1,A_2,\dotsb,A_n}(E)) \equiv \Pi_{A_1,A_2,\dotsb,A_n}(\sigma_{F}(E))$$<br>条件 F 里只涉及 属性$ {A_1,A_2,\dotsb,A_n}$时，上式成立。否则有下更一般的结论。<br>$$\Pi_{A_1,A_2,\dotsb,A_n}(\sigma_{F}(E)) \equiv                   \Pi_{A_1,A_2,\dotsb,A_n}(\sigma_{F}   (\Pi_{A_1,A_2,\dotsb,A_n,B_1,B_2,\dotsb,B_n}(E)))$$</li>
<li>选择与笛卡儿积的交换律<br>如果 F 中涉及的属性都是 $E_1$ 中的属性，则<br>$$\sigma_{F}(E_1 \times E_2) \equiv \sigma_{F}(E_1) \times E_2$$<br>如果 $F=F_1 \wedge F_2$, 并且 $F_1$ 只涉及 $E_1$ 中的属性，$F_2$ 只涉及 $E_2$ 中的属性，则由等价变换l连接的交换律、选择的串接定律以及上式可推出<br>$$\sigma_{F}(E_1 \times E_2) \equiv \sigma_{F_1}(E_1) \times \sigma_{F_2}(E_2)$$<br>若$F_1$ 只涉及 $E_1$ 中的属性，$F_2$ 涉及 $E_1$ 和 $E_2$的属性，则仍有<br>$$\sigma_{F}(E_1 \times E_2) \equiv \sigma_{F_2}(\sigma_{F_1}(E_1) \times E_2)$$<br>它是部分选择在笛卡儿积前先做。</li>
</ul>
<p>(2)结合律</p>
<ul>
<li>连接、笛卡儿积的结合律</li>
</ul>
<p>(3)分配律</p>
<ul>
<li>选择与并的分配律<br>设 $E=E_1 \cup E_2$ ，$E_1$、$E_2$有相同的属性名，则<br>$$\sigma_{F}(E_1 \cup E_2) \equiv \sigma_{F}(E_1) \cup\sigma_{F}(E_2)$$</li>
<li>选择与差运算的分配律<br>$E_1$、$E_2$有相同的属性名，则<br>$$\sigma_{F}(E_1 - E_2) \equiv \sigma_{F}(E_1) - \sigma_{F}(E_2)$$</li>
<li>选择对自然连接的分配律<br>$$\sigma_{F}(E_1 \bowtie E_2) \equiv \sigma_{F}(E_1) \bowtie \sigma_{F}(E_2)$$<br>F 只涉及 $E_1$、$E_2$的公共属性。</li>
<li>投影与笛卡儿积的分配律<br>A 是 $E_1$ 的属性，    B 是 $E_2$ 的属性。<br>$$\Pi_{A_1,A_2,\dotsb,A_n,B_1,B_2,\dotsb,B_n}(E_1 \times E_2) \equiv \Pi_{A_1,A_2,\dotsb,A_n}(E_1) \times \Pi_{B_1,B_2,\dotsb,B_n}(E_2)$$</li>
<li>投影与并的分配律<br>$E_1$、$E_2$有相同的属性名，则<br>$$\Pi_{A_1,A_2,\dotsb,A_n}(E_1 \cup E_2) \equiv \Pi_{A_1,A_2,\dotsb,A_n}(E_1) \cup \Pi_{A_1,A_2,\dotsb,A_n}(E_2 )$$</li>
</ul>
<p>(4)串接定律</p>
<ul>
<li>投影的串接定律<br>$$\Pi_{A_1,A_2,\dotsb,A_n}(\Pi_{B_1,B_2,\dotsb,B_n}(E)) \equiv \Pi_{A_1,A_2,\dotsb,A_n}(E)$$<br>${A_1,A_2,\dotsb,A_n}$ 是 ${B_1,B_2,\dotsb,B_n}$ 的子集。</li>
<li>选择的串接定律<br>$$\sigma_{F_1}(\sigma_{F_2}(E)) \equiv \sigma_{F_1\wedge F_2}(E)$$    </li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>几个约定：<br>      (1) 设关系模式$R(A_1,A_2,\dotsb,A_n)$,它的一个关系为R。t $\in$ R 表示 <strong>t</strong> 是R的一个元组。$t[A_i]$则表示元组 <strong>t</strong> 中相应于属性$A_i$的一个分量。<br>      (2) $t[A] =( t[A_{i1}],t[A_{i2}],\dotsb,t[A_{ik}]) $ 表示元组 <strong>t</strong> 在属性列 A 上诸分量的集合，$\overline{A} $ 表示剩余的属性组。<br>      (3) R 为 n 目关系，S 为 m 目关系。$t_r \in R $,$t_s \in S $, $ \mathop{t_rt_s}^{ \frown} $ 称为元组的连接。它是一个n + m 的元组。<br>      (4) 给定一个关系为 R(X,Z) ,X 和Z为属性组。当 t[X]=x 时，x 在 R 上的象集定义为<br>      $$ Z_x={ t[Z] | t \in R,t[X]=x}$$<br>      它表示R中属性组X上的值为 x 的诸元组在 Z 上分量的集合。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>关系代数</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-索引</title>
    <url>/2018/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<blockquote>
<p>数据库中常用的存取方法为索引方法和聚簇方法。索引方法包括B+树索引和Hash索引。</p>
</blockquote>
<ol>
<li><p>B+树索引<br> 对一个或多个属性列建立索引（组合索引、唯一索引）。<br> 一般如下：</p>
<ul>
<li>如果一个（或一组）属性经常在查询条件里出现，则考虑建立索引。</li>
<li>如果一个属性经常作为最大值和最小值等聚集函数的参数。</li>
<li><p>如果一个（或一组）属性经常在连接操作的连接条件中出现。</p>
<p>关系上定义的索引并不是越多越好，系统为维护索引要付出代价。更新频率高的关系索引不宜太多。</p>
</li>
</ul>
</li>
<li>Hash索引<br> 如果一个关系的属性主要出现在等值连接条件或主要出现在等值比较选择条件中，而且满足下列条件之一<ul>
<li>一个关系的大小可以预知，而且不变。</li>
<li>关系的大小动态改变，但数据库管理系统提供了动态hash存取方法。<br>则可选择hash存取方法。</li>
</ul>
</li>
<li>聚簇索引<br> 为了提高某个属性（或属性组）的查询速度，把这个或这些属性上具有相同值得元组集中存放在连续得物理块中成为聚簇。该属性（或属性组）成为聚簇码。<br> 一个数据库可以建立多个聚簇，一个关系只能加入一个聚簇。<br> 首先涉及候选聚簇一般来说<br>   <em>(1) 对经常在一起进行连接操作的关系建立聚簇。<br>   (2) 如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇。<br>   (3) 如果一个人关系的一个（或一组）属性上的值重复率很高，则此单个             关系可建立聚簇。即对应每个聚簇码值呃平均元组数不能太少，太少             则聚簇的效果不明显。</em><br> 然后检查候选聚簇中的关系，取消其中不必要的关系。<br>   <em>(1) 从聚簇中删除经常进行全表扫描的关系。<br>   (2) 从聚簇中删除更新操作多于连接操作的关系。<br>   (3) 不同的聚簇中可能包含相同的关系，一个关系可以在某一个聚簇中，但不能同时加入多个聚簇。要从这多个聚簇方案（包括不建立聚簇）中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。</em><blockquote>
<p>对已有关系建立聚簇将导致关系中元组移动其物理存储位置，并使次关系上原来建立的所有索引无效，必须重建。当一个元组的聚簇码值改变时，该元组的存储位置也要做相应移动，聚簇码要相对稳定，以减少修改聚簇码值所引起的维护开销。<br>因此，当通过聚簇码进行访问或连接是该关系的主要应用，与聚簇码无关的其他访问很少或者是次要的，这时可以使用聚簇。尤其当 SQL 语句中包含与聚簇码有关的ORDER BY、GROUP BY、UNION、DISTINCT等子句或短语时，使用聚簇特别有利，可以省去对结果集的排序操作；否则很可能适得其反。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-规范化</title>
    <url>/2018/02/28/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A7%84%E8%8C%83%E5%8C%96/</url>
    <content><![CDATA[<ol>
<li><p>函数依赖</p>
<ul>
<li><p>设 <em>R(U)</em>是属性集 <em>U</em> 上的关系模式，<em>X,Y</em> 是 <em>U</em> 的子集。若对于 <em>R(U)</em>的任意一个可能的关系 <em>r</em>,<em>r</em> 中不可能存在两个元组在 X 上的属性值相等，而在 <em>Y</em> 上的属性值不等，则称 <strong>X函数确定Y</strong> 或 <strong>Y 函数依赖于 X</strong>，记作$X \rightarrow Y$。</p>
<blockquote>
<p>术语&amp;记号<br>$X \rightarrow Y$，但 $Y\nsubseteq X$，则称$X \rightarrow Y$是<strong>非平凡的函数依赖</strong>。<br>$X \rightarrow Y$，但 $Y\subseteq X$，则称$X \rightarrow Y$是<strong>平凡的函数依赖</strong>。对于任一关系模式，平凡还是依赖总是成立。<br>若 $X \rightarrow Y$，则称 X 为这个函数依赖的决定属性组，也称<strong>决定因素</strong>。<br>若 $X \rightarrow Y$，$Y \rightarrow X$，则记作 $X \leftarrow \rightarrow Y$。<br>若 Y 不函数依赖于 X，则记作 $X  \nrightarrow Y$。</p>
</blockquote>
</li>
<li><p>在 R(U) 中，如果 $X \rightarrow Y$，并且对于X 的任何一个真子集 $X^{‘}$, 都有 $X^{‘}  \nrightarrow Y$，则 Y 对 X <strong>完全函数依赖</strong>，记作<br>$$ X  \mathop{\rightarrow}^{ F} Y$$<br>否则为<strong>部分函数依赖</strong>，记作<br>$$ X  \mathop{\rightarrow}^{ P} Y$$</p>
</li>
<li>在 R(U) 中，如果 $X \rightarrow Y(Y\nsubseteq X)$，$Y  \nrightarrow X$，$Y  \rightarrow Z$，$Z\nsubseteq Y$ 则称 Z 对  X<strong>传递函数依赖</strong>。记作$ X  \mathop{\rightarrow}^{传递} Y $。</li>
</ul>
</li>
</ol>
<a id="more"></a>    
<ol start="2">
<li><p>码</p>
<ul>
<li>设 K 为 R&lt; U,F&gt;  中的属性和属性组合，若 $ K  \mathop{\rightarrow}^{ F} U$，则K 为 R的<strong>候选码</strong>。<br>若 U 部分函数依赖于 K ,即 $ K  \mathop{\rightarrow}^{ P} U$，则 K 成为 <strong>超码</strong>。候选码是最小的超码。若候选码多于一个，则选定其中的一个为主码。<br>包含在任何一个候选码中的属性称为<strong>主属性</strong>；反之为<strong>非主属性</strong>。</li>
<li>关系模式 R 中的属性或属性组 X 并非 R 的码，但X 是另一个关系模式的码，则称 X 是 R的<strong>外部码</strong>，也称外码。<br>主码和外码提供了一个表示关系间联系的手段。</li>
</ul>
</li>
<li><p>范式<br> 关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p>
<ul>
<li>1NF</li>
<li>2NF<br>若 $R \in 1NF$， 且每一个非主属性完全函数依赖于任何一个候选码，则$R \in 2NF$。<br>不满足2NF会产生插入异常、上除异常以及修改复杂等问题。</li>
<li>3NF<br>设关系模式 $R&lt; U,F&gt;  \in 1NF$，若R 中不存在这样的码 X，属性组 Y及非属性组$ Z(Z \nsupseteq Y)$ 使得 $X \rightarrow Y$，$Y \rightarrow Z$成立，$Y  \nrightarrow X$，则称 $R&lt; U,F&gt;  \in 3NF$</li>
<li>BCNF</li>
</ul>
</li>
<li><p>多值依赖&amp;4NF</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数组最大值</title>
    <url>/2020/01/21/%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p>数组先升后降，找到这个转折点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> a[] ,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> a[l];</span><br><span class="line">	<span class="keyword">if</span>((l+<span class="number">1</span> == r) &amp;&amp; a[l]&gt;=a[r]) </span><br><span class="line">		<span class="keyword">return</span> a[l];</span><br><span class="line">	<span class="keyword">if</span>((l+<span class="number">1</span> == r) &amp;&amp; a[l]&lt;a[r]) </span><br><span class="line">		<span class="keyword">return</span> a[r];</span><br><span class="line">	<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[m] &gt;a[m+<span class="number">1</span>] &amp;&amp; a[m] &gt;a[m<span class="number">-1</span>]) </span><br><span class="line">		<span class="keyword">return</span> a[m];</span><br><span class="line">	<span class="keyword">if</span>(a[m] &gt;a[m+<span class="number">1</span>] &amp;&amp; a[m] &lt;a[m<span class="number">-1</span>]) </span><br><span class="line">		<span class="keyword">return</span> bs(a,l,m<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span> bs(a,m+<span class="number">1</span>,r);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 1462 通往奥格瑞玛的道路 [ 二分 + dij ]</title>
    <url>/2020/02/26/%E6%B4%9B%E8%B0%B71462%E9%80%9A%E5%BE%80%E5%A5%A5%E6%A0%BC%E7%91%9E%E7%8E%9B%E7%9A%84%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1462" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1462</a></p>
<p><strong>题目背景</strong></p>
<p>在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量</p>
<p>有一天他醒来后发现自己居然到了联盟的主城暴风城</p>
<p>在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛</p>
<p><strong>题目描述</strong></p>
<p>在艾泽拉斯，有n个城市。编号为1,2,3,…,n。</p>
<p>城市之间有m条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。</p>
<p>每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。</p>
<p>假设1为暴风城，n为奥格瑞玛，而他的血量最多为b，出发时他的血量是满的。</p>
<p>歪嘴哦不希望花很多钱，他想知道，在可以到达奥格瑞玛的情况下，他所经过的所有城市中最多的一次收取的费用的最小值是多少。</p>
<p><strong>输入格式</strong></p>
<p>第一行3个正整数，n，m，b。分别表示有n个城市，m条公路，歪嘴哦的血量为b。</p>
<p>接下来有n行，每行1个正整数，fi。表示经过城市i，需要交费fi元。</p>
<p>再接下来有m行，每行3个正整数，ai，bi，ci(1&lt;=ai，bi&lt;=n)。表示城市ai和城市bi之间有一条公路，如果从城市ai到城市bi，或者从城市bi到城市ai，会损失ci的血量。</p>
<p><strong>输出格式</strong></p>
<p>仅一个整数，表示歪嘴哦交费最多的一次的最小值。</p>
<p>如果他无法到达奥格瑞玛，输出AFK。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4 8</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">2 1 2</span><br><span class="line">2 4 1</span><br><span class="line">1 3 4</span><br><span class="line">3 4 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对所有的缴费排序，二分判断每个最大缴费是否可行。</p>
<p>开始 优先队列 一直压点…蠢哭…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,b,vis[MAX],fi[MAX],d[MAX],ai,bi,ci,ans=<span class="number">0</span>;</span><br><span class="line">ll low[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next,c;</span><br><span class="line">&#125;edge[<span class="number">10</span>*MAX];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	edge[tot].to=v;</span><br><span class="line">	edge[tot].c=c;</span><br><span class="line">	edge[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	ll c;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c&gt;x.c;</span><br><span class="line">    &#125;</span><br><span class="line">    node(<span class="keyword">int</span> _i,ll _c)&#123;</span><br><span class="line">    	i=_i;</span><br><span class="line">    	c=_c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		vis[i]=<span class="literal">false</span>;</span><br><span class="line">		low[i]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(d[s] &gt; high) <span class="keyword">return</span>;<span class="comment">//第一个点就不符合 </span></span><br><span class="line">	low[s]=<span class="number">0</span>;</span><br><span class="line">	q.push(node(s,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node cur=q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">int</span> v=cur.i;</span><br><span class="line">		ll lowv=cur.c;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[v]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> t=edge[i].to;</span><br><span class="line">			<span class="keyword">int</span> c=edge[i].c;</span><br><span class="line">			<span class="keyword">if</span>(fi[t] &lt;= high &amp;&amp; lowv + c &lt; low[t])&#123;</span><br><span class="line">				low[t] = lowv + c;</span><br><span class="line">				q.push(node(t,low[t]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);sf(b);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(fi[i]);</span><br><span class="line">		d[i]=fi[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line">	init();</span><br><span class="line">	fi(i,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(ai);sf(bi);sf(ci);</span><br><span class="line">		addedge(ai,bi,ci);</span><br><span class="line">		addedge(bi,ai,ci);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		dij(<span class="number">1</span>,d[m]);</span><br><span class="line">		<span class="keyword">if</span>(low[n]&gt;b)&#123; </span><br><span class="line">			l=m+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ans=d[m];</span><br><span class="line">			r=m<span class="number">-1</span>;</span><br><span class="line">		&#125; ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans) pf(ans);</span><br><span class="line">	<span class="keyword">else</span> pfc(<span class="string">"AFK"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷1980</title>
    <url>/2020/02/10/%E6%B4%9B%E8%B0%B71980/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1980" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1980</a><br>题目描述<br>试计算在区间 1 到 n 的所有整数中，数字x(0 ≤ x ≤ 9) 共出现了多少次？例如，在 1到11中，即在 1,2,3,4,5,6,7,8,9,10,11 中，数字 1 出现了 4 次。</p>
<p>输入格式<br>2个整数 n,x 之间用一个空格隔开。</p>
<p>输出格式<br>1 个整数，表示 x 出现的次数。</p>
<p>输入输出样例<br>输入 #1复制<br>11 1<br>输出 #1复制<br>4</p>
<blockquote>
<p>三个状态：pre 表示前面已有多少个 X 出现。prex  表示前一个数 ，flag  表示前面是否全为 0 。 prex ,flag 专门统计 0 而设 orz… 因为不能统计前导 0 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,x;<span class="comment">//flag 前面不全为 0？ </span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> prex,<span class="keyword">bool</span> flag,<span class="keyword">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag &amp;&amp; x==<span class="number">0</span> &amp;&amp; prex==<span class="number">0</span> &amp;&amp;pos==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">-1</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[pos][pre][prex][flag]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre][prex][flag];</span><br><span class="line">    <span class="keyword">int</span> up=limit ? a[pos] : <span class="number">9</span>;</span><br><span class="line">    ll tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up;i++)&#123;    </span><br><span class="line">        <span class="keyword">if</span>(i==x)  tmp+=dfs(pos<span class="number">-1</span>,(flag&amp;&amp;x==<span class="number">0</span>)||x!=<span class="number">0</span>? pre+<span class="number">1</span> :pre,i,flag,limit &amp;&amp; i==a[pos]);</span><br><span class="line">        <span class="keyword">else</span>  tmp+=dfs(pos<span class="number">-1</span>,pre,x&gt;<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>,i,limit &amp;&amp; i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) dp[pos][pre][prex][flag]=tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        a[pos++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(pos<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in","r",stdin);</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;solve(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1005 矩阵取数 [ 高精 dp ]</title>
    <url>/2020/05/06/%E6%B4%9B%E8%B0%B7P1005/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1005" target="_blank" rel="noopener">P1005 矩阵取数</a></p>
<p><strong>题目描述</strong></p>
<p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 n<em>×</em>m 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：</p>
<ol>
<li>每次取数时须从每行各取走一个元素，共 n 个。经过 m 次后取完矩阵内所有元素；</li>
<li>每次取走的各个元素只能是该元素所在行的行首或行尾；</li>
<li>每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 ×2^i，其中 <em>i</em> 表示第 <em>i</em> 次取数（从 1 开始编号）；</li>
<li>游戏结束总得分为 m 次取数得分之和。</li>
</ol>
<p>帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p>
<p><strong>输入输出格式</strong></p>
<p>输入文件包括 n+1 行：</p>
<p>第一行为两个用空格隔开的整数 n 和 m。</p>
<p>第 2∽<em>n</em>+1 行为 n<em>×</em>m 矩阵，其中每行有 m 个用单个空格隔开的非负整数。</p>
<p><strong>输出格式</strong></p>
<p>输出文件仅包含1行，为一个整数，即输入矩阵取数后的最大得分。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 2 3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">82</span><br></pre></td></tr></table></figure>
<p><strong>HINT</strong></p>
<p>NOIP 2007 提高第三题。</p>
<p>数据范围：</p>
<p>60% 的数据满足：1≤<em>n</em>,<em>m</em>≤30，答案不超过 $10^{16}$。</p>
<p>100% 的数据满足：1≤<em>n</em>,<em>m</em>≤80，$0≤a_{ij}≤1000$。</p>
<blockquote>
<p>区间dp, 题目是取的，逆着放就可以了。。</p>
<p>然后就是预处理出2的幂，保存起来，<strong>用高精！</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll a[MAX][MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bigint</span>&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> MOD=<span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1000</span>],len;</span><br><span class="line">	bigint()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		len = <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	bigint(ll x)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			a[len++]=x%MOD;</span><br><span class="line">			x/=MOD;</span><br><span class="line">		&#125;<span class="keyword">while</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> bigint &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(len&lt;b.len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(len&gt;b.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;b.a[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;b.a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	bigint <span class="keyword">operator</span> + (<span class="keyword">const</span> bigint &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		bigint res;</span><br><span class="line">		res.len=max(len,b.len);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)&#123;</span><br><span class="line">			res.a[i]+=((i&lt;len)?a[i]:<span class="number">0</span>)+((i&lt;b.len)?b.a[i]:<span class="number">0</span>);</span><br><span class="line">			res.a[i+<span class="number">1</span>]+=res.a[i]/MOD;</span><br><span class="line">			res.a[i]%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res.a[res.len]&gt;<span class="number">0</span>) res.len++;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	bigint <span class="keyword">operator</span> * (<span class="keyword">const</span> bigint &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		bigint res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> up=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp=a[i]*b.a[j] + res.a[i+j]+up;</span><br><span class="line">				res.a[i+j] = tmp % MOD;</span><br><span class="line">				up = tmp / MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(up) res.a[i+b.len] = up;</span><br><span class="line">		&#125;</span><br><span class="line">		res.len =len + b.len; </span><br><span class="line">		<span class="keyword">while</span>(res.a[res.len <span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; res.len &gt;<span class="number">1</span>) res.len--;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,a[len<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%04d"</span>,a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bigint f[MAX][MAX],ans,p2[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	p2[<span class="number">0</span>]=bigint(<span class="number">1</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,MAX) p2[i]=p2[i<span class="number">-1</span>]*bigint(<span class="number">2</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fi(j,<span class="number">0</span>,m) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i][j]);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		fi(j,<span class="number">0</span>,m) f[j][j]=bigint(a[i][j])*p2[m];</span><br><span class="line">		fi(k,<span class="number">2</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			fi(j,<span class="number">0</span>,m-k+<span class="number">1</span>)&#123; </span><br><span class="line">				<span class="keyword">int</span> e = j + k - <span class="number">1</span>;</span><br><span class="line">				bigint t1 = f[j+<span class="number">1</span>][e] + bigint(a[i][j])*p2[m-k+<span class="number">1</span>];</span><br><span class="line">				bigint t2 = f[j][e<span class="number">-1</span>] + bigint(a[i][e])*p2[m-k+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(t1&lt;t2) f[j][e] = t2;</span><br><span class="line">				<span class="keyword">else</span> f[j][e] = t1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = ans + f[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	ans.print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1020 导弹拦截[ LIS dilworth定理 二分 ]</title>
    <url>/2020/03/02/%E6%B4%9B%E8%B0%B7P1020/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1020</a></p>
<p><strong>题目描述</strong></p>
<p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p>
<p>输入导弹依次飞来的高度（雷达给出的高度数据是 ≤50000 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<p><strong>输入格式</strong></p>
<p>1行，若干个整数（个数 ≤100000）</p>
<p><strong>输出格式</strong></p>
<p>2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">389 207 155 300 299 170 158 65</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font color="#FF1493">dilworth定理</font> : 对于任意有限偏序集，其最长链中元素的数目必等于其最小反链划分中反链的数目。</p>
<p>并不能看懂，看了一圈下来，意思就是本题中需要多少套导弹拦截系统等于最长上升子序列的长度。</p>
<p>然后求一遍最长不增序列和一趟最长上升序列。两个的二分有区别，需要注意一下…当然也可以用 </p>
<p><code>algorithm</code> 里面的函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX],cnt,len1,len2,f[MAX]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//单增序列 </span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(f[m]&lt;x) l=m+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l]&gt;=x?l<span class="number">-1</span>:l;  <span class="comment">//找到最后一个小于 x 的元素 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//不增序列 </span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(f[m]&lt;=x) r=m;   <span class="comment">//不增序列，左高右低，所以此时往左取 </span></span><br><span class="line">		<span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l]&lt;x?l<span class="number">-1</span>:l;  <span class="comment">//与递增不同，这里找的是最后一个大于 x 的元素 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	len1=len2=<span class="number">0</span>;cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(~sf(a[cnt++]));</span><br><span class="line">	cnt--;</span><br><span class="line">	f[<span class="number">0</span>]=-INF;</span><br><span class="line">	fi(i,<span class="number">0</span>,cnt)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=bs2(f,<span class="number">0</span>,len1,a[i]);</span><br><span class="line">		f[x+<span class="number">1</span>]=a[i];</span><br><span class="line">		len1=max(len1,x+<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	fi(i,<span class="number">0</span>,cnt)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=bs(f,<span class="number">0</span>,len2,a[i]);</span><br><span class="line">		f[x+<span class="number">1</span>]=a[i];</span><br><span class="line">		len2=max(len2,x+<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,len1+<span class="number">1</span>,len2+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dilworth</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1156 垃圾陷阱 [ DP ]</title>
    <url>/2020/03/08/%E6%B4%9B%E8%B0%B7P1156/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1156" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1156</a></p>
<p><strong>题目描述</strong></p>
<p>卡门――农夫约翰极其珍视的一条<code>Holsteins</code>奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为 D<em>(2≤</em>D≤100) 英尺。</p>
<p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p>
<p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p>
<p>假设卡门预先知道了每个垃圾扔下的时间 t<em>(0&lt;</em>t<em>≤1000)，以及每个垃圾堆放的高度 h</em>(1≤<em>h</em>≤25)和吃进该垃圾能维持生命的时间 f<em>(1≤</em>f*≤30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续10小时的能量，如果卡门10小时内没有进食，卡门就将饿死。</p>
<p><strong>输入格式</strong></p>
<p>第一行为2个整数，D 和 <em>G</em>(1≤ G≤100)，G为被投入井的垃圾的数量。</p>
<p>第二到第 G<em>+1 行每行包括 3个整数：T</em>(0&lt;<em>T</em>&lt;=1000)，表示垃圾被投进井中的时间；F<em>(1≤</em>F<em>≤30)，表示该垃圾能维持卡门生命的时间；和 H</em>(1≤<em>H</em>≤25)，该垃圾能垫高的高度。</p>
<p><strong>输出格式</strong></p>
<p>如果卡门可以爬出陷阱，输出一个整表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 4</span><br><span class="line">5 4 9</span><br><span class="line">9 3 2</span><br><span class="line">12 6 10</span><br><span class="line">13 1 1</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$d[i][j]$ 表示前 i 个垃圾，高度为 j 时的最大存活时间（累计）。转移方程：</p>
<ol>
<li>$f[i][j]=max(f[i][j],f[i-1][j] + F) $  </li>
<li>$f[i][j+H]=f[i-1][j]$</li>
</ol>
<p>因为 2 . 的关系 $f[i][j]$ 可能提前更新，所以要取 $\max()$ 。</p>
<p>如果无法到达顶部，因为有可能无法等到下一个垃圾到来就死了…所以不能直接输出 sum…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d,g,cur,f[MAX][MAX],T,F,H,sum,ans=INF;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> t,f,h;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t&lt;x.t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(d);sf(g);</span><br><span class="line">	fi(i,<span class="number">0</span>,g)&#123;</span><br><span class="line">		sf(a[i].t);sf(a[i].f);sf(a[i].h);</span><br><span class="line">		sum+=a[i].f;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(a,a+g);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">10</span>+a[<span class="number">0</span>].f;</span><br><span class="line">	f[<span class="number">0</span>][a[<span class="number">0</span>].h]=<span class="number">10</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,g)&#123;</span><br><span class="line">		T=a[i].t;F=a[i].f;H=a[i].h;</span><br><span class="line">		fi(j,<span class="number">0</span>,d+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(f[i<span class="number">-1</span>][j] &gt;= T) &#123;</span><br><span class="line">				f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j] + F);<span class="comment">//因为下面那句可能提前更新g[i][j]所以需要 max()</span></span><br><span class="line">				f[i][j+H]=f[i<span class="number">-1</span>][j];</span><br><span class="line">				<span class="keyword">if</span>(j+H&gt;=d) &#123;</span><br><span class="line">					ans=min(ans,f[i][j+H]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans==INF)&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,g)ans=max(ans,f[i][<span class="number">0</span>]);</span><br><span class="line">		pf(ans);</span><br><span class="line">	&#125;<span class="keyword">else</span> pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1282 多米诺骨牌 [ 分组背包(每组有且只能选一个) ]</title>
    <url>/2020/03/04/%E6%B4%9B%E8%B0%B7P1282/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1282" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1282</a></p>
<p><strong>题目描述</strong></p>
<p>多米诺骨牌有上下 2 个方块组成，每个方块中有 1~6 个点。现有排成行的</p>
<p>上方块中点数之和记为 S1，下方块中点数之和记为 S2，它们的差为|S1-S2|。例如在图 8-1 中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转 180°，使得上下两个方块互换位置。 编程用最少的旋转次数使多米诺骨牌上下 2 行点数之差达到最小。</p>
<p><img src="/.io//1.png" alt="img"></p>
<p>对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。</p>
<p><strong>输入格式</strong></p>
<p>输入文件的第一行是一个正整数n(1≤n≤1000)，表示多米诺骨牌数。接下来的n行表示n个多米诺骨牌的点数。每行有两个用空格隔开的正整数，表示多米诺骨牌上下方块中的点数a和b，且1≤a，b≤6。</p>
<p><strong>输出格式</strong></p>
<p>输出文件仅一行，包含一个整数。表示求得的最小旋转次数。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6 1</span><br><span class="line">1 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要差值最小，就是填一个 sum/2 的背包…然后每组有且只能必须选择一个加入，转移方程：$d[i][j]=max(d[i-1][j-c_i]+w_i)$</p>
<p>这样只能求得最小差值，题目要求差值最小的情况下旋转次数也最少，所以用 $c[i][j]$ 记录前 i 个骨牌容量为 j 的情况下最少的旋转次数，代价相等的情况下有</p>
<p>$c[i][j]=min(c[i-1][j-c_0],c[i-1][j-c_1] + 1)$</p>
<p>$c_0,c_1$ 表示当前骨牌上下点数。</p>
<p>然后需要注意的是，下标越界… 容量为 0 初始化为 -INF ,即：$d[i][0]=-INF$（<del>调了好久，菜哭</del>）</p>
<p>sum 可能是奇数，sum/2 取大的！考虑这样的情况，$pre + c_1 = sum/2 , pre + c_1 = sum/2 + 1$ </p>
<p>这样取小的话旋转次数就多 1 。所以取大</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,sum=<span class="number">0</span>,d[MAX*<span class="number">6</span>][MAX*<span class="number">6</span>],c[MAX*<span class="number">6</span>][MAX*<span class="number">6</span>],g[MAX][MAX],a[MAX][<span class="number">2</span>],t1,t2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(a[i][<span class="number">0</span>]);sf(a[i][<span class="number">1</span>]);</span><br><span class="line">		sum+=a[i][<span class="number">0</span>]+a[i][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum&amp;<span class="number">1</span>)</span><br><span class="line">		sum/=<span class="number">2</span>,sum++;<span class="comment">//如果是奇数，取大的 </span></span><br><span class="line">	<span class="keyword">else</span> sum/=<span class="number">2</span>;  </span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		d[i][<span class="number">0</span>]=-INF;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">			t1= i<span class="number">-1</span> &gt;= <span class="number">0</span>?d[i<span class="number">-1</span>][j-a[i][<span class="number">0</span>]] + a[i][<span class="number">0</span>] : a[i][<span class="number">0</span>];</span><br><span class="line">			t2= i<span class="number">-1</span> &gt;= <span class="number">0</span>?d[i<span class="number">-1</span>][j-a[i][<span class="number">1</span>]] + a[i][<span class="number">1</span>] : a[i][<span class="number">1</span>];</span><br><span class="line">			t1= j-a[i][<span class="number">0</span>]&gt;=<span class="number">0</span>?t1:<span class="number">0</span>;</span><br><span class="line">			t2= j-a[i][<span class="number">1</span>]&gt;=<span class="number">0</span>?t2:<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(t1==t2)&#123;</span><br><span class="line">				<span class="keyword">if</span>(c[i<span class="number">-1</span>][j-a[i][<span class="number">0</span>]] &lt;= c[i<span class="number">-1</span>][j-a[i][<span class="number">1</span>]]+<span class="number">1</span>)&#123;</span><br><span class="line">					d[i][j] =t1;</span><br><span class="line">					c[i][j]=c[i<span class="number">-1</span>][j-a[i][<span class="number">0</span>]];</span><br><span class="line">					<span class="comment">//g[i][j]=1; //记录转移路径 </span></span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					d[i][j] =t2;</span><br><span class="line">					c[i][j]=c[i<span class="number">-1</span>][j-a[i][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">					<span class="comment">//g[i][j]=2;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(t1&gt;t2) &#123;</span><br><span class="line">				d[i][j] =t1;</span><br><span class="line">				c[i][j]=c[i<span class="number">-1</span>][j-a[i][<span class="number">0</span>]];</span><br><span class="line">				<span class="comment">//g[i][j]=1;</span></span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				d[i][j] =t2;</span><br><span class="line">				c[i][j]=c[i<span class="number">-1</span>][j-a[i][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">				<span class="comment">//g[i][j]=2;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//打印方案 </span></span><br><span class="line"><span class="comment">//	for(int i=n-1;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">//		printf("%-4d",i);</span></span><br><span class="line"><span class="comment">//		if(g[i][sum]==1)&#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;"1"&lt;&lt;" "&lt;&lt;c[i][sum]&lt;&lt;" "&lt;&lt;a[i][0]&lt;&lt;" "&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//			sum-=a[i][0];</span></span><br><span class="line"><span class="comment">//		&#125;else if(g[i][sum]==2)&#123;</span></span><br><span class="line"><span class="comment">//			cout&lt;&lt;"2"&lt;&lt;" "&lt;&lt;c[i][sum]&lt;&lt;" "&lt;&lt;a[i][1]&lt;&lt;" "&lt;&lt;sum&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//			sum-=a[i][1];</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	pf(c[n<span class="number">-1</span>][sum]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>放一下大佬的解法 <a href="https://www.luogu.com.cn/blog/Euclid/p1282-duo-mi-nuo-gu-pai" target="_blank" rel="noopener">P1282 多米诺骨牌</a> <a href="https://www.luogu.com.cn/problemnew/solution/P1282" target="_blank" rel="noopener">P1282 多米诺骨牌 题解</a></p>
<p>蒟蒻想不到就是了…</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1433吃奶酪</title>
    <url>/2020/02/22/%E6%B4%9B%E8%B0%B7P1433%E5%90%83%E5%A5%B6%E9%85%AA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1433" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1433</a><br>题目描述<br>房间里放着 n 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0) 点处。</p>
<p>输入格式<br>第一行一个正整数 n。</p>
<p>接下来每行 2个实数，表示第i块奶酪的坐标。</p>
<p>两点之间的距离公式为 sqrt ( x^2 + y^2 );<br>输出格式<br>一个数，表示要跑的最少距离，保留 2 位小数。</p>
<p>输入输出样例<br>输入<br>4<br>1 1<br>1 -1<br>-1 1<br>-1 -1<br>输出<br>7.41<br>说明/提示<br>1≤n≤15。</p>
<blockquote>
<p>dp[ i ][ j ] 表示已经走过的城市为 i ( 已经走过的地方 每一个用一位 1/0  表示是否走过，压缩为 i )，当前所在的城市为 j 的最短路程。<br>相应的状态转移方程为dp[ i ][ j ]=min( dp[ i ^ (1&lt;&lt;j) ][ k ] + dis[ k ][ j ]  );     i ^ (1&lt;&lt;j) 的意思是将 j 这个城市从 i 状态中去掉。 dis[ k ][ j ] 是 k 和 j 之间的距离。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">17</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> dis[MAX][MAX],ans,dp[N][MAX],x[MAX],y[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	x[<span class="number">0</span>]=<span class="number">0</span>;y[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;x[i]);<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,i+<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			dis[i][j] = <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">			dis[j][i] = dis[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	fi(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;n)&#123;                 <span class="comment">//用 s 表示已经访问过的城市集合 </span></span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))&#123;     <span class="comment">//如果 i 点 在 s 中 </span></span><br><span class="line">				<span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))) <span class="comment">//s 中只有 i </span></span><br><span class="line">					dp[s][i] = dis[<span class="number">0</span>][i];</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					dp[s][i]=INF;</span><br><span class="line">					fi(j,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)) &amp;&amp; j!=i)&#123;   <span class="comment">//  s^(1&lt;&lt;(i-1)) 从 s 中去掉 j  </span></span><br><span class="line">							dp[s][i]=min(dp[s^(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][j]+dis[j][i],dp[s][i]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans =dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">	fi(i,<span class="number">2</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i] &lt; ans)</span><br><span class="line">			ans = dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 T126840 加密通信 [ gcd ]</title>
    <url>/2020/05/04/%E6%B4%9B%E8%B0%B7T126840/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/T126840?contestId=28335" target="_blank" rel="noopener">加密通信</a></p>
<p><strong>题目描述</strong></p>
<p>首先，八意永琳会写出需要被加密的明文 <em>A</em> ，此段明文由 <em>n</em>−1 个正整数构成。</p>
<p>之后，她会构造出一个由 n 个<strong>质数</strong>构成的密文 B*，满足对 $\forall  i ∈[1, n),B_i×B_{i+1}=A_i$ 。</p>
<p>为了提高信息的利用率，八意永琳规定 <em>B</em> 中出现的所有质数的值必须在 [1,M] 范围内。</p>
<p><strong>输入格式</strong></p>
<p>第一行一个整数 <em>T</em> , 表示需要被加密的明文的组数。</p>
<p>对于每组明文：</p>
<p>第一行两个整数 n,M ，代表明文的长度+1，也即所求密文的长度和可出现质数的最大值。</p>
<p>接下来一行 n - 1 个由空格隔开的正整数，代表明文 A*。</p>
<p><strong>输出格式</strong></p>
<p>对于每组明文，均输出一行：</p>
<ul>
<li>若有解，输出<strong>任意一组</strong>合法密文 B<em>B</em> 即可，密文中的 n* 个质数以空格隔开。</li>
<li>若无解，输出 <code>-1</code>。</li>
</ul>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 233</span><br><span class="line">55 35 77</span><br><span class="line">4 5</span><br><span class="line">55 35 77</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 5 7 11 </span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<h4 id="数据保证："><a href="#数据保证：" class="headerlink" title="数据保证："></a>数据保证：</h4><ul>
<li>若不考虑 b_i 在 [1,M] 范围内的条件，必然有至少一组合法解。</li>
<li>有至少一对 (i,j)，使得 $a_i \ne a_{i+1}$ 。</li>
</ul>
<p><a href="https://www.luogu.com.cn/blog/chenxinyang2006/di-yue-jia-mi-tong-xin-ti-xie" target="_blank" rel="noopener"><strong>题解</strong></a></p>
<blockquote>
<p>题目数据保证，至少有一对  $a_i \ne a_{i+1}$。</p>
<p>因为 $a_i$ 都是两个质数相乘的形式， $a_i \ne a_{i+1}$，所以 $a_i$ 和 $a_{i+1}$ 至多只有一个公因子，所以 $b_i=gcd(a_i,a_{i+1})$ 。</p>
<p>从不相等的这处开始向两边扩展。</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷U106905整理书包 [ 枚举 dp ]</title>
    <url>/2020/04/18/%E6%B4%9B%E8%B0%B7U106905%E6%95%B4%E7%90%86%E4%B9%A6%E5%8C%85/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/U106905?contestId=28733" target="_blank" rel="noopener">U106905整理书包</a></p>
<p><strong>题目背景</strong></p>
<p>随着学校学习压力的增大，CYX 的书包日益沉重，终于有一天，他受不了了，于是，他在整理了书包后，洛谷上又顺便多了一道题……</p>
<p><strong>题目描述</strong></p>
<p>他将他所需要的 <em>n</em> 样学习文具列了出来，第 i<em> 样文具的重量是 w_i，价值是 v_i，减去包的自重，他最大只能承受 m</em> 的重量，求他能装下的最大文具价值。</p>
<p>题出好了，但 CYX 很生气，因为这只是01背包的模板题，太简单了。于是他加了 k<em> 种组合增益效果，每种组合效果用一个三元组(</em>i<em>,</em>j<em>,</em>v<em>) 表示，意思是如果同时选择了第 </em>i<em> 种文具和第 </em>j<em> 种文具，就能额外增加 v</em> 的价值（<strong>注：组合之间不互斥，效果可以累加</strong>），还是求他能装下的最大价值。</p>
<p>难度是上来了，可不料 CYX 更生气了，因为，他不会做了……</p>
<p><strong>输入格式</strong></p>
<p>输入数据共 1+n+k 行。</p>
<p>第一行共三个整数 n<em>，</em>m<em>，</em>k*，分别表示 CYX 的学习文具的数量，除去书包的自重外 CYX 能承受的重量和增益组合的个数。</p>
<p>之后 <em>n</em> 行，每行两个整数 w_i 和 v_i，表示第 i* 种文具的重量和价值。</p>
<p>之后 k<em> 行，每行三个整数 </em>i<em>，</em>j<em>，</em>v<em>，表示如果同时选择了第 </em>i<em> 种文具和第 </em>j<em> 种文具，就能额外增加 </em>v* 的价值。</p>
<p><strong>输出格式</strong></p>
<p>仅一行一个整数，表示 CYX 能装下的最大价值。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 8 0</span><br><span class="line">2 1</span><br><span class="line">6 8</span><br><span class="line">3 5</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 10 1</span><br><span class="line">6 3</span><br><span class="line">3 2</span><br><span class="line">5 3</span><br><span class="line">3 6</span><br><span class="line">2 4</span><br><span class="line">1 4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>
<p><strong>输入 #3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 9 3</span><br><span class="line">4 3</span><br><span class="line">3 2</span><br><span class="line">8 4</span><br><span class="line">1 2</span><br><span class="line">5 4</span><br><span class="line">3 8</span><br><span class="line">2 5 5</span><br><span class="line">5 6 2</span><br><span class="line">2 5 7</span><br></pre></td></tr></table></figure>
<p><strong>输出 #3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>
<p><strong>hint</strong></p>
<p>【样例解释】</p>
<p>样例一解释：选择第 3，4个文具，价值和为 11。</p>
<p>样例二解释：选择第 1，4 个文具，满足第 1 种组合再加 5 的价值，价值和为 14。</p>
<p>样例三解释：选择第 2，4，5 个文具，满足第 1，3 种组合再加 12 的价值，价值和为 20。</p>
<hr>
<p>【数据范围】</p>
<p>对于 10% 的数据，保证 1≤<em>n</em>≤20。</p>
<p>对于另外20% 的数据，保证 k*=0。</p>
<p>对于另外 30% 的数据，保证 1≤<em>n</em>≤100，1≤<em>m</em>≤200。</p>
<p>对于 100% 的数据，保证 1≤<em>n</em>≤10^3，1≤<em>m</em>≤2×10^3，0≤<em>k</em>≤10，1≤<em>w**i</em>≤300，1≤<em>i</em>,<em>j</em>≤<em>n</em>，1≤<em>v</em>≤500，1≤<em>v**i</em>≤500，i<em>\=</em>j*。</p>
<blockquote>
<p><img src="/.io//1.PNG" alt></p>
<p><strong>0 &lt;= k &lt;= 10</strong> <del>应该能想到枚举吧</del></p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1006 传纸条 [ DP ]</title>
    <url>/2020/03/05/%E6%B4%9B%E8%B0%B7p1006/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1006" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1006</a></p>
<p>题意：一个棋盘，左上到右下，两条不相交的权值最大的路径，只首尾重合。</p>
<blockquote>
<p>$d[i][j][x][y]$ 表示第一条路到 $（i，j）$ 第二条到 $（x，y）$</p>
<p>$d[i][j][x][y]=max(d[i-1][j][x-1][y],d[i-1][j][x][y-1],d[i][j-1][x-1][y],d[i][j-1][x][y-1])$</p>
<p>$+a[i][j]+a[x][y]$</p>
<p>枚举 $i,j,x,y$ 的时候$（i，j）$ 默认在 $（x，y）$ 下面，因为不能相交，总有一条在下面。当只有 $y=j+1$</p>
<p>有一点重合，判断一下即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">50</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,a[MAX][MAX],d[MAX][MAX][MAX][MAX],f,e; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(m);sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,m+<span class="number">1</span>)	</span><br><span class="line">		fi(j,<span class="number">1</span>,n+<span class="number">1</span>)	</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">	fi(k,<span class="number">1</span>,n+m)&#123;</span><br><span class="line">		f= k&gt;m ?m:k;</span><br><span class="line">		e= k&lt;m ?<span class="number">1</span>:k-m+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=f,j=e;i&gt;<span class="number">0</span>&amp;&amp;j&lt;=n;i--,j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x=i<span class="number">-1</span>,y=j+<span class="number">1</span>;x&gt;<span class="number">0</span>&amp;&amp;y&lt;=n;x--,y++)&#123;</span><br><span class="line">				d[i][j][x][y]=max(d[i<span class="number">-1</span>][j][x<span class="number">-1</span>][y],max(d[i][j<span class="number">-1</span>][x<span class="number">-1</span>][y],d[i][j<span class="number">-1</span>][x][y<span class="number">-1</span>]));</span><br><span class="line">				<span class="keyword">if</span>(y-j&gt;<span class="number">1</span>) d[i][j][x][y]=max(d[i][j][x][y],d[i<span class="number">-1</span>][j][x][y<span class="number">-1</span>]);<span class="comment">//此时会重叠 </span></span><br><span class="line">				d[i][j][x][y]+=a[i][j]+a[x][y];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(d[m][n<span class="number">-1</span>][m<span class="number">-1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1031</title>
    <url>/2020/02/14/%E6%B4%9B%E8%B0%B7p1031/</url>
    <content><![CDATA[<p>题目描述<br>有N堆纸牌，编号分别为 1,2,…,N。每堆上有若干张，但纸牌总数必为N的倍数。可以在任一堆上取若干张纸牌，然后移动。<br>移牌规则为：在编号为1堆上取的纸牌，只能移到编号为2的堆上；在编号为N的堆上取的纸牌，只能移到编号为N-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。<br>现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。</p>
<p>例如N=4，4堆纸牌数分别为：<br>①9②8③17④6<br>移动3次可达到目的：<br>从 ③ 取4张牌放到 ④ （9,8,13,10）-&gt; 从 ③ 取3张牌放到 ②（9,11,10,10）-&gt; 从 ② 取11张牌放到①（10,10,10,10）。</p>
<p>输入格式<br>两行<br>第一行为：N（N 堆纸牌，1≤N≤100）<br>第二行为：A_1,A_2, … ,A_nN堆纸牌，每堆纸牌初始数，1≤Ai≤10000）<br>输出格式<br>一行：即所有堆均达到相等时的最少移动次数</p>
<blockquote>
<p>寻找这样一个区间 （l ,r ）只需要向一个方向移动卡牌，为此可能需要分割某个点。 这样的区间需要移动 r - l 次，否则就不符合区间的定义。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans,a[MAX],cnt,cf,ce,avg=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(a[i]);</span><br><span class="line">		avg+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	avg/=n;	</span><br><span class="line">	ans =<span class="number">0</span>;cnt=<span class="number">0</span>;cf=<span class="number">0</span>,ce=<span class="number">-1</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		ce+=<span class="number">1</span>;</span><br><span class="line">		cnt +=a[i];</span><br><span class="line">		<span class="keyword">if</span>(cnt &gt;= (ce-cf+<span class="number">1</span>) * avg)&#123;</span><br><span class="line">			ans += (ce-cf);</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">				<span class="keyword">int</span> t = cnt-(ce-cf+<span class="number">1</span>) * avg;</span><br><span class="line">				<span class="keyword">if</span>(t) ans ++;</span><br><span class="line">				a[i+<span class="number">1</span>]+=t;</span><br><span class="line">				cnt=<span class="number">0</span>;cf=i+<span class="number">1</span>;ce=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1032 字串变换</title>
    <url>/2020/02/20/%E6%B4%9B%E8%B0%B7p1032/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1032" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1032</a></p>
<p>题意：字串 A B, 存在一些转换规则使得子串由  A’ -&gt; B’ ，问最少的转换步数。超过 10 步，输出 “NO ANSWER!”<br>输入输出样例<br>输入<br>abcd xyz<br>abc xu<br>ud y<br>y yz<br>输出<br>3</p>
<blockquote>
<p>双向 bfs , 有几个字符串的坑…<br>有相同的多个子串时，每次只转换一个子串，因为有多种选择每个都要试一遍。。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">string</span> a,b,c[<span class="number">10</span>],d[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m,len; <span class="comment">//vis</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; t;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,L[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123; <span class="comment">//num of b in a</span></span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = b.size(),l = a.find(b);</span><br><span class="line">	<span class="keyword">while</span>(l!=<span class="number">-1</span>)&#123;</span><br><span class="line">		L[cnt++]=l;</span><br><span class="line">		l=a.find(b,l+len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> _replace(<span class="keyword">int</span> index,<span class="built_in">string</span> a,<span class="built_in">string</span> b,<span class="built_in">string</span> c)&#123;</span><br><span class="line">	<span class="keyword">int</span> len = b.size();</span><br><span class="line">	a.replace(index,len,c);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	queue&lt;string&gt; s;</span></span><br><span class="line"><span class="comment">//	queue&lt;string&gt; t;</span></span><br><span class="line">	<span class="keyword">if</span>(!a.compare(b)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s.push(a);m[a]=<span class="number">1</span>;</span><br><span class="line">	t.push(b);m[b]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(!s.empty() || !t.empty())&#123;</span><br><span class="line">		<span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp= s.front();</span><br><span class="line">			s.pop();</span><br><span class="line">			fi(i,<span class="number">0</span>,cnt)&#123;</span><br><span class="line">				<span class="keyword">int</span> l= count(tmp,c[i]);</span><br><span class="line">				fi(j,<span class="number">0</span>,l)&#123;</span><br><span class="line">					<span class="built_in">string</span> tmp2= _replace(L[j],tmp,c[i],d[i]);</span><br><span class="line">					<span class="keyword">if</span>(tmp2.compare(tmp)!=<span class="number">0</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(m[tmp2]==<span class="number">0</span>)&#123;</span><br><span class="line">							len[tmp2] = len[tmp] +<span class="number">1</span> ;</span><br><span class="line">							<span class="keyword">if</span>(len[tmp2]&gt;<span class="number">10</span>) <span class="keyword">continue</span>; <span class="comment">// 10 steps</span></span><br><span class="line">							m[tmp2]=<span class="number">1</span>;</span><br><span class="line">							s.push(tmp2);</span><br><span class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span>(m[tmp2]==<span class="number">2</span>)&#123;</span><br><span class="line">							<span class="keyword">return</span> len[tmp2] + len[tmp] +<span class="number">1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!t.empty())&#123;</span><br><span class="line">			<span class="built_in">string</span> tmp= t.front();</span><br><span class="line">			t.pop();</span><br><span class="line">			fi(i,<span class="number">0</span>,cnt)&#123;</span><br><span class="line">				<span class="keyword">int</span> l= count(tmp,d[i]);</span><br><span class="line">				fi(j,<span class="number">0</span>,l)&#123;</span><br><span class="line">					<span class="built_in">string</span> tmp2= _replace(L[j],tmp,d[i],c[i]);</span><br><span class="line">					<span class="keyword">if</span>(tmp2.compare(tmp)!=<span class="number">0</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(m[tmp2]==<span class="number">0</span>)&#123;</span><br><span class="line">							len[tmp2] = len[tmp] +<span class="number">1</span> ;</span><br><span class="line">							<span class="keyword">if</span>(len[tmp2]&gt;<span class="number">10</span>)<span class="keyword">continue</span>;</span><br><span class="line">							m[tmp2]=<span class="number">2</span>; </span><br><span class="line">							t.push(tmp2);</span><br><span class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span>(m[tmp2]==<span class="number">1</span>) &#123;</span><br><span class="line">							<span class="keyword">return</span> len[tmp2] + len[tmp] +<span class="number">1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;c[cnt]&gt;&gt;d[cnt]) cnt++;</span><br><span class="line">	<span class="keyword">int</span> t=bfs();</span><br><span class="line">	<span class="keyword">if</span>(t&gt;<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO ANSWER!"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补一个 c++ 字符串替换函数，本题没用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> _replace(<span class="built_in">string</span> a,<span class="built_in">string</span> b,<span class="built_in">string</span> c)&#123;<span class="comment">//replace all b in a</span></span><br><span class="line">	<span class="keyword">int</span> len1 = b.size(),len2=c.size(),l = a.find(b),L[<span class="number">100</span>],cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l!=<span class="number">-1</span>)&#123;</span><br><span class="line">		L[cnt++]=l;</span><br><span class="line">		l = a.find(b,l+len1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> inc= i&gt;<span class="number">0</span>? i * (len2-len1):<span class="number">0</span>;</span><br><span class="line">		a.replace(L[i] + inc ,len1,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>BFS</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1063 能量项链[ 区间DP ]</title>
    <url>/2020/03/08/%E6%B4%9B%E8%B0%B7p1063/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1063" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1063</a></p>
<blockquote>
<p>枚举区间的时候，tail 数组也要枚举…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAX*<span class="number">2</span>],d[MAX*<span class="number">2</span>][MAX*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(a[i]);</span><br><span class="line">		a[i+n]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	a[n*<span class="number">2</span>]=a[<span class="number">0</span>];</span><br><span class="line">	fi(k,<span class="number">2</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(i,<span class="number">0</span>,n*<span class="number">2</span>-k)&#123; <span class="comment">//!!</span></span><br><span class="line">			<span class="keyword">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">			fi(h,i,j)&#123;</span><br><span class="line">				d[i][j]=max(d[i][j],d[i][h] + d[h+<span class="number">1</span>][j] + a[i]*a[h+<span class="number">1</span>]*a[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> _max=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		_max=max(_max,d[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	pf(_max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1064 金明的预算方案 [ dp dfs ]</title>
    <url>/2020/04/29/%E6%B4%9B%E8%B0%B7p1064/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1064" target="_blank" rel="noopener">P1064 金明的预算方案</a></p>
<p><strong>题目描述</strong></p>
<p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过<em>N</em>元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p>
<p>主件 附件</p>
<p>电脑 打印机，扫描仪</p>
<p>书柜 图书</p>
<p>书桌 台灯，文具</p>
<p>工作椅 无</p>
<p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N<em>元。于是，他把每件物品规定了一个重要度，分为5等：用整数 1-5 表示，第 5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过</em>N<em>元（可以等于N</em>元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p>
<p>设第 j <em>件物品的价格为 v，重要度为 w_[j]，共选中了 k 件物品，编号依次为 j</em>1,<em>j</em>2,…,<em>j**k</em>，则所求的总和为：</p>
<p><em>v</em>[<em>j</em>1]×<em>w</em>[<em>j</em>1]+<em>v</em>[<em>j</em>2]×<em>w</em>[<em>j</em>2]+…+<em>v</em>[<em>j**k</em>]×<em>w</em>[<em>j**k</em>]。</p>
<p>请你帮助金明设计一个满足要求的购物单。</p>
<p><strong>输入格式</strong></p>
<p>第1行，为两个正整数，用一个空格隔开：</p>
<p>N m （其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第 j *行给出了编号为j-1的物品的基本数据，每行有3个非负整数</p>
<p>v p q （其中v<em>v</em>表示该物品的价格（v&lt;10000），p表示该物品的重要度（1-5），q<em>表示该物品是主件还是附件。如果q=0</em>，表示该物品为主件，如果q&gt;0，表示该物品为附件，<em>q</em>是所属主件的编号）</p>
<p><strong>输出格式</strong></p>
<p>一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、 对于一棵子树，给予空间 v , 选择树根的情况下，对子子树们跑 01 背包。</p>
<p>2、先求 dfs 序列，对于一个节点 x , </p>
<ul>
<li>如果选择 x ,那么他的子节点可以选择，d[i] 从 d[i-1] 直接转移而来</li>
<li>如果不选择 x，那么子节点不可选，只能从左兄弟转移而来，跑 dfs 的时候记录左兄弟节点 pre[i].</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; si;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfn(n) printf(<span class="meta-string">"%d\n"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(register int i=(s);i&lt;(t);i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(i,s,t) for(register int i=(s)-1;i&gt;=(t);i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,u[MAX],p[MAX],q,d[MAX],pre[MAX];</span><br><span class="line">vi v[MAX];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,f[<span class="number">100</span>][MAX]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp=cnt;</span><br><span class="line">	fi(i,<span class="number">0</span>,v[x].size())&#123;</span><br><span class="line">		dfs(v[x][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	d[++cnt]=x;</span><br><span class="line">	pre[cnt]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	u[<span class="number">0</span>]=<span class="number">0</span>;p[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(u[i]);sf(p[i]);sf(q);</span><br><span class="line">		<span class="keyword">if</span>(q) v[q].pb(i);</span><br><span class="line">		<span class="keyword">else</span> v[<span class="number">0</span>].pb(i);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,cnt)</span><br><span class="line">		fi(j,<span class="number">0</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=u[d[i]]) f[i][j]=max(f[pre[i]][j],f[i<span class="number">-1</span>][j-u[d[i]]] + u[d[i]] * p[d[i]]);</span><br><span class="line">			<span class="keyword">else</span>  f[i][j] = f[pre[i]][j];</span><br><span class="line">		&#125; </span><br><span class="line">	pf(f[cnt<span class="number">-1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>DFS</tag>
        <tag>noip</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1080</title>
    <url>/2020/02/15/%E6%B4%9B%E8%B0%B7p1080/</url>
    <content><![CDATA[<p>题目描述<br>恰逢 H国国庆，国王邀请n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。<br>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p>
<p>==输入格式==<br>第一行包含一个整数n，表示大臣的人数。<br>第二行包含两个整数 a和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。<br>接下来 n行，每行包含两个整数a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。<br>==输出格式==<br>一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。<br>输入输出样例<br>输入<br>3<br>1 1<br>2 3<br>7 4<br>4 6<br>输出<br>2</p>
<blockquote>
<p>考虑相邻的两个 a（ l1 , r1 ）,b ( l2 , r2 )，假设之前的代价值为 x  ，<br>a 在前时 ，代价 = x <em> l1 / r2;<br>b 在前时 ，代价 = x </em> l2 / r1;<br>所以按( l(a) / r(b) )排序即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span>&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> mod =<span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> DLEN=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">36000</span>],len,flag;<span class="comment">//正负 </span></span><br><span class="line">	BigInt()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		len=<span class="number">1</span>;</span><br><span class="line">		flag =<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	BigInt(<span class="keyword">int</span> v)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">if</span>(v&lt;<span class="number">0</span>) flag=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> flag =<span class="number">1</span>;</span><br><span class="line">		len=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			a[len++]=v%mod;</span><br><span class="line">			v/=mod;</span><br><span class="line">		&#125;<span class="keyword">while</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	BigInt(<span class="keyword">const</span> <span class="keyword">char</span> s[])&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">int</span> inc=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'-'</span>)flag= <span class="number">-1</span>,inc=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> L=<span class="built_in">strlen</span>(s+inc);</span><br><span class="line">		len =L/DLEN;</span><br><span class="line">		<span class="keyword">if</span>(L%DLEN) len++;</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=L<span class="number">-1</span>+inc;i&gt;=inc;i-=DLEN)&#123;</span><br><span class="line">			<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> k=i-DLEN +<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(k&lt;inc) k=inc;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;=i;j++)</span><br><span class="line">				t=t*<span class="number">10</span> + s[j] -<span class="string">'0'</span>;</span><br><span class="line">			a[index++] =t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span>  <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ln;</span><br><span class="line">		<span class="keyword">if</span>(len &gt; b.len || (flag ==<span class="number">1</span> &amp;&amp; b.flag==<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(len==b.len)&#123;</span><br><span class="line">			ln = len<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(a[ln]==b.a[ln]&amp;&amp;ln&gt;=<span class="number">0</span>)ln--;</span><br><span class="line">			<span class="keyword">if</span>(ln&gt;=<span class="number">0</span>&amp;&amp;a[ln]&gt;b.a[ln])</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInt <span class="keyword">operator</span> -(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag!=b.flag)&#123;<span class="comment">//减负数转加法 </span></span><br><span class="line">			BigInt c=*<span class="keyword">this</span>,d=b;</span><br><span class="line">			<span class="keyword">if</span>(c.flag==<span class="number">1</span>&amp;&amp;d.flag==<span class="number">-1</span>)&#123;</span><br><span class="line">				d.flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> c+d;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(c.flag==<span class="number">-1</span>&amp;&amp;d.flag==<span class="number">1</span>)&#123;</span><br><span class="line">				c.flag=<span class="number">1</span>;</span><br><span class="line">				BigInt e= c+d;</span><br><span class="line">				e.flag=<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">return</span> e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i,j,big;</span><br><span class="line">		<span class="keyword">bool</span> flag;</span><br><span class="line">		BigInt t1,t2;</span><br><span class="line">		<span class="keyword">if</span>(*<span class="keyword">this</span>&gt;b)&#123;</span><br><span class="line">			t1=*<span class="keyword">this</span>;</span><br><span class="line">			t2=b;</span><br><span class="line">			flag=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			t1=b;</span><br><span class="line">			t2=*<span class="keyword">this</span>;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		big=t1.len;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;big;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t1.a[i]&lt;t2.a[i])&#123;</span><br><span class="line">				j=i+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(t1.a[j]==<span class="number">0</span>) j++;</span><br><span class="line">				t1.a[j--]--;</span><br><span class="line">				<span class="keyword">while</span>(j&gt;i)</span><br><span class="line">					t1.a[j--]+=mod<span class="number">-1</span>;</span><br><span class="line">				t1.a[i]+=mod-t2.a[i];</span><br><span class="line">			&#125;<span class="keyword">else</span> t1.a[i]-=t2.a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		t1.len=big;</span><br><span class="line">		<span class="keyword">while</span>(t1.a[t1.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;t1.len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			t1.len--;</span><br><span class="line">			big--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) t1.a[big<span class="number">-1</span>]=<span class="number">0</span>-t1.a[big<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">return</span> t1;</span><br><span class="line">	&#125; </span><br><span class="line">	BigInt <span class="keyword">operator</span> +(<span class="keyword">const</span> BigInt &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag!=b.flag)&#123;<span class="comment">//加负数转减法 </span></span><br><span class="line">			BigInt tmp=b,tmp1=*<span class="keyword">this</span>;</span><br><span class="line">			<span class="keyword">if</span>(tmp1&gt;tmp) &#123;</span><br><span class="line">				tmp.flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> tmp1-tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				tmp1.flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> tmp-tmp1;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		BigInt res;</span><br><span class="line">		res.len=max(len,b.len);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=res.len;i++)</span><br><span class="line">			res.a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.len;i++)&#123;</span><br><span class="line">			res.a[i]+=((i&lt;len)?a[i]:<span class="number">0</span>)+((i&lt;b.len)?b.a[i]:<span class="number">0</span>);</span><br><span class="line">			res.a[i+<span class="number">1</span>]+=res.a[i]/mod;</span><br><span class="line">			res.a[i]%=mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res.a[res.len]&gt;<span class="number">0</span>) res.len++;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInt <span class="keyword">operator</span> /(<span class="keyword">const</span> <span class="keyword">int</span> &amp;b) <span class="keyword">const</span>&#123; <span class="comment">//大数除整数 </span></span><br><span class="line">		BigInt res;</span><br><span class="line">		<span class="keyword">int</span> i,down=<span class="number">0</span>,ins=<span class="number">0</span>,tmp=b;</span><br><span class="line">		<span class="keyword">if</span>(b&lt;<span class="number">0</span>)tmp=-b;</span><br><span class="line">		<span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			res.a[i]=(a[i]+down*mod)/tmp;</span><br><span class="line">			down =a[i]+down * mod - res.a[i]*tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		res.len=len;</span><br><span class="line">		res.flag = flag * (b&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(res.a[res.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;res.len&gt;<span class="number">1</span>)res.len--;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInt <span class="keyword">operator</span> *(<span class="keyword">const</span> BigInt &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		BigInt res;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> up=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.len;j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> temp =a[i] * b.a[j] + res.a[i+j] +up;</span><br><span class="line">				res.a[i+j] =temp % mod;</span><br><span class="line">				up=temp/mod;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(up) </span><br><span class="line">				res.a[i+b.len] =up;</span><br><span class="line">		&#125;</span><br><span class="line">		res.len =len + b.len;</span><br><span class="line">		<span class="keyword">while</span>(res.a[res.len <span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; res.len &gt;<span class="number">1</span>) res.len--;</span><br><span class="line">		res.flag = flag * b.flag;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,a[len<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%04d"</span>,a[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line">BigInt sum,ans;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;p[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; x,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.first *<span class="number">1.0</span> /y.second &lt; y.first *<span class="number">1.0</span> /x.second ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	sf(a);sf(b); </span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(p[i].first);sf(p[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p,p+n,cmp);</span><br><span class="line">	sum = BigInt(a);ans =BigInt(<span class="number">0</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sum/p[i].second &gt; ans) ans =sum/p[i].second ;</span><br><span class="line">		sum =sum * BigInt(p[i].first);</span><br><span class="line">	&#125;</span><br><span class="line">	ans.output();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1091 合唱队形 [ LIS ]</title>
    <url>/2020/03/02/%E6%B4%9B%E8%B0%B7p1091/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1091" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1091</a></p>
<p><strong>题意：</strong>一个序列删除几个使其成为山峰状（中间一个最大，然后两边依次减少），求最少删除个数。</p>
<blockquote>
<p>枚举中间值，然后左边求最长上升子序列，右边求最长下降子序列，右边序列的所有值小于左序列的最大值（最后一个）。下降序列的二分，特别注意…被坑死…或者直接逆着求上升序列…用库函数吧…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAX],len1,len2,f[MAX],peak,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//单增序列 </span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(f[m]&lt;x) l=m+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l]&gt;=x?l<span class="number">-1</span>:l;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs2</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//单减序列 </span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(f[m]&lt;=x) r=m; <span class="comment">//' = ' 要放在这里 </span></span><br><span class="line">		<span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l]&lt;=x?l<span class="number">-1</span>:l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	ans = INF;</span><br><span class="line">	fi(ind,<span class="number">0</span>,n)&#123;</span><br><span class="line">		len1=<span class="number">0</span>;	</span><br><span class="line">		f[<span class="number">0</span>]=INF;</span><br><span class="line">		fi(i,<span class="number">0</span>,ind+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> x=bs(f,<span class="number">0</span>,len1,a[i]);</span><br><span class="line">			f[x+<span class="number">1</span>]=a[i];</span><br><span class="line">			len1=max(len1,x+<span class="number">1</span>);</span><br><span class="line">		&#125; </span><br><span class="line">		len2=len1;</span><br><span class="line">		<span class="keyword">if</span>(ind+<span class="number">1</span>&lt;n) &#123;</span><br><span class="line">			peak=f[len1]; <span class="comment">//最大值 </span></span><br><span class="line">			fi(i,ind+<span class="number">1</span>,n)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i] &lt; peak )&#123; <span class="comment">//在小于 peak 的里面找最长递减序列 </span></span><br><span class="line">					<span class="keyword">int</span> x=bs2(f,len1,len2,a[i]);</span><br><span class="line">					f[x+<span class="number">1</span>]=a[i];</span><br><span class="line">					len2=max(len2,x+<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		ans = min(ans, n-len2<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1092 虫食算</title>
    <url>/2020/02/19/%E6%B4%9B%E8%B0%B7p1092/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1092" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1092</a></p>
<p>题目描述<br>所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：</p>
<p> 43#9865#045<br>+ 8468#6633<br> 44445509678<br>其中#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。</p>
<p>现在，我们对问题做两个限制：</p>
<p>首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。</p>
<p>其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N-1。输入数据保证N个字母分别至少出现一次。</p>
<p> BADC<br>+CBDA<br> DCCC<br>上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。</p>
<p>输入格式<br>包含四行。<br>第一行有一个正整数N(N≤26)。</p>
<p>后面的三行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有N位。</p>
<p>输出格式<br>一行，即唯一的那组解。</p>
<p>解是这样表示的：输出N个数字，分别表示A,B,C,…所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。</p>
<p>输入输出样例<br>输入<br>5<br>ABCED<br>BDACE<br>EBBAA<br>输出<br>1 0 3 4 2</p>
<blockquote>
<p>方法一 ：剪枝</p>
<ol>
<li>最高位不能有进位。</li>
<li>第 i 位，满足 ( A[ i ] + B[ i ] ）% n != C[ i ]  和   ( A[ i ] + B[ i ] + 1 ）% n != C[ i ] 。return </li>
<li>按字母从后往前出现的顺序搜索</li>
</ol>
</blockquote>
<blockquote>
<p>越剪越慢的菜鸡 :(</p>
</blockquote>
]]></content>
      <tags>
        <tag>剪枝</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1095 [ dp ]</title>
    <url>/2020/04/10/%E6%B4%9B%E8%B0%B7p1095/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1095" target="_blank" rel="noopener">P1095 守望者的逃离</a></p>
<p><strong>题目描述</strong></p>
<p>恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。守望者的跑步速度为17<em>m</em>/<em>s</em>，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1<em>s</em>内移动60<em>m</em>，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为44点/<em>s</em>，只有处在原地休息状态时才能恢复。</p>
<p>现在已知守望者的魔法初值M<em>，他所在的初始位置与岛的出口之间的距离</em>S<em>，岛沉没的时间T</em>。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意：守望者跑步、闪烁或休息活动均以秒(<em>s</em>)为单位，且每次活动的持续时间为整数秒。距离的单位为米(<em>m</em>)。</p>
<p><strong>输入格式</strong></p>
<p>共一行，包括空格隔开的三个非负整数M<em>,</em>S<em>,</em>T*。</p>
<p><strong>输出格式</strong></p>
<p>共两行。</p>
<p>第11行为字符串“<em>Y<strong>e</strong>s</em>”或“No”（区分大小写），即守望者是否能逃离荒岛。</p>
<p>第22行包含一个整数。第一行为“<em>Y<strong>e</strong>s</em>”（区分大小写）时表示守望者逃离荒岛的最短时间；第一行为“No”（区分大小写）时表示守望者能走的最远距离。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">39 200 4</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br><span class="line">197</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36 255 10</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>日常膜题解（ruobaole）.</p>
<p>根据贪心的原则，魔法足够的话能跳跃是一定要跳跃的。每次跳跃 60 米，算上等待时间，可能并不如走路划算。设 f[i] 表示前 i 秒能走的最远距离, $f[i] = max(f[i],f[i-1]+17)$， $f[i]$ 初始化为跳跃所能达到的最远距离。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m,s,t,f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(m);sf(s);sf(t);</span><br><span class="line">	fi(i,<span class="number">1</span>,t+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(m&gt;=<span class="number">10</span>) &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>] + <span class="number">60</span>; m -= <span class="number">10</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			f[i]=f[i<span class="number">-1</span>] ; m += <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,t+<span class="number">1</span>)&#123;</span><br><span class="line">		f[i]=max(f[i],f[i<span class="number">-1</span>]+<span class="number">17</span>);</span><br><span class="line">		<span class="keyword">if</span>(f[i] &gt;= s)&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"Yes"</span>);pf(i);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">	pf(f[t]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1103 [ dp ]</title>
    <url>/2020/04/26/%E6%B4%9B%E8%B0%B7p1103/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1103" target="_blank" rel="noopener">P1103 书本整理</a></p>
<p><strong>题目描述</strong></p>
<p><code>Frank</code>是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以<code>Frank</code>首先将书按高度顺序排列在书架上。但是<code>Frank</code>发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉k本书，使得书架可以看起来整齐一点。</p>
<p>书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有4本书：</p>
<p>1×2<br>5×3<br>2×4<br>3×1<br>那么<code>Frank</code>将其排列整齐后是：</p>
<p>1×2<br>2×4<br>3×1<br>5×3<br>不整齐度就是2+3+2=7</p>
<p>已知每本书的高度都不一样，请你求出去掉k本书后的最小的不整齐度。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个数字n和 <em>k</em>，代表书有几本，从中去掉几本。(1≤<em>n</em>≤100,1≤<em>k</em>&lt;<em>n</em>)</p>
<p>下面的n行，每行两个数字表示一本书的高度和宽度，均小于200。</p>
<p>保证高度不重复</p>
<p><strong>输出格式</strong></p>
<p>一行一个整数，表示书架的最小不整齐度。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 1</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要求去掉k本书，即是保留 n - k 本书的最小代价。</p>
<p>设 $f[i][j]$ : 前 i 本书保留 j 本的代价。 $f[i][j]=min(f[i][j],f[k][j-1] + abs(a[k] - a[i]))$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,d[MAX],f[MAX][MAX],ans;</span><br><span class="line">pii p[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(k);</span><br><span class="line">	k = n-k;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(p[i].ft);sf(p[i].sd);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p,p+n);</span><br><span class="line">	mem(f,<span class="number">0x3f</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,n) f[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n)</span><br><span class="line">		fi(j,<span class="number">0</span>,i)</span><br><span class="line">			fi(l,<span class="number">2</span>,min(i+<span class="number">1</span>,k)+<span class="number">1</span>)&#123;</span><br><span class="line">				f[i][l]=min(f[i][l],f[j][l<span class="number">-1</span>]+<span class="built_in">abs</span>(p[i].sd-p[j].sd));</span><br><span class="line">			&#125;</span><br><span class="line">	ans = INF;</span><br><span class="line">	fi(i,k<span class="number">-1</span>,n)</span><br><span class="line">		ans = min(ans,f[i][k]);</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1119 灾后重建 [ floyd ]</title>
    <url>/2020/02/27/%E6%B4%9B%E8%B0%B7p1119%E7%81%BE%E5%90%8E%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1119" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1119</a></p>
<p><strong>题目背景</strong></p>
<p><em>B</em>地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p>
<p><strong>题目描述</strong></p>
<p>给出<em>B</em>地区的村庄数<em>N</em>，村庄编号从0到N<em>−1，和所有 M</em> 条公路的长度，公路是双向的。并给出第 <em>i</em> 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第天 $t_i$ 重建完成，并且在当天即可通车。若为 $t_i$则说明地震未对此地区造成损坏，一开始就可以通车。之后有Q<em>个询问 (</em>x<em>,</em>y<em>,</em>t<em>)，对于每个询问你要回答在第  t</em> 天，从村庄 <em>x</em> 到村庄 y 的最短路径长度为多少。如果无法找到从 x <em>村庄到y</em>村庄的路径，经过若干个已重建完成的村庄，或者村庄<em>x</em>或村庄 y*在第 t 天仍未重建完成 ，则需要返回−1。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个正整数 N<em>,</em>M，表示了村庄的数目与公路的数量。</p>
<p>第二行包含 <em>N</em> 个非负整数 <em>t</em>0≤<em>t</em>1≤…≤<em>t**N</em>−1。</p>
<p>接下来M<em>行，每行 3个非负整数i</em>,<em>j</em>,<em>w</em>，w<em>w</em>为不超过 10000 的正整数，表示了有一条连接村庄 <em>i</em> 与村庄 j <em>的道路，长度为 w</em>，保证 i≠j，且对于任意一对村庄只会存在一条道路。</p>
<p>接下来一行也就是M<em>+3行包含一个正整数 </em>Q<em>，表示</em>Q*个询问。</p>
<p>接下来Q<em>行，每行 3个非负整数 </em>x<em>,</em>y<em>,</em>t<em>，询问在第t</em>天，从村庄 x<em> 到村庄 y </em>的最短路径长度为多少，数据保证了 t* 是不下降的。</p>
<p><strong>输出格式</strong></p>
<p>共<em>Q</em>行，对每一个询问 (<em>x</em>,<em>y</em>,<em>t</em>) 输出对应的答案，即在第 t<em>天，从村庄x</em>到村庄 y <em>的最短路径长度为多少。如果在第 t天无法找到从 x</em>村庄到 y 村庄的路径，经过若干个已重建完成的村庄，或者村庄 x 或村庄 y *在第 t 天仍未修复完成，则输出−1。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3 4</span><br><span class="line">0 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">2 1 4</span><br><span class="line">0 3 5</span><br><span class="line">4</span><br><span class="line">2 0 2</span><br><span class="line">0 1 2</span><br><span class="line">0 1 3</span><br><span class="line">0 1 4</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用 floyd 每次加入一个点的特点…</p>
<p>有多次查询，维护一个 last time , 如果本次查询 t &lt;= last 则 T[ v ] &lt;= last 的无需再计算。总的下来只需要跑一边 Floyd</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,T[MAX],t,g[MAX][MAX],x,y,w,q,d[MAX][MAX],last; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T[v]&gt;last &amp;&amp; T[v]&lt;=t)</span><br><span class="line">		fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fi(j,<span class="number">0</span>,n)</span><br><span class="line">			<span class="keyword">if</span>(d[i][v]+d[v][j]&lt;d[i][j])</span><br><span class="line">				d[i][j]=d[i][v]+d[v][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		sf(T[i]);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fi(j,i+<span class="number">1</span>,n)&#123;</span><br><span class="line">			g[i][j]=INF;g[j][i]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		sf(x);sf(y);sf(w);</span><br><span class="line">		g[x][y]=w;</span><br><span class="line">		g[y][x]=w;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fi(j,<span class="number">0</span>,n)&#123;</span><br><span class="line">			d[i][j]=g[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	sf(q);</span><br><span class="line">	last=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		sf(x);sf(y);sf(t);</span><br><span class="line">		fi(i,<span class="number">0</span>,n)</span><br><span class="line">			floyd(i,t);</span><br><span class="line">		last = max(last,t);</span><br><span class="line">		<span class="keyword">if</span>(d[x][y]==INF || T[x]&gt;t ||T[y]&gt;t)pfc(<span class="string">"-1"</span>);</span><br><span class="line">		<span class="keyword">else</span> pf(d[x][y]);</span><br><span class="line">		pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1120</title>
    <url>/2020/02/21/%E6%B4%9B%E8%B0%B7p1120/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1126" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1126</a></p>
<p>题意：2 * 2 的矩阵块从起点到终点，有 向左转，向右转，前进一步，前进2步，前进三步 5种操作。每个操作花费 1 秒。 问最少时间？</p>
<blockquote>
<p>直接搜索会超时的，，<br>要注意的是，每个位置的状态要把方向算进去。但是向前走的时候不用考虑方向，只要可以通过即可。 走多步的时候，要一个一个判断，可能中间有墙。<br>双向 BFS 的时候，相遇的时候两个方向需要特别处理，因为转向也有代价。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX][MAX],vis[MAX][MAX][<span class="number">4</span>],vis2[MAX][MAX],len[MAX][MAX][<span class="number">4</span>],</span><br><span class="line">   sx,sy,fx,fy,f,ans=INF,aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">   awr[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,flag=<span class="number">0</span>; <span class="comment">//flag for end point</span></span><br><span class="line"><span class="keyword">char</span> tf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">int</span> f;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _f)&#123;</span><br><span class="line">		x=_x;y=_y;f=_f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt; n<span class="number">-1</span> || y&lt;<span class="number">1</span> || y&gt; m<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[x][y] ||a[x][y+<span class="number">1</span>] ||a[x+<span class="number">1</span>][y] ||a[x+<span class="number">1</span>][y+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f,<span class="keyword">int</span> steps)</span></span>&#123;<span class="comment">// steps along f</span></span><br><span class="line">	<span class="keyword">int</span> tx,ty;</span><br><span class="line">	fi(i,<span class="number">0</span>,steps)&#123;</span><br><span class="line">		tx= x + aw[f][<span class="number">0</span>];</span><br><span class="line">		ty= y + aw[f][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(!judge(tx,ty)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		x=tx;y=ty;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt;h;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node s,node r)</span></span>&#123;</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	mem(vis2,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(s.x==r.x &amp;&amp; s.y==r.y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[s.x][s.y][s.f]=<span class="number">1</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">		h.push(node(r.x,r.y,i)); </span><br><span class="line">		vis[r.x][r.y][i]=<span class="number">1</span>;</span><br><span class="line">		len[r.x][r.y][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	vis2[s.x][s.y]=<span class="number">1</span>;</span><br><span class="line">	vis2[r.x][r.y]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty() || !h.empty())&#123;</span><br><span class="line">		<span class="keyword">if</span>(!q.empty())&#123;</span><br><span class="line">			node t= q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			fi(i,<span class="number">1</span>,<span class="number">3</span>+<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(judge2(t.x,t.y,t.f,i))&#123;</span><br><span class="line">					<span class="keyword">int</span> tx=t.x+aw[t.f][<span class="number">0</span>],ty=t.y+aw[t.f][<span class="number">1</span>];</span><br><span class="line">					fi(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">						tx = tx + aw[t.f][<span class="number">0</span>];</span><br><span class="line">						ty = ty + aw[t.f][<span class="number">1</span>];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(vis2[tx][ty]==<span class="number">0</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(len[tx][ty][t.f]&gt;len[t.x][t.y][t.f] + <span class="number">1</span> || len[tx][ty][t.f]==<span class="number">0</span> )</span><br><span class="line">							len[tx][ty][t.f]=len[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">						vis[tx][ty][t.f]=<span class="number">1</span>;</span><br><span class="line">						vis2[tx][ty]=<span class="number">1</span>;</span><br><span class="line">						q.push(node(tx,ty,t.f));</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis2[tx][ty]==<span class="number">2</span>)&#123;</span><br><span class="line">						<span class="keyword">int</span> _min=INF;</span><br><span class="line">						fi(j,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">							<span class="keyword">if</span>(len[tx][ty][j])&#123;</span><br><span class="line">								<span class="keyword">int</span> tmp;</span><br><span class="line">								<span class="keyword">if</span>(t.f==awr[j]) tmp=<span class="number">0</span>;</span><br><span class="line">								<span class="keyword">else</span> <span class="keyword">if</span>((t.f - <span class="number">1</span> +<span class="number">4</span>)%<span class="number">4</span> == awr[j] ||(t.f + <span class="number">1</span> +<span class="number">4</span>)%<span class="number">4</span> == awr[j]) tmp=<span class="number">1</span>;</span><br><span class="line">								<span class="keyword">else</span> tmp=<span class="number">2</span>;</span><br><span class="line">								<span class="keyword">if</span>(_min &gt; len[tx][ty][j] + len[t.x][t.y][t.f]+<span class="number">1</span> + tmp)</span><br><span class="line">									_min=len[tx][ty][j] + len[t.x][t.y][t.f] +<span class="number">1</span>+ tmp;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> _min;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!vis[t.x][t.y][(t.f<span class="number">-1</span>+<span class="number">4</span>)%<span class="number">4</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> k=(t.f<span class="number">-1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">				q.push(node(t.x,t.y,k)); <span class="comment">//left</span></span><br><span class="line">				vis[t.x][t.y][k]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(len[t.x][t.y][k]&gt;len[t.x][t.y][t.f] + <span class="number">1</span> || len[t.x][t.y][k]==<span class="number">0</span>)</span><br><span class="line">					len[t.x][t.y][k] = len[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!vis[t.x][t.y][(t.f+<span class="number">1</span>+<span class="number">4</span>)%<span class="number">4</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> k=(t.f+<span class="number">1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">				q.push(node(t.x,t.y,k)); <span class="comment">//right</span></span><br><span class="line">				vis[t.x][t.y][k]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(len[t.x][t.y][k]&gt;len[t.x][t.y][t.f] + <span class="number">1</span> || len[t.x][t.y][k]==<span class="number">0</span> )</span><br><span class="line">					len[t.x][t.y][k] = len[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!h.empty())&#123;</span><br><span class="line">			node t= h.front();</span><br><span class="line">			h.pop();</span><br><span class="line">			fi(i,<span class="number">1</span>,<span class="number">3</span>+<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(judge2(t.x,t.y,t.f,i))&#123;</span><br><span class="line">					<span class="keyword">int</span> tx=t.x+aw[t.f][<span class="number">0</span>],ty=t.y+aw[t.f][<span class="number">1</span>];</span><br><span class="line">					fi(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">						tx = tx + aw[t.f][<span class="number">0</span>];</span><br><span class="line">						ty = ty + aw[t.f][<span class="number">1</span>];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(vis2[tx][ty]==<span class="number">0</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(len[tx][ty][t.f]&gt;len[t.x][t.y][t.f] + <span class="number">1</span> || len[tx][ty][t.f]==<span class="number">0</span> )</span><br><span class="line">							len[tx][ty][t.f]=len[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">						vis[tx][ty][t.f]=<span class="number">1</span>;</span><br><span class="line">						vis2[tx][ty]=<span class="number">2</span>;</span><br><span class="line">						h.push(node(tx,ty,t.f));</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis2[tx][ty]==<span class="number">1</span>)&#123;</span><br><span class="line">						<span class="keyword">int</span> _min=INF;</span><br><span class="line">						fi(j,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">							<span class="keyword">if</span>(len[tx][ty][j])&#123;</span><br><span class="line">								<span class="keyword">int</span> tmp;</span><br><span class="line">								<span class="keyword">if</span>(t.f==awr[j]) tmp=<span class="number">0</span>;</span><br><span class="line">								<span class="keyword">else</span> <span class="keyword">if</span>((t.f - <span class="number">1</span> +<span class="number">4</span>)%<span class="number">4</span> == awr[j] ||(t.f + <span class="number">1</span> +<span class="number">4</span>)%<span class="number">4</span> == awr[j]) tmp=<span class="number">1</span>;</span><br><span class="line">								<span class="keyword">else</span> tmp=<span class="number">2</span>;</span><br><span class="line">								<span class="keyword">if</span>(_min &gt; len[tx][ty][j] + len[t.x][t.y][t.f] + <span class="number">1</span>+tmp)</span><br><span class="line">									_min=len[tx][ty][j] + len[t.x][t.y][t.f]+<span class="number">1</span>+ tmp;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> _min;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!vis[t.x][t.y][(t.f<span class="number">-1</span>+<span class="number">4</span>)%<span class="number">4</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> k=(t.f<span class="number">-1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">				h.push(node(t.x,t.y,k)); <span class="comment">//left</span></span><br><span class="line">				vis[t.x][t.y][k]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(len[t.x][t.y][k]&gt;len[t.x][t.y][t.f] + <span class="number">1</span> || len[t.x][t.y][k]==<span class="number">0</span>)</span><br><span class="line">					len[t.x][t.y][k] = len[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!vis[t.x][t.y][(t.f+<span class="number">1</span>+<span class="number">4</span>)%<span class="number">4</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> k=(t.f+<span class="number">1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">				h.push(node(t.x,t.y,k)); <span class="comment">//right</span></span><br><span class="line">				vis[t.x][t.y][k]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(len[t.x][t.y][k]&gt;len[t.x][t.y][t.f] + <span class="number">1</span> || len[t.x][t.y][k]==<span class="number">0</span> )</span><br><span class="line">					len[t.x][t.y][k] = len[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in","r",stdin);</span></span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">	sf(sx);sf(sy);sf(fx);sf(fy);</span><br><span class="line">	getchar();</span><br><span class="line">	tf = getchar() ;</span><br><span class="line">	<span class="keyword">switch</span>(tf)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'N'</span> : f=<span class="number">0</span> ; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'E'</span> : f=<span class="number">1</span> ; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'S'</span> : f=<span class="number">2</span> ; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'W'</span> : f=<span class="number">3</span> ; <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(bfs(node(sx,sy,f),node(fx,fy,<span class="number">0</span>)) );<span class="comment">//-1 all aw</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1140 相似基因 [ DP ]</title>
    <url>/2020/03/03/%E6%B4%9B%E8%B0%B7p1140/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1140" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1140</a></p>
<p>题意：两个碱基对序列，4种核苷酸，简记作 A,C,G,T ，每种核苷酸各自对应时</p>
<p>作用不同，求最大作用。</p>
<blockquote>
<p>$d[ i ][ j ][ 0/1 ]$ 表示到链 1 的  $i$ 位置，链 2 的  $j$ 位置时，末尾位置对齐或对空时的状态。</p>
<p>状态转移如下代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s1[MAX],s2[MAX];</span><br><span class="line"><span class="keyword">int</span> l1,l2,d[MAX][MAX][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> dn[<span class="number">5</span>]=&#123;<span class="string">'A'</span>,<span class="string">'C'</span>,<span class="string">'G'</span>,<span class="string">'T'</span>,<span class="string">'-'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dc[<span class="number">25</span>]=&#123;<span class="number">5</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">5</span>,</span><br><span class="line">           <span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-1</span>,-INF&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">		fi(j,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">			a[dn[i]][dn[j]]=dc[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(l1);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s1+<span class="number">1</span>);</span><br><span class="line">	sf(l2);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s2+<span class="number">1</span>);</span><br><span class="line">	init();</span><br><span class="line">	fi(i,<span class="number">1</span>,l1+<span class="number">1</span>)&#123;</span><br><span class="line">		d[i][<span class="number">0</span>][<span class="number">0</span>]=d[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] + a[s1[i]][<span class="string">'-'</span>];</span><br><span class="line">		d[i][<span class="number">0</span>][<span class="number">1</span>]=-INF;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,l2+<span class="number">1</span>)&#123;</span><br><span class="line">		d[<span class="number">0</span>][i][<span class="number">0</span>]=d[<span class="number">0</span>][i<span class="number">-1</span>][<span class="number">0</span>] + a[<span class="string">'-'</span>][s2[i]];</span><br><span class="line">		d[<span class="number">0</span>][i][<span class="number">1</span>]=-INF;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,l1+<span class="number">1</span>)&#123;</span><br><span class="line">		fi(j,<span class="number">1</span>,l2+<span class="number">1</span>)&#123;</span><br><span class="line">			d[i][j][<span class="number">0</span>]=max(max(d[i<span class="number">-1</span>][j][<span class="number">0</span>]+a[s1[i]][<span class="string">'-'</span>],d[i][j<span class="number">-1</span>][<span class="number">0</span>]+a[<span class="string">'-'</span>][s2[j]]),</span><br><span class="line">			           max(d[i][j<span class="number">-1</span>][<span class="number">1</span>]+a[<span class="string">'-'</span>][s2[j]],d[i<span class="number">-1</span>][j][<span class="number">1</span>]+a[s1[i]][<span class="string">'-'</span>]));</span><br><span class="line">			d[i][j][<span class="number">1</span>]=max(d[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+a[s1[i]][s2[j]] , d[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+a[s1[i]][s2[j]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(max(d[l1][l2][<span class="number">0</span>],d[l1][l2][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>观察发现，第三个状态是多余的…去掉后如下…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> s1[MAX],s2[MAX];</span><br><span class="line"><span class="keyword">int</span> l1,l2,d[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> dn[<span class="number">5</span>]=&#123;<span class="string">'A'</span>,<span class="string">'C'</span>,<span class="string">'G'</span>,<span class="string">'T'</span>,<span class="string">'-'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dc[<span class="number">25</span>]=&#123;<span class="number">5</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">5</span>,</span><br><span class="line">           <span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-1</span>,-INF&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">		fi(j,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">			a[dn[i]][dn[j]]=dc[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(l1);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s1+<span class="number">1</span>);</span><br><span class="line">	sf(l2);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s2+<span class="number">1</span>);</span><br><span class="line">	init();</span><br><span class="line">	fi(i,<span class="number">1</span>,l1+<span class="number">1</span>)</span><br><span class="line">		d[i][<span class="number">0</span>]=d[i<span class="number">-1</span>][<span class="number">0</span>] + a[s1[i]][<span class="string">'-'</span>];</span><br><span class="line">	fi(i,<span class="number">1</span>,l2+<span class="number">1</span>)</span><br><span class="line">		d[<span class="number">0</span>][i]=d[<span class="number">0</span>][i<span class="number">-1</span>]+ a[<span class="string">'-'</span>][s2[i]];</span><br><span class="line">	fi(i,<span class="number">1</span>,l1+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,l2+<span class="number">1</span>)</span><br><span class="line">			d[i][j]=max(d[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[s1[i]][s2[j]],max(d[i][j<span class="number">-1</span>]+a[<span class="string">'-'</span>][s2[j]],d[i<span class="number">-1</span>][j]+a[s1[i]][<span class="string">'-'</span>]));</span><br><span class="line">	pf(d[l1][l2]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1141</title>
    <url>/2020/02/20/%E6%B4%9B%E8%B0%B7p1141/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1141" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1141</a></p>
<p>题目描述<br>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。</p>
<p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p>
<p>输入格式<br>第1行为两个正整数n,。</p>
<p>下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。</p>
<p>接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第ii行第j列的一个格子，询问从这一格开始能移动到多少格。</p>
<p>输出格式<br>m行，对于每个询问输出相应答案。</p>
<p>输入输出样例<br>输入<br>2 2<br>01<br>10<br>1 1<br>2 2<br>输出<br>4<br>4</p>
<blockquote>
<p> 通过设置 vis 为不同的值，避免重复初试化 vis 。<br> 如果从某点可以到达一个区域，那么从该区域中的任何一点都可以到达相同的区域。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,vis[MAX][MAX],rec[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt;n || y&lt;<span class="number">1</span> || y&gt;n ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y)&#123;</span><br><span class="line">		x=_x;y=_y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span> &lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(node t,<span class="keyword">int</span> tag)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rec[vis[t.x][t.y]]!= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> rec[vis[t.x][t.y]];</span><br><span class="line">	q.push(t);</span><br><span class="line">	vis[t.x][t.y]=tag;</span><br><span class="line">	ans =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node c = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		ans ++;</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx= c.x + aw[i][<span class="number">0</span>],ty= c.y + aw[i][<span class="number">1</span>]; </span><br><span class="line">			<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; vis[tx][ty]&lt;tag &amp;&amp; a[tx][ty]!=a[c.x][c.y])&#123;</span><br><span class="line">				q.push(node(tx,ty));</span><br><span class="line">				vis[tx][ty]=tag;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rec[vis[t.x][t.y]]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		pf(bfs(node(x,y),i));pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1149火柴棒等式</title>
    <url>/2020/02/12/%E6%B4%9B%E8%B0%B7p1149%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<p>题目描述<br>给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示：</p>
<p><img src="/.io//1.PNG" alt></p>
<p>注意：</p>
<ol>
<li>加号与等号各自需要两根火柴棍。</li>
<li>如果A≠B  则 A+B=C 与 B+A=C 视为不同的等式(A,B,C&gt;=0)</li>
<li>n根火柴棍必须全部用上</li>
</ol>
<p>输入格式<br>一个整数n(n&lt;=24)。</p>
<p>输出格式<br>一个整数，能拼成的不同等式的数目。</p>
<p>输入输出样例<br>输入 14  输出 2<br>输入 18  输出 9</p>
<blockquote>
<p>首先暴力枚举 x 根火柴棒可以组成多少个数字。然后 枚举 三个数字的火柴棒个数，判断即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">14000</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">10</span>]=&#123;<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">6</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,ans;</span><br><span class="line"><span class="keyword">int</span> x,y,z,t[<span class="number">21</span>][MAX],cnt[<span class="number">21</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	v[<span class="number">2</span>].push_back(<span class="number">1</span>);</span><br><span class="line">	v[<span class="number">3</span>].push_back(<span class="number">7</span>);</span><br><span class="line">	v[<span class="number">4</span>].push_back(<span class="number">4</span>);</span><br><span class="line">	v[<span class="number">5</span>].push_back(<span class="number">2</span>);v[<span class="number">5</span>].push_back(<span class="number">3</span>);v[<span class="number">5</span>].push_back(<span class="number">5</span>);</span><br><span class="line">	v[<span class="number">6</span>].push_back(<span class="number">0</span>);v[<span class="number">6</span>].push_back(<span class="number">6</span>);v[<span class="number">6</span>].push_back(<span class="number">9</span>);</span><br><span class="line">	v[<span class="number">7</span>].push_back(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> pre,<span class="keyword">int</span> flag,<span class="keyword">int</span> a[],<span class="keyword">int</span> *cnt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>) a[(*cnt)++]=pre;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">6</span>)&#123;</span><br><span class="line">		fi(j,<span class="number">0</span>,v[c[i]].size())&#123;</span><br><span class="line">			<span class="keyword">if</span>(!flag&amp;&amp;v[c[i]][j]==<span class="number">0</span>&amp;&amp;x!=<span class="number">6</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!v[c[i]][j])flag=<span class="number">1</span>;</span><br><span class="line">			dfs(x-c[i],pre * <span class="number">10</span> + v[c[i]][j],flag,a,cnt); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fi(i,<span class="number">1</span>,<span class="number">21</span>)&#123;</span><br><span class="line">		dfs(i,<span class="number">0</span>,<span class="literal">false</span>,t[i],&amp;cnt[i]);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		cnt +=a[x %<span class="number">10</span>];</span><br><span class="line">		x /=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	init();init_i();</span><br><span class="line">	sf(n);</span><br><span class="line">	n-=<span class="number">4</span>;ans =<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		fi(j,<span class="number">1</span>,n+<span class="number">1</span>-i)&#123;</span><br><span class="line">			<span class="keyword">int</span> k= n - i -j;</span><br><span class="line">			fi(l,<span class="number">0</span>,cnt[i])</span><br><span class="line">				fi(m,<span class="number">0</span>,cnt[j])&#123;</span><br><span class="line">					<span class="keyword">int</span> tmp= t[i][l]+t[j][m];</span><br><span class="line">					<span class="keyword">if</span>(cal(tmp)==k) </span><br><span class="line">						ans ++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1162 填涂游戏</title>
    <url>/2020/02/19/%E6%B4%9B%E8%B0%B7p1162/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1162" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1162</a></p>
<p>题意 ： 将一个矩阵中由 1  包围的部分，涂成 2；</p>
<p>0 0 0 0 0 0<br>0 0 1 1 1 1<br>0 1 1 0 0 1<br>1 1 0 0 0 1<br>1 0 0 0 0 1<br>1 1 1 1 1 1</p>
<p>0 0 0 0 0 0<br>0 0 1 1 1 1<br>0 1 1 2 2 1<br>1 1 2 2 2 1<br>1 2 2 2 2 1<br>1 1 1 1 1 1</p>
<blockquote>
<p>基本的想法就是 找到圈内的某个点，然后 BFS，但是题目卡这个…<br>另一个就是涂圈外面的… （  看别人的做法，菜死 :(  ）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAX][MAX],x,y;</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x ,y;</span><br><span class="line">	node (<span class="keyword">int</span> i,<span class="keyword">int</span> j)&#123;</span><br><span class="line">		x=i;y=j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;n+<span class="number">1</span>||y&lt;<span class="number">0</span>||y&gt;n+<span class="number">1</span>||a[x][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(node(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node tmp= q.front();</span><br><span class="line">		a[tmp.x][tmp.y]=<span class="number">2</span>;</span><br><span class="line">		q.pop();</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx= tmp.x +aw[i][<span class="number">0</span>],ty=tmp.y+aw[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(judge2(tx,ty))&#123;</span><br><span class="line">				q.push(node(tx,ty));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	mem(a,<span class="number">0</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	bfs2();</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		fi(j,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j]==<span class="number">2</span>) pfc(<span class="string">"0"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>) pfc(<span class="string">"1"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)  pfc(<span class="string">"2"</span>);</span><br><span class="line">			pfc(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1197 星球大战 [ 并查集 删点?]</title>
    <url>/2020/03/01/%E6%B4%9B%E8%B0%B7p1197%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1197" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1197</a></p>
<p>题意：一组连通块，每删除一个点，给出删除后的连通块数目。</p>
<blockquote>
<p>首先知道：n 个点的森林，有 m 颗树，则有 n-m 条边。据此可以求出最后有多少个连通块。</p>
<p>然后从后往前，加入节点，逆序求出每删除一个点后的连通块数目。</p>
<p>所以…如果并查集删点的话，可以按逆向加点处理…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">4</span>*<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,k,d[MAX]; </span><br><span class="line"><span class="keyword">int</span> f[MAX],vis[MAX],ans[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x]==x?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(find(x)!=find(y)) f[find(y)]=find(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> from,to,next;</span><br><span class="line">&#125;edge[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot,head[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	mem(head,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	edge[tot].from=x;</span><br><span class="line">	edge[tot].to=y;</span><br><span class="line">	edge[tot].next=head[x];</span><br><span class="line">	head[x]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	init();</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n+<span class="number">1</span>) f[i]=i;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		addedge(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	sf(k);</span><br><span class="line">	fi(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">		sf(d[i]);</span><br><span class="line">		vis[d[i]]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> total=n-k;</span><br><span class="line">	fi(i,<span class="number">0</span>,tot*<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[edge[i].from] &amp;&amp; !vis[edge[i].to] &amp;&amp; find(edge[i].from)!=find(edge[i].to))&#123;</span><br><span class="line">			total--;</span><br><span class="line">			merge(edge[i].from,edge[i].to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[k]=total;</span><br><span class="line">	fd(k,<span class="number">0</span>)&#123;</span><br><span class="line">		total++;</span><br><span class="line">		vis[d[i]]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=head[d[i]];j!=<span class="number">-1</span>;j=edge[j].next)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[edge[j].to]&amp;&amp;f[find(d[i])]!=f[find(edge[j].to)]) &#123;</span><br><span class="line">                total--;</span><br><span class="line">                merge(d[i],edge[j].to);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans[i]=total;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,k+<span class="number">1</span>)&#123;</span><br><span class="line">		pf(ans[i]);pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1209 修理牛棚 [ 贪心 ]</title>
    <url>/2020/03/10/%E6%B4%9B%E8%B0%B7p1209/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1209" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1209</a></p>
<p><strong>题目描述</strong></p>
<p>在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。</p>
<p>牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。</p>
<p>自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。</p>
<p>给出 m<em>,</em>s<em>,</em>c，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。</p>
<p><strong>输入格式</strong></p>
<p>一行三个整数 m<em>,</em>s<em>,</em>c<em>，意义如题目描述。<br>接下来 c</em> 行，每行包含一个整数，表示牛所占的牛棚的编号。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个整数，表示所需木板的最小总长度。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 50 18</span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">6 </span><br><span class="line">8 </span><br><span class="line">14</span><br><span class="line">15 </span><br><span class="line">16 </span><br><span class="line">17 </span><br><span class="line">21</span><br><span class="line">25 </span><br><span class="line">26 </span><br><span class="line">27 </span><br><span class="line">30 </span><br><span class="line">31 </span><br><span class="line">40 </span><br><span class="line">41 </span><br><span class="line">42 </span><br><span class="line">43</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>
<blockquote>
<p>按 空隙 从大到小排序，</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m,c,s,a[MAX],d[MAX],ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(m);sf(s);sf(c);</span><br><span class="line">	fi(i,<span class="number">0</span>,c)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	sort(a,a+c);</span><br><span class="line">	ans = a[c<span class="number">-1</span>]-a[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,c)</span><br><span class="line">		<span class="keyword">if</span>(i) d[i]=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">	sort(d+<span class="number">1</span>,d+<span class="number">1</span>+c,cmp);</span><br><span class="line">	fi(i,<span class="number">1</span>,m)</span><br><span class="line">		ans -= d[i];</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1226 [ 快速幂 ]</title>
    <url>/2020/03/18/%E6%B4%9B%E8%B0%B7p1226/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1226" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1226</a></p>
<p><strong>题目描述</strong></p>
<p>给你三个整数 b,p,k，求 b^p mod k。</p>
<p><strong>输入格式</strong></p>
<p>输入只有一行三个整数，分别代表 b,p,k</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个字符串 <code>b^p mod k=s</code>，其中 b, p, k 分别为题目给定的值， s 为运算结果。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 10 9</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2^10 mod 9=7</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll a,b,k;</span><br><span class="line"><span class="function">ll <span class="title">binpow</span><span class="params">(ll a, ll b,ll k)</span> </span>&#123;</span><br><span class="line">  a %= k;</span><br><span class="line">  ll res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % k;</span><br><span class="line">    a = a * a % k;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld^%lld mod %lld=%lld"</span>,a,b,k,binpow(a,b,k)%k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1233木棍加工</title>
    <url>/2020/02/23/%E6%B4%9B%E8%B0%B7p1233%E6%9C%A8%E6%A3%8D%E5%8A%A0%E5%B7%A5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1233" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1233</a></p>
<p>题意，有长宽两种属性的木棍，后续选择的 如果长宽小于等于 前面的，则没有代价。给出一组木棍，求最小代价。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">5000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,n,f;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt;p[MAX],s[MAX]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt; x,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span> &gt; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.first == y.first) <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">	<span class="keyword">return</span> x.first &gt; y.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(p[i].first);sf(p[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p,p+n,cmp);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">		fi(j,<span class="number">0</span>,ans)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[j].first&gt;=p[i].first &amp;&amp; s[j].second&gt;=p[i].second)&#123;</span><br><span class="line">				s[j].first=p[i].first;s[j].second=p[i].second;</span><br><span class="line">				f=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!f)&#123;</span><br><span class="line">			s[ans].first=p[i].first;s[ans].second=p[i].second;</span><br><span class="line">			ans ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1265 公路修建 [ prim ]</title>
    <url>/2020/02/27/%E6%B4%9B%E8%B0%B7p1265%E5%85%AC%E8%B7%AF%E4%BF%AE%E5%BB%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1265" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1265</a></p>
<p>题意：完全图求最小生成树</p>
<blockquote>
<p>题目数据爆 int …</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX= <span class="number">5000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,vis[MAX];</span><br><span class="line"><span class="keyword">double</span> x[MAX],y[MAX],g[MAX][MAX],low[MAX],ans=<span class="number">0.0</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n)low[i]=dis(<span class="number">0</span>,i);</span><br><span class="line">	fi(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		<span class="keyword">double</span> _min=INF;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">		fi(j,<span class="number">0</span>,n)</span><br><span class="line">			<span class="keyword">if</span>(!vis[j]&amp;&amp;_min&gt;low[j])&#123;</span><br><span class="line">				_min=low[j];</span><br><span class="line">				k=j;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(_min==INF)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		ans += _min;</span><br><span class="line">		vis[k]=<span class="number">1</span>;</span><br><span class="line">		fi(j,<span class="number">0</span>,n)&#123;</span><br><span class="line">			<span class="keyword">double</span> tmp=dis(k,j);</span><br><span class="line">			<span class="keyword">if</span>(!vis[j]&amp;&amp;low[j]&gt;tmp)</span><br><span class="line">				low[j]=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	prim();	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf"</span>,ans);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>prim</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1280 尼克的任务[ DP 倒序 ]</title>
    <url>/2020/03/03/%E6%B4%9B%E8%B0%B7p1280/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1280" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1280</a></p>
<p><strong>题目描述</strong></p>
<p>尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。</p>
<p>尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。</p>
<p>写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。</p>
<p><strong>输入格式</strong></p>
<p>输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。</p>
<p>接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。</p>
<p><strong>输出格式</strong></p>
<p>输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 6</span><br><span class="line">1 2</span><br><span class="line">1 6</span><br><span class="line">4 11</span><br><span class="line">8 5</span><br><span class="line">8 1</span><br><span class="line">11 5</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果定义 $f[i]$ 为前 $1-i$ 分钟的最大空余时间，然后发现后面的会影响前面的…</p>
<p>然后用 $f[i]$ 表示 $i-n$ 的最大空余时间。往前，没有任务则 时间+1，否则选一个最优的。</p>
<p>emmm  具体看底下吧…基本照抄题解…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> p[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pii x,pii y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.first&gt;y.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(k);</span><br><span class="line">	fi(i,<span class="number">1</span>,k+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(p[i].first);</span><br><span class="line">		sf(p[i].second);</span><br><span class="line">		sum[p[i].first]++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p+<span class="number">1</span>,p+k+<span class="number">1</span>,cmp);</span><br><span class="line">	fd(n+<span class="number">1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sum[i]==<span class="number">0</span>)</span><br><span class="line">			d[i]=d[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> fi(j,<span class="number">1</span>,sum[i]+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[i+p[num].second]&gt;d[i])</span><br><span class="line">				d[i] = d[i+p[num].second];</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(d[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/.io//菜浸奈.webp" alt="..."></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>DP优化</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1330 [ 二分图 ]</title>
    <url>/2020/02/24/%E6%B4%9B%E8%B0%B7p1330/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1330" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1330</a><br>题目描述<br>曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。</p>
<p>阳光大学的校园是一张由 n 个点构成的无向图，n 个点之间由 m 条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。</p>
<p>询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。<br>输入格式<br>第一行两个正整数，表示节点数和边数。 接下来 m 行，每行两个整数 u,v表示点 u 到点 v 之间有道路相连。<br>输出格式<br>仅一行如果河蟹无法封锁所有道路，则输出 Impossible，否则输出一个整数，表示最少需要多少只河蟹。<br>输入输出样例<br>输入<br>3 3<br>1 2<br>1 3<br>2 3<br>输出<br>Impossible<br>输入<br>3 2<br>1 2<br>2 3<br>输出<br>1</p>
<blockquote>
<p>二分图，</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,x,y,ans,cnt,color[<span class="number">20</span>*MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;edge[<span class="number">20</span>*MAX];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	edge[tot].to=v;</span><br><span class="line">	edge[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	cnt ++;  <span class="comment">//统计此联通块节点数目 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v= edge[i].to; <span class="comment">//枚举每条边 &lt;u,v&gt;</span></span><br><span class="line">		<span class="keyword">if</span>(color[u]==color[v]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//节点 v 已着色，且和节点 u 的颜色冲突</span></span><br><span class="line">		<span class="keyword">if</span>(!color[v])&#123;</span><br><span class="line">			color[v]=<span class="number">3</span>-color[u];     <span class="comment">//给结点 v 着与结点 u 相反的颜色</span></span><br><span class="line">			<span class="keyword">if</span>(color[v]==<span class="number">1</span>) ans ++;</span><br><span class="line">			<span class="keyword">if</span>(!dfs(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		addedge(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	mem(color,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> _min = <span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!color[i])&#123;   <span class="comment">// 非联通图，遍历所有节点</span></span><br><span class="line">			ans =<span class="number">1</span>;color[i]=<span class="number">1</span>;cnt=<span class="number">0</span>;   <span class="comment">// cnt  当前连通块的节点个数</span></span><br><span class="line">			<span class="keyword">if</span>(dfs(i))&#123;</span><br><span class="line">				_min += min(ans,cnt-ans); <span class="comment">//一种着色方案，颜色反转即另一种方案的结果</span></span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				pfc(<span class="string">"Impossible"</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(_min);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>BFS</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1341 [ 欧拉回路 ]</title>
    <url>/2020/02/25/%E6%B4%9B%E8%B0%B7p1341/</url>
    <content><![CDATA[<p><strong>欧拉路</strong></p>
<p><font color="#E91E63">欧拉回路 </font>: 每条边只经过一次，而且回到起点</p>
<p><font color="#E91E63">欧拉路径 </font>: 每条边只经过一次，不要求回到起点</p>
<p><strong>欧拉回路判断</strong>：</p>
<p><font color="#E91E63">无向图 </font>：连通（不考虑度为零的点），每个顶点度数都为偶数。</p>
<p><font color="#E91E63">有向图</font>：基图连通（把边当成无向边，同样不考虑度为0的点），每个顶点出度等于入度。</p>
<p><font color="#E91E63">混合图 </font>（有有向边和无向边）:首先是基图连通(不考虑度为零的点)，然后需要借助网络流判定。<br>首先给原图中的每条无向边随便指定一个方向（成为初始方向），将原图改为有向图 G’ ,然后的任务就是改变 G’ 中某些边的方向（当然是无向边转化来的，原混合图中的有向边不能动）使其满足每个点的入度等于出度。<br>设D[ i ] 为G’ 中（点 i 的出度 -点 i 的入度） ，可以发现，在改变G’ 中的边的方向的过程中，任何点的D 值得奇偶性都不会发生改变（设将边<i , j> 改为 &lt;j,i&gt; ,则i 入度加1出度减1，i 入度减1或出度加1，两者之差减 2 或 加2，奇偶性不变）而最终要求的是每个点的出度等于入度，即每个点的D值都为零，是偶数，故可得：若初始定向得到的G’中任意一个点的D值为奇数，那么原图中一定不存在欧拉环。<br>若初始D值都是偶数，则将G’改装成网络：设立源点S和汇点T,对于每个D[ i ] &gt; 0点 i ，连边 &lt;S,i&gt;,容量为D[ i ] / 2;对于每个D[ j ] &lt; 0 的点 j ，连边 &lt;j,T&gt;,容量为 –D[ j ]/2; G‘ 中的每条边在网络中仍保留，容量为1（表示该边最多只能边方向一次）。求这个网络的最大流，若S引出的所有边均满流，若原混合图是欧拉图，将网络中所有流量为1 的中间边（就是不与S或T关联的边）在G’ 中改变方向，形成的新图G’’ 一定是有向欧拉图；若S引出的边没有满流，则原混合图不是欧拉图。</i></p>
<p><strong>欧拉路径判断</strong>：</p>
<p><font color="#E91E63">无向图 </font>：连通（不考虑度为0 的点），每个顶点度数都是偶数或者仅有两个顶点的度数为偶数。</p>
<p><font color="#E91E63">有向图  </font>：基图连通（把边当成无向边，同样不考虑度0的度），每个顶点出度等于入度或者有且仅有一个点的出度比入度多1，有且仅有一个点的出度比入度小1，其余出度等于入度。</p>
<p><font color="#E91E63">混合图  </font>：如果存在欧拉回路，一点存在欧拉路径。否则如果有且仅有两个点的（出度 – 入度）是奇数，那么给这两个点加边，判断是否存在欧拉回路。</p>
<p><font color="#FFC107">题目:  </font><br><a href="https://www.luogu.com.cn/problem/P1341" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1341</a><br>题目描述<br>给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。</p>
<p>输入格式<br>第一行输入一个正整数n。</p>
<p>以下n行每行两个字母，表示这两个字母需要相邻。</p>
<p>输出格式<br>输出满足要求的字符串。</p>
<p>如果没有满足要求的字符串，请输出“No Solution”。</p>
<p>如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案<br>输入输出样例<br>输入<br>4<br>aZ<br>tZ<br>Xt<br>aX<br>输出<br>XaZtX</p>
<blockquote>
<p>看的题解…<br>把每个字母当作一个节点（…）自己搞字符串很懵逼</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">3000</span>;</span><br><span class="line"><span class="keyword">int</span> n,head,b[<span class="number">150</span>][<span class="number">150</span>],deg[<span class="number">150</span>],f[<span class="number">150</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2</span>],ans[MAX]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x]==x?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//找欧拉回路/路径 </span></span><br><span class="line">	fi(i,<span class="number">64</span>,<span class="number">125</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[x][i])&#123;</span><br><span class="line">			b[x][i]=b[i][x]=<span class="number">0</span>;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[n--]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	fi(i,<span class="number">64</span>,<span class="number">125</span>)f[i]=i;</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a); </span><br><span class="line">		b[a[<span class="number">0</span>]][a[<span class="number">1</span>]] = b[a[<span class="number">1</span>]][a[<span class="number">0</span>]] = <span class="number">1</span> ;</span><br><span class="line">		deg[a[<span class="number">0</span>]]++;</span><br><span class="line">		deg[a[<span class="number">1</span>]]++;</span><br><span class="line">		<span class="keyword">int</span> x=find(a[<span class="number">0</span>]),y=find(a[<span class="number">1</span>]);</span><br><span class="line">		f[x]=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">64</span>,<span class="number">125</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]==i &amp;&amp; deg[i])cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt!=<span class="number">1</span>) &#123; <span class="comment">//非连通图 </span></span><br><span class="line">		pfc(<span class="string">"No Solution"</span>);<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	head=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">64</span>,<span class="number">125</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(deg[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="number">0</span>) head=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt &amp;&amp; cnt!=<span class="number">2</span>) &#123;<span class="comment">//有奇度数点，且不是两个，不存在欧拉路 </span></span><br><span class="line">		pfc(<span class="string">"No Solution"</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="number">0</span>)</span><br><span class="line">		fi(i,<span class="number">64</span>,<span class="number">125</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(deg[i]) &#123;</span><br><span class="line">				head=i;<span class="keyword">break</span>; <span class="comment">//字典序最小，起点 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	dfs(head);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>欧拉路</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1352 [ 树形dp ]</title>
    <url>/2020/03/19/%E6%B4%9B%E8%B0%B7p1352/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1352</a></p>
<p>题意：一棵树，每个节点有代价，父节点和子节点不能同时取到，求最大代价。</p>
<blockquote>
<p>先找树根，然后就是一个模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">6000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,ish[MAX],vis[MAX],l,k,rt,f[MAX][<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX];</span><br><span class="line"><span class="keyword">int</span> tot,h[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	mem(h,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=h[u];</span><br><span class="line">	h[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">			dfs(v);</span><br><span class="line">			f[u][<span class="number">0</span>] += max(f[v][<span class="number">0</span>],f[v][<span class="number">1</span>]);</span><br><span class="line">			f[u][<span class="number">1</span>] += f[v][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	init();</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	mem(ish,<span class="number">0</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		sf(f[i][<span class="number">1</span>]);</span><br><span class="line">	rt=<span class="number">1</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(l);sf(k);</span><br><span class="line">		addedge(k,l);</span><br><span class="line">		<span class="keyword">if</span>(ish[l]) rt=k;</span><br><span class="line">		ish[l]=ish[k]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(rt);</span><br><span class="line">	pf(max(f[rt][<span class="number">0</span>],f[rt][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1359 p3385 [ spfa模板 ]</title>
    <url>/2020/03/17/%E6%B4%9B%E8%B0%B7p1359/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1359" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1359</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3385" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3385</a></p>
<p>题意：就是求最短路和判负环</p>
<blockquote>
<p>存一下spfa 的模板…这样，两个有区别注意一下</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p1359租用游艇</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,t,d[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next,to,c;</span><br><span class="line">&#125;edge[MAX*MAX];</span><br><span class="line"><span class="keyword">int</span> tot,head[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	mem(head,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	edge[tot].to=v;</span><br><span class="line">	edge[tot].c=c;</span><br><span class="line">	edge[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; </span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">bool</span> inq[MAX];<span class="comment">//队列中？</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i] = INF;</span><br><span class="line">	mem(inq,<span class="number">0</span>);</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u= q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		inq[u]=<span class="number">0</span>;<span class="comment">//清除在队列中标记 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">			<span class="keyword">int</span> c=edge[i].c;</span><br><span class="line">			<span class="keyword">if</span>(d[v] &gt; d[u] +c)&#123;</span><br><span class="line">				d[v] = d[u] +c;</span><br><span class="line">				<span class="keyword">if</span>(!inq[v])&#123;<span class="comment">//已经在队列中，不要重复添加 </span></span><br><span class="line">					inq[v]=<span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	init();</span><br><span class="line">	fi(i,<span class="number">1</span>,n)</span><br><span class="line">		fi(j,i+<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			sf(t);</span><br><span class="line">			addedge(i,j,t);</span><br><span class="line">		&#125;</span><br><span class="line">	spfa(<span class="number">1</span>);</span><br><span class="line">	pf(d[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p3385【模板】负环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i] = INF;</span><br><span class="line">	mem(cnt,<span class="number">0</span>);<span class="comment">//进队次数 </span></span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	cnt[s]=<span class="number">1</span>;</span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u= q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">			<span class="keyword">int</span> c=edge[i].c;</span><br><span class="line">			<span class="keyword">if</span>(d[v] &gt; d[u] +c)&#123;</span><br><span class="line">				d[v] = d[u] +c;</span><br><span class="line">				q.push(v);</span><br><span class="line">				<span class="keyword">if</span>(++cnt[v]&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//某点入队n次，必存在负环 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1396 [ 生成树 / spfa / 最小瓶颈生成树 ]</title>
    <url>/2020/03/25/%E6%B4%9B%E8%B0%B7p1396/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1396" target="_blank" rel="noopener">P1396 营救</a></p>
<p><strong>题目背景</strong></p>
<p>“咚咚咚……”“查水表！”原来是查水表来了，现在哪里找这么热心上门的查表员啊！小明感动的热泪盈眶，开起了门……</p>
<p>题目描述</p>
<p>妈妈下班回家，街坊邻居说小明被一群陌生人强行押上了警车！妈妈丰富的经验告诉她小明被带到了 t<em>t</em> 区，而自己在 s<em>s</em> 区。</p>
<p>该市有 m<em>m</em> 条大道连接 n<em>n</em> 个区，一条大道将两个区相连接，每个大道有一个拥挤度。小明的妈妈虽然很着急，但是不愿意拥挤的人潮冲乱了她优雅的步伐。所以请你帮她规划一条从 s<em>s</em> 至 t<em>t</em> 的路线，使得经过道路的拥挤度最大值最小。</p>
<p><strong>输入格式</strong></p>
<p>第一行有四个用空格隔开的 <em>n</em>，<em>m</em>，<em>s</em>，<em>t</em>，其含义见【题目描述】。</p>
<p>接下来 m<em> 行，每行三个整数 u</em>,<em>v</em>,<em>w</em>，表示有一条大道连接区 u<em> 和区 v</em>，且拥挤度为 w。</p>
<p><strong>两个区之间可能存在多条大道</strong>。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个整数，代表最大的拥挤度。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 1 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法一：先求出生成树，转有根树 （root = s）,从 t 往上计算最大边就是答案。</p>
<p>方法二：dij or spfa</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,f[MAX],vis[MAX];</span><br><span class="line"><span class="keyword">int</span> fa[MAX],cost[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,c;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c&lt;x.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x]==<span class="number">-1</span>?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge2</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next,c;</span><br><span class="line">&#125;e2[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	e2[tot].to=v;</span><br><span class="line">	e2[tot].c=c;</span><br><span class="line">	e2[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e2[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v= e2[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v] = u;</span><br><span class="line">		cost[v] = e2[i].c;</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(f,<span class="number">-1</span>);mem(head,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(m);sf(s);sf(t);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(e[i].u);sf(e[i].v);sf(e[i].c);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e,e+m);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		<span class="keyword">int</span> u= find(e[i].u);</span><br><span class="line">		<span class="keyword">int</span> v= find(e[i].v);</span><br><span class="line">		<span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">			f[u]=v;</span><br><span class="line">			addedge(e[i].u,e[i].v,e[i].c);</span><br><span class="line">			addedge(e[i].v,e[i].u,e[i].c);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s);</span><br><span class="line">	<span class="keyword">int</span> x = t,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x!=s)&#123;</span><br><span class="line">		ans = max(ans,cost[x]);</span><br><span class="line">		x=fa[x];</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//spfa 代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,u,v,w,d[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next,c;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].c=c;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">bool</span> inq[MAX];</span><br><span class="line">	mem(inq,<span class="number">0</span>);</span><br><span class="line">	mem(d,<span class="number">0x3f</span>);</span><br><span class="line">	q.push(s);</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u= q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		inq[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(d[v]&gt;max(d[u],e[i].c))&#123; <span class="comment">//松弛</span></span><br><span class="line">				d[v]=max(d[u],e[i].c);</span><br><span class="line">				<span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">					inq[v]=<span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(head,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(m);sf(s);sf(t);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(u);sf(v);sf(w);</span><br><span class="line">		addedge(u,v,w);addedge(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	spfa(s);</span><br><span class="line">	pf(d[t]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 1434  [SHOI2002]滑雪 [ 记忆化搜索 ]</title>
    <url>/2020/02/22/%E6%B4%9B%E8%B0%B7p1434%E6%BB%91%E9%9B%AA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1434" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1434</a></p>
<blockquote>
<p><strong>记忆化搜索</strong>。如果记录（x,y）到终点的代价，记忆化搜索是满足拓扑序的有向图，所以如果状态之间有双向的转移就会出错，本题题意（从高到地）决定了简单的记忆是可行的，否则就要另外处理了。</p>
<p>再比如，一个矩阵，如果规定只能向右向下是满足的，如果可以4个方向转移，就会出错。</p>
<p><strong>最优性剪枝</strong>，记录起点到当前点（x,y）的代价。如果搜索到这点时，代价大于已记录的则剪去即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX][MAX],ans,rec[MAX][MAX],vis[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt;n || y&lt;<span class="number">1</span> ||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rec[x][y]) <span class="keyword">return</span> rec[x][y];</span><br><span class="line">	<span class="keyword">int</span> _max=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tx= x + aw[i][<span class="number">0</span>],ty= y + aw[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; !vis[tx][ty] &amp;&amp; a[tx][ty] &lt; a[x][y]) &#123;</span><br><span class="line">			vis[tx][ty] = <span class="number">1</span>;</span><br><span class="line">			_max= max(_max,dfs(tx,ty)+<span class="number">1</span>);</span><br><span class="line">			vis[tx][ty] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rec[x][y]=_max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">	mem(rec,<span class="number">0</span>);mem(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> _max=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			_max=max(_max,dfs(i,j));</span><br><span class="line">		&#125;</span><br><span class="line">	pf(_max+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>剪枝</tag>
        <tag>DFS</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1435 回文子串 [ lcs 区间dp ]</title>
    <url>/2020/04/23/%E6%B4%9B%E8%B0%B7p1435%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1435" target="_blank" rel="noopener">P1435 回文字串</a></p>
<p><strong>题目描述</strong></p>
<p>回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。</p>
<p>比如 “Ab3bd”插入2个字符后可以变成回文词“dAb3bAd”或“Adb3bdA”，但是插入少于2个的字符无法变成回文词。</p>
<p>注：此问题区分大小写</p>
<p><strong>输入格式</strong></p>
<p>一个字符串(0&lt;strlen&lt;=1000)</p>
<p><strong>输出格式</strong></p>
<p>有且只有一个整数，即最少插入字符数</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ab3bd</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、求正反数组的 lcs</p>
<p>2、$f[i][j]=max(f[i+1][j-1]+2,min(f[i+1][j],f[i][j-1])+1)$ </p>
<p>$f[i][j]$ 表示 i~j 成为回文串需要的最少插入次数。</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1457 [ 枚举 BFS ]</title>
    <url>/2020/03/18/%E6%B4%9B%E8%B0%B7p1457/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1457" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1457</a></p>
<p>题意：一个矩阵统计“连通块”个数和大小（用“墙”分隔），再求去掉哪堵墙后得到最大”连通块“。</p>
<blockquote>
<p>统计“连通块个数“ 和大小 直接跑一边 BFS 即可，然后从左往右，从下往上（先北后东）暴力枚举每堵墙，拆掉后求”连通块“大小，取最大值即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,a[MAX][MAX],c,vis[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">4</span>]=&#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt,_max,_max2,ex,ey,flag,tmp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y)&#123;</span><br><span class="line">		x=_x;y=_y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>,tx,ty;</span><br><span class="line">	<span class="keyword">if</span>(vis[x][y]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	vis[x][y]=<span class="number">1</span>;</span><br><span class="line">	q.push(node(x,y));</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node t=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		ans ++;</span><br><span class="line">		c=a[t.x][t.y] ;</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;=f[i])&#123;</span><br><span class="line">				c-=f[i];</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				tx=t.x+aw[i][<span class="number">0</span>];ty=t.y+aw[i][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(judge(tx,ty)&amp;&amp;!vis[tx][ty])&#123;</span><br><span class="line">					q.push(node(tx,ty));</span><br><span class="line">					vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">haveWall</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c=a[x][y];</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="number">8</span>) c-=<span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> c-=<span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> c-=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(m);sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			tmp=bfs(i,j);</span><br><span class="line">			<span class="keyword">if</span>(tmp) cnt++;</span><br><span class="line">			_max=max(_max,tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">	fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">		fd(n+<span class="number">1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">// 北 2 东 1 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">				mem(vis,<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span>(haveWall(i,j,k))&#123;</span><br><span class="line">					a[i][j]-=f[k];<span class="comment">//拆墙 </span></span><br><span class="line">					tmp=bfs(i,j);</span><br><span class="line">					a[i][j]+=f[k];<span class="comment">//复原 </span></span><br><span class="line">					<span class="keyword">if</span>(tmp &gt; last)&#123;</span><br><span class="line">						last=tmp;</span><br><span class="line">						_max2=tmp;</span><br><span class="line">						ex=i;ey=j;flag=k;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d\n%d\n%d %d "</span>,cnt,_max,_max2,ex,ey);</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">1</span>) pfc(<span class="string">"E"</span>);</span><br><span class="line">	<span class="keyword">else</span> pfc(<span class="string">"N"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1460 [ dfs ]</title>
    <url>/2020/04/03/%E6%B4%9B%E8%B0%B7p1460/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1460" target="_blank" rel="noopener">P1460 [USACO2.1]健康的荷斯坦奶牛 Healthy Holsteins</a></p>
<p><strong>题目描述</strong></p>
<p>农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。</p>
<p>给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。</p>
<p>维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。</p>
<p><strong>输入格式</strong></p>
<p>第一行一个整数 v<em>，表示需要的维他命的种类数。<br>第二行 v</em>v* 个整数，表示牛每天需要的每种维他命的最小量。</p>
<p>第三行一个整数 g<em>，表示可用来喂牛的饲料的种数。<br>下面 g</em> 行，第 <em>n</em> 行表示编号为 n* 饲料包含的各种维他命的量的多少。</p>
<p><strong>输出格式</strong></p>
<p>输出文件只有一行，包括牛必需的最小的饲料种数 p<em>；后面有 p</em> 个数，表示所选择的饲料编号（按从小到大排列）。</p>
<p>如果有多个解，输出饲料序号最小的（即字典序最小）。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">100 200 300 400</span><br><span class="line">3</span><br><span class="line">50  50  50  50</span><br><span class="line">200 300 200 300</span><br><span class="line">900 150 389 399</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意几点：1、因为要字典序输出，对于一个饲料，要先搜索 “选择” 的状态，再搜索 “不选” 的。如果先选择 ”不选 “饲料的状态，dfs 回溯的时候会从后往前搜，不符合字典序。</p>
<p>2、数组需要撤销操作！</p>
<p>3、如果要用 bfs , 不要遗漏 “不选” 的状态。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">25</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> u,t[MAX],g,ans=INF,rec;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX],k[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fi(i,<span class="number">0</span>,u)</span><br><span class="line">		<span class="keyword">if</span>(k[i] &lt; t[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> ind,<span class="keyword">int</span> cnt,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cnt &gt; ans || cnt &gt; g ||ind&gt;g) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(judge() &amp;&amp; ans &gt; cnt) &#123;</span><br><span class="line">		ans = cnt; </span><br><span class="line">		rec = s;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,u) k[i] += a[ind][i];</span><br><span class="line">	dfs(ind+<span class="number">1</span>,cnt+<span class="number">1</span>,s|(<span class="number">1</span>&lt;&lt;ind)); <span class="comment">//选 </span></span><br><span class="line">	fi(i,<span class="number">0</span>,u) k[i] -= a[ind][i];</span><br><span class="line">	dfs(ind+<span class="number">1</span>,cnt,s);<span class="comment">//不选 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(u);</span><br><span class="line">	fi(i,<span class="number">0</span>,u) sf(t[i]); </span><br><span class="line">	sf(g);</span><br><span class="line">	fi(i,<span class="number">0</span>,g)</span><br><span class="line">		fi(j,<span class="number">0</span>,u) sf(a[i][j]);</span><br><span class="line">	dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	pf(ans);pfc(<span class="string">" "</span>);</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,g)</span><br><span class="line">		<span class="keyword">if</span>(rec &amp; (<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">			pf(i+<span class="number">1</span>);pfc(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1522 牛的旅行 [ floyd ]</title>
    <url>/2020/03/10/%E6%B4%9B%E8%B0%B7p1522%E7%89%9B%E7%9A%84%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1522" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1522</a></p>
<p>题目好长图好多…</p>
<blockquote>
<p>用 floyd 求各个点的最短路，然后求每个点到各个点的最短路的最长路。然后，枚举所有不连接的点 $i , j$ </p>
<p>$\min(f[i]+f[j]+d[i][j])$ 即答案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">150</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">double</span> d[MAX][MAX],f[MAX][MAX],md[MAX],l1,l2;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;p[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(p[i].x);</span><br><span class="line">		sf(p[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,i+<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			d[i][j]=d[j][i]=<span class="built_in">sqrt</span>((p[i].x-p[j].x) *(p[i].x-p[j].x)+(p[i].y-p[j].y) *(p[i].y-p[j].y) );</span><br><span class="line">			<span class="keyword">if</span>(a[i][j]==<span class="string">'1'</span>)f[i][j]=f[j][i]=d[i][j];</span><br><span class="line">			<span class="keyword">else</span> f[i][j]=f[j][i]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">	fi(k,<span class="number">1</span>,n+<span class="number">1</span>)  <span class="comment">//floyd</span></span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">			fi(j,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span>(f[i][j]&gt;f[i][k]+f[k][j])</span><br><span class="line">					f[i][j]=f[i][k]+f[k][j];</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;  <span class="comment">//各个点的最长</span></span><br><span class="line">		fi(j,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(f[i][j]!=INF)</span><br><span class="line">				md[i]=max(md[i],f[i][j]);</span><br><span class="line">		l1 =max(l1,md[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	l2=INF;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,i+<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(f[i][j]==INF &amp;&amp; l2&gt;md[i]+md[j]+d[i][j])</span><br><span class="line">				l2=md[i]+md[j]+d[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.6lf"</span>,max(l1,l2));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1541 乌龟棋 [DP]</title>
    <url>/2020/03/08/%E6%B4%9B%E8%B0%B7p1541/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1541" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1541</a></p>
<p>题意：太长。。</p>
<blockquote>
<p>4维DP</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">350</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX],b,ans;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">42</span>][<span class="number">42</span>][<span class="number">42</span>][<span class="number">42</span>],h[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(b);</span><br><span class="line">		h[b]++;</span><br><span class="line">	&#125;</span><br><span class="line">	mem(d,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=h[<span class="number">1</span>];i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=h[<span class="number">2</span>];j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=h[<span class="number">3</span>];k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> t=h[<span class="number">4</span>];t&gt;=<span class="number">0</span>;t--)&#123;</span><br><span class="line">					<span class="keyword">int</span> t1=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">if</span>(i+<span class="number">1</span>&lt;=h[<span class="number">1</span>]) t1= max(d[i+<span class="number">1</span>][j][k][t],t1);</span><br><span class="line">					<span class="keyword">if</span>(j+<span class="number">1</span>&lt;=h[<span class="number">2</span>]) t1= max(t1,d[i][j+<span class="number">1</span>][k][t]);</span><br><span class="line">					<span class="keyword">if</span>(k+<span class="number">1</span>&lt;=h[<span class="number">3</span>]) t1= max(d[i][j][k+<span class="number">1</span>][t],t1);</span><br><span class="line">					<span class="keyword">if</span>(t+<span class="number">1</span>&lt;=h[<span class="number">4</span>]) t1= max(t1,d[i][j][k][t+<span class="number">1</span>]);</span><br><span class="line">					d[i][j][k][t]=t1+a[i+j*<span class="number">2</span>+k*<span class="number">3</span>+t*<span class="number">4</span>];</span><br><span class="line">				&#125;</span><br><span class="line">	pf(d[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/.io//1.png" alt="..."></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1564 [ dp ]</title>
    <url>/2020/04/26/%E6%B4%9B%E8%B0%B7p1564/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1564" target="_blank" rel="noopener">P1564 膜拜</a></p>
<p><strong>题目描述</strong></p>
<p>神牛有很多…当然…每个同学都有自己衷心膜拜的神牛.</p>
<p>某学校有两位神牛，神牛甲和神牛乙。新入学的 n 位同学们早已耳闻他们的神话。</p>
<p>所以，已经衷心地膜拜其中一位了。现在，老师要给他们分机房。但是，要么保证整个机房都是同一位神牛的膜拜者，或者两个神牛的膜拜者人数差不超过 m<em>。另外，现在 n</em> 位同学排成一排，老师只会把连续一段的同学分进一个机房。老师想知道，至少需要多少个机房。</p>
<p><strong>输入格式</strong></p>
<p>输入文件第一行包含两个整数 n 和 m。</p>
<p>第 2 到第 (n + 1) 行，每行一个非 1 即 2 的整数，第 (i + 1) 行的整数表示第 i 个同学崇拜的对象，1 表示甲，2 表示乙。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最小需要机房的数量。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>f[i] : 前 i  个同学最少需要多少个班级；</p>
<p>$f[i] = min(f[i],f[j]+1)  ,(0&lt;j&lt;i)$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">2500</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX],b[MAX],c[MAX],f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) &#123;</span><br><span class="line">		sf(a[i]);</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;</span><br><span class="line">			b[i] = b[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			c[i] = c[i<span class="number">-1</span>];</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			c[i] = c[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">			b[i] = b[i<span class="number">-1</span>];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	mem(f,<span class="number">0x3f</span>);</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">0</span>,i)</span><br><span class="line">			<span class="keyword">if</span>(f[j]+<span class="number">1</span>&lt;f[i]&amp;&amp;(<span class="built_in">abs</span>(b[i]-b[j] + c[i]- c[j])&lt;=m || b[i]==b[j] ||c[i]==c[j]))&#123;</span><br><span class="line">				f[i]=f[j]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	pf(f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1604B 进制星球 [ 高精度 ]</title>
    <url>/2020/02/23/%E6%B4%9B%E8%B0%B7p1604B%E8%BF%9B%E5%88%B6%E6%98%9F%E7%90%83/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1604" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1604</a></p>
<p>题目背景<br>进制题目，而且还是个计算器~~</p>
<p>题目描述<br>话说有一天，小Z乘坐宇宙飞船，飞到一个美丽的星球。因为历史的原因，科技在这个美丽的星球上并不很发达，星球上人们普遍采用B（2&lt;=B&lt;=36）进制计数。星球上的人们用美味的食物招待了小Z，作为回报，小Z希望送一个能够完成B进制加法的计算器给他们。 现在小Z希望你可以帮助他，编写实现B进制加法的程序。</p>
<p>输入格式<br>共3行第1行：一个十进制的整数,表示进制B。第2-3行：每行一个B进制数正整数。数字的每一位属于{0，1，2，3，4，5，6，7，8，9，A，B……}，每个数字长度&lt;=2000位。</p>
<p>输出格式<br>一个B进制数，表示输入的两个数的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">2000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> a[MAX],b[MAX];</span><br><span class="line"><span class="keyword">int</span>  c[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a,b);</span><br><span class="line">	<span class="keyword">int</span> last =<span class="number">0</span>,t, l1=<span class="built_in">strlen</span>(a),l2=<span class="built_in">strlen</span>(b) ;</span><br><span class="line">	<span class="keyword">int</span> i=l1<span class="number">-1</span>,j=l2<span class="number">-1</span>,cnt=<span class="number">0</span>,t1,t2;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;=<span class="string">'A'</span>) t1= a[i]-<span class="string">'A'</span>+<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span> t1=a[i] - <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">if</span>(b[j]&gt;=<span class="string">'A'</span>) t2= b[j]-<span class="string">'A'</span>+<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span> t2=b[j] - <span class="string">'0'</span>;</span><br><span class="line">		t = t1 + t2 + last;</span><br><span class="line">		c[cnt++]=t % n;</span><br><span class="line">		last = t / n;</span><br><span class="line">		i--;j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;=<span class="string">'A'</span>) t1= a[i]-<span class="string">'A'</span>+<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span> t1=a[i] - <span class="string">'0'</span>;</span><br><span class="line">		t = t1 + last;</span><br><span class="line">		c[cnt++] = t % n;</span><br><span class="line">		last = t / n;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[j]&gt;=<span class="string">'A'</span>) t2= b[j]-<span class="string">'A'</span>+<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span> t2= b[j] - <span class="string">'0'</span>;</span><br><span class="line">		t = t2 + last;</span><br><span class="line">		c[cnt++] = t % n;</span><br><span class="line">		last = t / n;</span><br><span class="line">		j--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(last!=<span class="number">0</span>) c[cnt++] = last;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=cnt<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c[j]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="string">'A'</span> + c[j] - <span class="number">10</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> pf(c[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1638 逛画展 [ 二分 尺取法 ]</title>
    <url>/2020/04/02/%E6%B4%9B%E8%B0%B7p1638/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1638" target="_blank" rel="noopener">P1638 逛画展</a></p>
<p><strong>题目描述</strong></p>
<p>博览馆正在展出由世上最佳的 M 位画家所画的图画。</p>
<p>wangjy想到博览馆去看这几位大师的作品。</p>
<p>可是，那里的博览馆有一个很奇怪的规定，就是在购买门票时必须说明两个数字，</p>
<p>a和b，代表他要看展览中的第 a 幅至第 b 幅画(包含 a 和 b)之间的所有图画，而门票</p>
<p>的价钱就是一张图画一元。</p>
<p>为了看到更多名师的画，wangjy希望入场后可以看到所有名师的图画(至少各一张)。</p>
<p>可是他又想节省金钱。。。</p>
<p>作为wangjy的朋友，他请你写一个程序决定他购买门票时的 a 值和 b 值。</p>
<p><strong>输入格式</strong></p>
<p>第一行是 N 和 M，分别代表博览馆内的图画总数及这些图画是由多少位名师的画</p>
<p>所绘画的。</p>
<p>其后的一行包含 N 个数字，它们都介于 1 和 M 之间，代表该位名师的编号。</p>
<p><strong>输出格式</strong></p>
<p>a和 b(a&lt;=b) 由一个空格符所隔开。</p>
<p>保证有解，如果多解，输出a最小的。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12 5</span><br><span class="line">2 5 3 1 3 2 4 1 1 5 4 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题意：求包含 m 个不同元素的最短子区间</p>
<p>1、尺取法 ，对于区间 [ l , r ] , 像右延申 r 直到该区间满足包含  m 个元素，更新答案，左端点 l + 1,继续下一个区间。</p>
<p>2、二分，二分区间长度 d , 然后判断整个区间即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX],d[<span class="number">2000</span>+<span class="number">10</span>],ans,L,R;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,cnt=<span class="number">0</span>,ans=INF;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=n)&#123;</span><br><span class="line">		<span class="keyword">while</span>(r&lt;n &amp;&amp; cnt &lt; m)&#123;</span><br><span class="line">			r ++ ;</span><br><span class="line">			<span class="keyword">if</span>(!d[a[r]]) cnt ++;</span><br><span class="line">			d[a[r]]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt &lt; m) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(ans &gt; r-l+<span class="number">1</span>)&#123;</span><br><span class="line">			ans = r-l+<span class="number">1</span>;</span><br><span class="line">			L=l;R=r;</span><br><span class="line">		&#125;</span><br><span class="line">		ans =  min(ans,r-l+<span class="number">1</span>);</span><br><span class="line">		cnt -= !--d[a[l++]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d"</span>,L,R);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>尺取法</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1717 钓鱼 [ dp 贪心 ]</title>
    <url>/2020/04/02/%E6%B4%9B%E8%B0%B7p1717/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1717" target="_blank" rel="noopener">P1717 钓鱼</a></p>
<p><strong>题目描述</strong></p>
<p>话说发源于小朋友精心设计的游戏被电脑组的童鞋们藐杀之后非常不爽，为了表示安慰和鼓励，VIP999 决定请他吃一次“年年大丰收”，为了表示诚意，他还决定亲自去钓鱼。</p>
<p>但是，因为还要准备 NOIP2013, z老师只给了他 H<em> 个小时的空余时间，假设有 </em>n* 个鱼塘都在一条水平路边，从左边到右编号为 1, 2, 3 .. n 。</p>
<p>VIP是个很讲究效率的孩子，他希望用这些时间钓到尽量多的鱼。他从湖1出发，向右走，有选择的在一些湖边停留一定的时间钓鱼，最后在某一个湖边结束钓鱼。他测出从第 i<em> 个湖到 i+1个湖需要走 5×</em>t_i* 分钟的路，还测出在第 i 个湖边停留，第一个5分钟可以钓到鱼 f_i，以后再每钓5分钟鱼，鱼量减少 d_i。为了简化问题，他假定没有其他人钓鱼，也不会有其他因素影响他钓到期望数量的鱼。请编程求出能钓最多鱼的数量。</p>
<p><strong>输入格式</strong></p>
<p>第一行：湖的数量n。</p>
<p>第二行：时间h（小时）。</p>
<p>第三行：n个数，<em>f</em>1，f<em>2，… fn</em>。</p>
<p>第四行：n个数，d<em>1，d</em>2，….d<em>n</em>。</p>
<p>第五行：n-1个数，t<em>1，t</em>2，….t<em>n</em>−1</p>
<p><strong>输出格式</strong></p>
<p>一个数，所能钓鱼的最大数量。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">10  1</span><br><span class="line">2  5</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>dp:</strong> $d[i][j]$ 表示前 i 个鱼塘花费 j 时间的最大收获。</p>
<p>$dp[i][j] = max(dp[i][j] ,dp[i-1][j - k - t[i-1]] + k<em>f[i] - k</em>(k-1)/2 * d[i]);$</p>
<p><strong>贪心：</strong> 直觉上，应该选择单位时间收获最大的鱼塘 x 先钓鱼，等到单位时间收获变小时，再考虑其他鱼塘。但是鱼塘之间转移有额外的代价。如果鱼塘 x 在最末尾，光是到达 x 就要花费很大的代价，显然这样贪心是不行的。如果，末尾是固定的呢？就是说花费在路程上的时间是固定（走回头路显然不合理），问题就转化为，n 个鱼塘，每个鱼塘每分钟的产鱼量递减，求 h 分钟内的最大产量，这样，只要选每分钟最大产量那个鱼塘。这样又有一个问题：如果每分钟最大产量的那个鱼塘都不同，就要来回转移。这里要用到一个“瞬移”的技巧 ，因为每个鱼塘的产鱼量是连续递减，所以这是可行的。最后呈现的效果就是，在一个鱼塘连续钓 t 分钟，然后再去往下一个鱼塘。</p>
<p>具体就是： 枚举最末尾的鱼塘，减去路程，剩余时间 h’ , 用优先队列维护每分钟最大产量，花光 h’ 为止。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">25</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,h,cnt,ans;</span><br><span class="line"><span class="keyword">int</span> f[MAX],d[MAX],t[MAX],tt[MAX],dp[MAX][<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(h);</span><br><span class="line">	h = h * <span class="number">60</span> /<span class="number">5</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) sf(f[i]);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) sf(d[i]);</span><br><span class="line">	fi(i,<span class="number">1</span>,n) sf(t[i]);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123; <span class="comment">//到达i点至少需要的时间 </span></span><br><span class="line">		tt[i] = tt[i<span class="number">-1</span>] + t[i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,tt[i],h+<span class="number">1</span>)</span><br><span class="line">			fi(k,<span class="number">0</span>,j-t[i<span class="number">-1</span>]+<span class="number">1</span>) <span class="keyword">if</span>( j - k - t[i<span class="number">-1</span>]&gt;=<span class="number">0</span> &amp;&amp; (k<span class="number">-1</span>)*d[i]&lt;f[i])&#123;</span><br><span class="line">				dp[i][j] = max(dp[i][j] ,dp[i<span class="number">-1</span>][j - k - t[i<span class="number">-1</span>]] + k*f[i] - k*(k<span class="number">-1</span>)/<span class="number">2</span> * d[i]);</span><br><span class="line">				ans = max(ans,dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1736 创意吃鱼法[ DP ]</title>
    <url>/2020/03/06/%E6%B4%9B%E8%B0%B7p1736/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1736" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1736</a></p>
<p><strong>题目描述</strong></p>
<p>回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^_*）。她发现，把大池子视为01矩阵（0表示对应位置无鱼，1表示对应位置有鱼）有助于决定吃鱼策略。</p>
<p>在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。</p>
<p>猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？</p>
<p><strong>输入格式</strong></p>
<p>有多组输入数据，每组数据：</p>
<p>第一行有两个整数n和m（n,m≥1），描述池塘规模。接下来的n行，每行有m个数字（非“0”即“1”）。每两个数字之间用空格隔开。</p>
<p>对于30%的数据，有n,m≤100</p>
<p>对于60%的数据，有n,m≤1000</p>
<p>对于100%的数据，有n,m≤2500</p>
<p><strong>输出格式</strong></p>
<p>只有一个整数——猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。</p>
<p><strong>输入输出样式</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">0 1 0 1 0 0</span><br><span class="line">0 0 1 0 1 0</span><br><span class="line">1 1 0 0 0 1</span><br><span class="line">0 1 1 0 1 0</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 0 1 0</span><br><span class="line">0 1 0 0</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 0 1</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>求对角线的最长，对角线有两条！直接把矩阵左右反转再求一次取大的（…）</p>
<p>$d[i][j]$ 表示右下角$(i,j)$ 的正方形且符合题目要求的对角线的最大值。</p>
<p>那么如果其他地方为 0 的话有 $d[i][j]=d[i-1][j-1]+1$ , 观察样例二，可能只取的$d[i-1][j-1]$</p>
<p>的一部分，取得最优解的时候。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//丑陋的代码...</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">2500</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX][MAX],d[MAX][MAX],sum[MAX][MAX],_max=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sum[i][j] - sum[i][j<span class="number">-1</span>] - sum[i-l<span class="number">-1</span>][j] + sum[i-l<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="number">1</span> &amp;&amp; </span><br><span class="line">	  	sum[i][j] - sum[i<span class="number">-1</span>][j] - sum[i][j-l<span class="number">-1</span>] + sum[i<span class="number">-1</span>][j-l<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,(m/<span class="number">2</span>)+<span class="number">1</span>)</span><br><span class="line">		swap(a[i][j],a[i][m-j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=d[i<span class="number">-1</span>][j<span class="number">-1</span>];k&gt;=<span class="number">0</span>;k--) </span><br><span class="line">				<span class="keyword">if</span>(a[i][j] &amp;&amp; k+<span class="number">1</span>&gt;d[i][j]&amp;&amp;cal(i,j,k))&#123;</span><br><span class="line">					d[i][j] = k+<span class="number">1</span>;</span><br><span class="line">					_max=max(_max,d[i][j]);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			sf(a[i][j]);</span><br><span class="line">			sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	f();</span><br><span class="line">	reverse();</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">			sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">	f();</span><br><span class="line">	pf(_max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1880 石子合并 [ DP断环成链 ]</title>
    <url>/2020/03/03/%E6%B4%9B%E8%B0%B7p1880/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1880</a></p>
<p>题意：在一个圆形操场的四周摆放 <em>N</em> 堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。</p>
<p>试设计出一个算法,计算出将 <em>N</em> 堆石子合并成 1 堆的最小得分和最大得分。</p>
<blockquote>
<p>将原有长度复制一份接在后面，然后跑 [1,n] 就可以保证取到所有起点的区间，这样仍可取到环形结构中的所有情况，是等价的。</p>
<p>本题的转移方程： $d[i][j]=max(d[i][k] + d[k+1][j]) + c[i][j]$</p>
<p>max 换成 min 就是最小值的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAX*<span class="number">2</span>],c[MAX*<span class="number">2</span>][MAX*<span class="number">2</span>],sum[MAX*<span class="number">2</span>],d[MAX*<span class="number">2</span>][MAX*<span class="number">2</span>],m[MAX*<span class="number">2</span>][MAX*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		sf(a[i]);</span><br><span class="line">		a[i+n]=a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	sum[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">	fi(i,<span class="number">1</span>,n*<span class="number">2</span>)&#123;</span><br><span class="line">		sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	&#125;	</span><br><span class="line">	fi(i,<span class="number">0</span>,n*<span class="number">2</span>)</span><br><span class="line">		fi(j,i,n*<span class="number">2</span>)&#123;</span><br><span class="line">			c[i][j]=sum[j];</span><br><span class="line">			<span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>)c[i][j]-=sum[i<span class="number">-1</span>];</span><br><span class="line">			m[i][j]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,n*<span class="number">2</span>) m[i][i]=<span class="number">0</span>;</span><br><span class="line">	fi(l,<span class="number">2</span>,n*<span class="number">2</span>)</span><br><span class="line">		fi(i,<span class="number">0</span>,n*<span class="number">2</span>-l+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">			fi(k,i,j)&#123;</span><br><span class="line">				d[i][j]=max(d[i][j],d[i][k]+d[k+<span class="number">1</span>][j]+c[i][j]);</span><br><span class="line">				m[i][j]=min(m[i][j],m[i][k]+m[k+<span class="number">1</span>][j]+c[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	<span class="keyword">int</span> _max=<span class="number">0</span>,_min=INF;	</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		_max=max(_max,d[i][i+n<span class="number">-1</span>]);</span><br><span class="line">		_min=min(_min,m[i][i+n<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,_min,_max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>DP优化</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1921 万圣节农场 [ tarjan 记忆化搜索 ]</title>
    <url>/2020/02/25/%E6%B4%9B%E8%B0%B7p1921%E4%B8%87%E5%9C%A3%E8%8A%82%E5%86%9C%E5%9C%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2921" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2921</a></p>
<p><strong>题目描述</strong></p>
<p>每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在N(1&lt;=N&lt;=100，000)个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。</p>
<p>由于牛棚不太大，FJ 通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ 在第 i 号隔间上张贴了一个“下一个隔间”Next_i(1&lt;=Next_i&lt;=N)，告诉奶牛要去的下一个隔间；这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。</p>
<p>FJ 命令奶牛i应该从i号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。</p>
<p>在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。</p>
<p><strong>输出格式</strong></p>
<p>第1行 整数n。</p>
<p>第2行到n+1行 每行包含一个整数 next_i 。</p>
<p><strong>输出格式</strong></p>
<p>n行，第i行包含一个整数，表示第i只奶牛要前往的隔间数。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>样例解释</strong></p>
<p>有4个隔间</p>
<p>隔间1要求牛到隔间1</p>
<p>隔间2要求牛到隔间3</p>
<p>隔间3要求牛到隔间2</p>
<p>隔间4要求牛到隔间3</p>
<p>牛1，从1号隔间出发，总共访问1个隔间；</p>
<p>牛2，从2号隔间出发，然后到三号隔间，然后到2号隔间，终止，总共访问2个隔间；</p>
<p>牛3，从3号隔间出发，然后到2号隔间，然后到3号隔间，终止，总共访问2个隔间；</p>
<p>牛4，从4号隔间出发，然后到3号隔间，然后到2号隔间，然后到3号隔间，终止，总共访问3个隔间。</p>
<p>翻译提供者：吃葡萄吐糖</p>
<blockquote>
<p>先用 tarjan 找出所有的强连通分量 ( 包括强连通分量的大小 )，然后再跑一边 dfs</p>
<p>搜索的时候，如果 u, v 不在一个圈内，则 ans [ u ] = 1  + ans[ v ]，需 dfs( v ) 先求出 ans[ v ] ; 否则两者相等，直接返回结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100000</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> n,next[MAX],ans[MAX];</span><br><span class="line"><span class="keyword">int</span> Low[MAX],DFN[MAX],Stack[MAX],Belong[MAX];</span><br><span class="line"><span class="keyword">int</span> ind,top;</span><br><span class="line"><span class="keyword">int</span> scc;   <span class="comment">//强连通分量的个数 </span></span><br><span class="line"><span class="keyword">bool</span> InStack[MAX];</span><br><span class="line"><span class="keyword">int</span> num[MAX];<span class="comment">//各个强连通分量包含点的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	Low[u]=DFN[u]=++ind;</span><br><span class="line">	Stack[top++]=u;</span><br><span class="line">	InStack[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> v=next[u];</span><br><span class="line">	<span class="keyword">if</span>(!DFN[v])&#123;</span><br><span class="line">		tarjan(v,u);</span><br><span class="line">		Low[u]=min(Low[u],Low[v]);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(InStack[v])&#123;</span><br><span class="line">		Low[u]=min(Low[u],DFN[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Low[u]==DFN[u])&#123;</span><br><span class="line">		scc++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			v=Stack[--top];</span><br><span class="line">			InStack[v]=<span class="literal">false</span>;</span><br><span class="line">			Belong[v]=scc; <span class="comment">//标记属于哪一个强连通分量</span></span><br><span class="line">			num[scc]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ans[u]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> v=next[u];</span><br><span class="line">	<span class="keyword">if</span>(Belong[v]!=Belong[u])&#123;</span><br><span class="line">		dfs(v);</span><br><span class="line">		ans[u] = <span class="number">1</span> + ans[v];</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		ans[u] = num[Belong[u]];</span><br><span class="line">		dfs(v) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(DFN,<span class="number">0</span>,<span class="keyword">sizeof</span>(DFN));</span><br><span class="line">	<span class="built_in">memset</span>(InStack,<span class="literal">false</span>,<span class="keyword">sizeof</span>(InStack));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	ind=scc=top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!DFN[i])</span><br><span class="line">			tarjan(i,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(next[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	solve(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(!ans[i])</span><br><span class="line">			dfs(i);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		pf(ans[i]);</span><br><span class="line">		pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1938 P2648 [ 最长路spfa 超级源点 ]</title>
    <url>/2020/03/17/%E6%B4%9B%E8%B0%B7p1938/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1938" target="_blank" rel="noopener">P1938</a> <a href="https://www.luogu.com.cn/problem/P2648" target="_blank" rel="noopener">P2648 赚钱</a></p>
<p>题意：<del>求最长路</del></p>
<blockquote>
<p><strong>p1938</strong></p>
<p>先点权转边权，然后求最长路，可能有负环，所以用spfa</p>
<p>求最长路的两个方法：</p>
<p>1、 将 d 数组初始化为 0，每次更新最大值</p>
<p>2、 所有边权取反后，求最短路（dij不能处理负边环，所以spfa）</p>
<p><strong>p2648</strong></p>
<p>在上一题的基础上，建出一个超级源点，然后给他和每个点连一条权值是 0 的边。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**p2648**</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">300</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> d,p,c,f,ai,bi,ji,ki,ti,ans,low[MAX],cnt[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next,c;</span><br><span class="line">&#125;edge[MAX*MAX];</span><br><span class="line"><span class="keyword">int</span> tot,head[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	mem(head,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	edge[tot].to=v;</span><br><span class="line">	edge[tot].c=c;</span><br><span class="line">	edge[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">bool</span> inq[MAX];<span class="comment">//这里是要初始化的！</span></span><br><span class="line">	mem(inq,<span class="number">0</span>);</span><br><span class="line">	low[s]=d; <span class="comment">//起点是有值的，本题 </span></span><br><span class="line">	q.push(s);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(++cnt[u]&gt;c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		inq[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">			<span class="keyword">int</span> c=edge[i].c;</span><br><span class="line">			<span class="keyword">if</span>(low[v] &lt; low[u] +c)&#123;</span><br><span class="line">				low[v] = low[u] +c;</span><br><span class="line">				<span class="keyword">if</span>(!inq[v])&#123; </span><br><span class="line">					inq[v]=<span class="number">1</span>;</span><br><span class="line">					q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(d);sf(p);sf(c);sf(f);</span><br><span class="line">	init();</span><br><span class="line">	fi(i,<span class="number">0</span>,p)&#123;</span><br><span class="line">		sf(ai);sf(bi);</span><br><span class="line">		addedge(ai,bi,d);</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,f)&#123;</span><br><span class="line">		sf(ji);sf(ki);sf(ti);</span><br><span class="line">		addedge(ji,ki,d-ti);</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,c+<span class="number">1</span>)</span><br><span class="line">		addedge(<span class="number">0</span>,i,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!spfa(<span class="number">0</span>))&#123;</span><br><span class="line">		pfc(<span class="string">"orz"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,c+<span class="number">1</span>)&#123;</span><br><span class="line">		ans = max(ans,low[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>spfa</tag>
        <tag>最长路</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p1941飞扬的小鸟[ dp ]</title>
    <url>/2020/05/06/%E6%B4%9B%E8%B0%B7p1941/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1941" target="_blank" rel="noopener">P1941 飞扬的小鸟</a></p>
<p><strong>题目描述</strong></p>
<p><code>Flappy Bird</code> 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。</p>
<p>为了简化问题，我们对游戏规则进行了简化和改编:</p>
<p>游戏界面是一个长为 <em>n</em>，高为 m 的二维平面，其中有 <em>k</em> 个管道（忽略管道的宽度）。</p>
<p>小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。</p>
<p>小鸟每个单位时间沿横坐标方向右移的距离为 1，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 <em>x</em>，<strong>每个单位时间可以点击多次</strong>，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 y<em>。小鸟位于横坐标方向不同位置时，上升的高度 x 和下降的高度 </em>y* 可能互不相同。</p>
<p>小鸟高度等于 0 或者小鸟碰到管道时，游戏失败。<strong>小鸟高度为 m 时，无法再上升</strong>。</p>
<p>现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。</p>
<p><strong>输入格式</strong></p>
<p>第 1 行有 3 个整数 n, m, k，分别表示游戏界面的长度，高度和水管的数量，每两个整数之间用一个空格隔开；</p>
<p>接下来的 n 行，每行 2 个用一个空格隔开的整数 <em>x</em> 和 y<em>，依次表示在横坐标位置 0∼</em>n<em>−1 上玩家点击屏幕后，小鸟在下一位置上升的高度 x</em>，以及在这个位置上玩家不点击屏幕时，小鸟在下一位置下降的高度 y。</p>
<p>接下来 k 行，每行 3 个整数 p,l,h，每两个整数之间用一个空格隔开。每行表示一个管道，其中 p 表示管道的横坐标，l 表示此管道缝隙的下边沿高度，h 表示管道缝隙上边沿的高度（输入数据保证 <em>p</em> 各不相同，但不保证按照大小顺序给出）。</p>
<p><strong>输出格式</strong></p>
<p>共两行。</p>
<p>第一行，包含一个整数，如果可以成功完成游戏，则输出 1，否则输出 0。</p>
<p>第二行，包含一个整数，如果第一行为 1，则输出成功完成游戏需要最少点击屏幕数，否则，输出小鸟最多可以通过多少个管道缝隙。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10 6 </span><br><span class="line">3 9  </span><br><span class="line">9 9  </span><br><span class="line">1 2  </span><br><span class="line">1 3  </span><br><span class="line">1 2  </span><br><span class="line">1 1  </span><br><span class="line">2 1  </span><br><span class="line">2 1  </span><br><span class="line">1 6  </span><br><span class="line">2 2  </span><br><span class="line">1 2 7 </span><br><span class="line">5 1 5 </span><br><span class="line">6 3 5 </span><br><span class="line">7 5 8 </span><br><span class="line">8 7 9 </span><br><span class="line">9 1 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10 4 </span><br><span class="line">1 2  </span><br><span class="line">3 1  </span><br><span class="line">2 2  </span><br><span class="line">1 8  </span><br><span class="line">1 8  </span><br><span class="line">3 2  </span><br><span class="line">2 1  </span><br><span class="line">2 1  </span><br><span class="line">2 2  </span><br><span class="line">1 2  </span><br><span class="line">1 0 2 </span><br><span class="line">6 7 9 </span><br><span class="line">9 1 4 </span><br><span class="line">3 8 10</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><img src="/.io//1348.png" alt="img"></p>
<blockquote>
<p>$f[i][j]$ 表示前 i 个管子高度为 j 的最小代价，</p>
<p>注意题目，向上，每个单位时间内可以点击多次，所以有 </p>
<p>$f[i][j]=min(f[i-1][j-k*x[i]]+k,f[i][j])$</p>
<p>复杂度 $ O(nm^2)$ ,T le..</p>
<p>因为是从下往上计算的，那么有$f[i][j]=f[i][j-x[i]]+1$</p>
<p>所以更新一下：$f[i][j]=min(f[i-1][j-x[i]],f[i][j-x[i]])+1$</p>
<p>观察上面的式子，$f[i-1][j-x[i]],f[i][j-x[i]]$ 第二维是相同的，如果 $l[i]+1&lt;= j &lt;= h[i]-1$</p>
<p>那么 $f[i-1][j-2*x[i]]$ 可能错过，所以 $x[i]&lt;= j &lt;= h[i]-1$</p>
<p>然后又有问题了…因为上年多计算了，导致一些存在管道的地方也有值了，本来是不能到达的…</p>
<p>所以，计算完后，把不属于  $[l[i]+1,h[i]-1]$ 赋值 INF 。</p>
<p>下面的同理。</p>
<p>向下的话，显然只能有一种情况 $f[i][j]=min(f[i][j],f[i-1][j+y[i]]),(j+y[i]&lt;=m)$</p>
<p>当 j == m 的时候，因为到顶就不上升，有</p>
<p>$f[i][m]=min(f[i][m],min(f[i-1][m-j],f[i][m-j])+1)$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,p,l[MAX],h[MAX],x[MAX],y[MAX],ans,cnt,flag;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">10100</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);sf(k);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) &#123;</span><br><span class="line">		sf(x[i]);sf(y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	mem(l,<span class="number">0</span>);mem(h,<span class="number">0x3f</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,k)&#123;</span><br><span class="line">		sf(p);sf(l[p]);sf(h[p]);</span><br><span class="line">	&#125;</span><br><span class="line">	mem(f,<span class="number">0x3f</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">2</span>*m) f[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		fi(j,<span class="number">1</span>,min(m+<span class="number">1</span>,h[i])) &#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=x[i]) f[i][j] = min(f[i][j-x[i]],f[i<span class="number">-1</span>][j-x[i]]) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(f[i][j]&lt;INF) flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(j,m-x[i],m+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(m&lt;=h[i])f[i][m]=min(f[i][m],min(f[i][j],f[i<span class="number">-1</span>][j])+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(f[i][m]&lt;INF) flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(j,l[i]+<span class="number">1</span>,min(m+<span class="number">1</span>,h[i])) &#123;</span><br><span class="line">			<span class="keyword">if</span>(j+y[i] &lt;= m) f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][j+y[i]]);</span><br><span class="line">			<span class="keyword">if</span>(f[i][j]&lt;INF) flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(j,<span class="number">0</span>,l[i]+<span class="number">1</span>) f[i][j]=INF;</span><br><span class="line">		fi(j,h[i],m+<span class="number">1</span>) f[i][j]=INF;</span><br><span class="line">		<span class="keyword">if</span>(h[i]&lt;=m)&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag) cnt ++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">		ans =INF;</span><br><span class="line">		fi(j,<span class="number">0</span>,m+<span class="number">1</span>) ans = min(ans,f[n][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"1\n%d"</span>,ans); </span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0\n%d"</span>,cnt); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1944 最长括号匹配 [ dp ]</title>
    <url>/2020/03/26/%E6%B4%9B%E8%B0%B7p1944%E6%9C%80%E9%95%BF%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1944" target="_blank" rel="noopener">p1944最长括号匹配</a></p>
<p><strong>题目描述</strong></p>
<p>对一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配子串。具体来说，满足如下条件的字符串成为括号匹配的字符串：</p>
<p>1.(),[]是括号匹配的字符串。</p>
<p>2.若A是括号匹配的串，则(A),[A]是括号匹配的字符串。</p>
<p>3.若A,B是括号匹配的字符串，则AB也是括号匹配的字符串。</p>
<p>例如：(),[],([]),()()都是括号匹配的字符串，而][,[(])则不是。</p>
<p>字符串A的子串是指由A中连续若干个字符组成的字符串。</p>
<p>例如，A,B,C,ABC,CAB,ABCABCd都是ABCABC的子串。空串是任何字符串的子串。</p>
<p><strong>输入格式</strong></p>
<p>输入一行，为一个仅由()[]组成的非空字符串。</p>
<p><strong>输出格式</strong></p>
<p>输出也仅有一行，为最长的括号匹配子串。若有相同长度的子串，输出位置靠前的子串。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">([(][()]]()</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[()]</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">())[]</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>d[ i ] 表示以 i 结尾的最长括号序列。</p>
<p>‘ [ ’ , ‘ ( ‘  结尾的长度肯定为 0 </p>
<p>$d[ i ]  = d[ i-1 ] + 2 + d[ i - d[ i-1] -2]$ ;</p>
<p>（<del>题解区大佬的</del>）：用栈记录匹配的下标 （ vis[ i ] = 1） , 然后计算最长的  ‘1’ 串。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> a[MAX];</span><br><span class="line"><span class="keyword">int</span> l,d[MAX],f,e,_max;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">	l=<span class="built_in">strlen</span>(a);</span><br><span class="line">	fi(i,<span class="number">1</span>,l)&#123;</span><br><span class="line">		<span class="keyword">if</span>((a[i]==<span class="string">')'</span> &amp;&amp; a[i-d[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'('</span>) || (a[i]==<span class="string">']'</span> &amp;&amp; a[i-d[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">'['</span>))</span><br><span class="line">			d[i]=d[i<span class="number">-1</span>]+ <span class="number">2</span> + d[i-d[i<span class="number">-1</span>]<span class="number">-2</span>];</span><br><span class="line">		<span class="keyword">if</span>(_max&lt;d[i])&#123;</span><br><span class="line">			_max=d[i];</span><br><span class="line">			e=i+<span class="number">1</span>;f=i-d[i]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,f,e)</span><br><span class="line">		<span class="built_in">putchar</span>(a[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p1967 [ 最大生成树+LCA ]</title>
    <url>/2020/03/24/%E6%B4%9B%E8%B0%B7p1967/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1967" target="_blank" rel="noopener">P1967 货车运输</a></p>
<p><strong>题目描述</strong></p>
<p>A 国有 <em>n</em> 座城市，编号从 1 到 n<em>，城市之间有 m</em> 条双向道路。每一条道路对车辆都有重量限制，简称限重。</p>
<p>现在有 q* 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p>
<p><strong>输入格式</strong></p>
<p>第一行有两个用一个空格隔开的整数 n<em>,</em>m<em>，表示 A 国有 </em>n<em> 座城市和 m</em> 条道路。</p>
<p>接下来 m<em> 行每行三个整数 x</em>,<em>y</em>,<em>z</em>，每两个整数之间用一个空格隔开，表示从 x<em> 号城市到 y</em> 号城市有一条限重为 z 的道路。<br>注意：x<em>\​=</em>y，两座城市之间可能有多条道路 。</p>
<p>接下来一行有一个整数 q<em>，表示有 q</em> 辆货车需要运货。</p>
<p>接下来 q<em> 行，每行两个整数 x</em>,<em>y</em>，之间用一个空格隔开，表示一辆货车需要从 x<em> 城市运输货物到 y</em> 城市，保证 x<em>\=</em>y</p>
<p><strong>输出格式</strong></p>
<p>共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。<br>如果货车不能到达目的地，输出 −1。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">3 1 1</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先求最大生成树，将生成树转为有根树，然后跑 lca (<del>buhui</del>)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[MAX],x,y,z,q,vis[MAX];</span><br><span class="line"><span class="keyword">int</span> fa[MAX],l[MAX],cost[MAX]; <span class="comment">//fa 父节点; l 节点深度; cost 节点到父节点的距离;</span></span><br><span class="line"><span class="keyword">int</span> anc[MAX][<span class="number">25</span>],val[MAX][<span class="number">25</span>];<span class="comment">//anc(i,j) 节点i的第2^j级祖先编号</span></span><br><span class="line">							  <span class="comment">//maxcost(i,j)  节点i的第2^j级组先之间路径上的最大权值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x]==<span class="number">-1</span>?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,c;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> edge&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c&gt;x.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;e[MAX*<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge2</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next,c;</span><br><span class="line">&#125;ve[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	ve[tot].to=v;</span><br><span class="line">	ve[tot].c=c;</span><br><span class="line">	ve[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123; <span class="comment">//转有根树 </span></span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=ve[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v=ve[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		l[v]=l[u]+<span class="number">1</span>;</span><br><span class="line">		fa[v]=u;</span><br><span class="line">		cost[v]=ve[i].c;</span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mem(val,<span class="number">0x3f</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		anc[i][<span class="number">0</span>]=fa[i];val[i][<span class="number">0</span>]=cost[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)anc[i][j]=<span class="number">-1</span>;<span class="comment">//表示祖先不存在 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) <span class="comment">//预处理出节点 i 的第2^j级祖先编号 和 路径上的最大权值</span></span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(anc[i][j<span class="number">-1</span>]!=<span class="number">-1</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> a=anc[i][j<span class="number">-1</span>];</span><br><span class="line">				anc[i][j]=anc[a][j<span class="number">-1</span>];</span><br><span class="line">				val[i][j]=min(val[i][j<span class="number">-1</span>],val[a][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(find(p)!=find(q))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l[p]&lt;l[q]) swap(p,q);</span><br><span class="line">	<span class="keyword">int</span> ans=INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)     <span class="comment">//使 p,q 深度相等</span></span><br><span class="line">		<span class="keyword">if</span>(l[anc[p][i]]&gt;=l[q])&#123;</span><br><span class="line">			ans = min(ans,val[p][i]);</span><br><span class="line">			p=anc[p][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==q) <span class="keyword">return</span> ans;<span class="comment">//lca 为 p</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)     <span class="comment">//向上找共同的祖先节点</span></span><br><span class="line">		<span class="keyword">if</span>(anc[p][i]!=<span class="number">-1</span>&amp;&amp;anc[p][i]!=anc[q][i])&#123;</span><br><span class="line">			ans = min(ans,min(val[p][i],val[q][i]));</span><br><span class="line">			p=anc[p][i];q=anc[q][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> min(ans,min(val[p][<span class="number">0</span>],val[q][<span class="number">0</span>]));<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(f,<span class="number">-1</span>);mem(fa,<span class="number">-1</span>);mem(head,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(e[i].x);sf(e[i].y);sf(e[i].c);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e,e+m);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		<span class="keyword">int</span> u = find(e[i].x);</span><br><span class="line">		<span class="keyword">int</span> v = find(e[i].y);</span><br><span class="line">		<span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">			f[u]=v;</span><br><span class="line">			addedge(e[i].x,e[i].y,e[i].c);</span><br><span class="line">			addedge(e[i].y,e[i].x,e[i].c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fa[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123; <span class="comment">// 处理森林</span></span><br><span class="line">			l[i]=<span class="number">1</span>;</span><br><span class="line">			dfs(i);</span><br><span class="line">			pre();</span><br><span class="line">		&#125;</span><br><span class="line">	sf(q);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		pf(lca(x,y));pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷p2123皇后游戏</title>
    <url>/2020/02/23/%E6%B4%9B%E8%B0%B7p2123%E7%9A%87%E5%90%8E%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2123" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2123</a></p>
<p>题目背景<br>还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游戏的另一个问题。</p>
<p>题目描述<br>皇后有 n 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 n 位大臣颁发奖金，其中第 i 位大臣所获得的奖金数目为第i－1 位大臣所获得奖金数目与前 i 位大臣左手上的数的和的较大值再加上第 i 位大臣右手上的数。</p>
<p>形式化地讲：我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi，则第 i 位大臣获得的奖金数目为 ci可以表达为：</p>
<p><img src="/.io//2.PNG" alt="..."></p>
<p>当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。</p>
<p>注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。</p>
<blockquote>
<p>看的这个…弱鸡完全做不出来…  <a href="https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">浅谈邻项交换排序的应用以及需要注意的问题</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">20000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> t,n;</span><br><span class="line">ll ans,sum;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;  x,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(min(x.first,y.second) == min(x.second,y.first)) <span class="keyword">return</span> x.first &lt; y.first;</span><br><span class="line">	<span class="keyword">return</span> min(x.first,y.second) &lt; min(x.second,y.first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			sf(p[i].first);sf(p[i].second);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(p,p+n,cmp);</span><br><span class="line">		ans = sum =<span class="number">0</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			sum += p[i].first;</span><br><span class="line">			ans = max(ans,sum) + p[i].second;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p2199 最后的迷宫 [ bfs ]</title>
    <url>/2020/04/17/%E6%B4%9B%E8%B0%B7p2199/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2199" target="_blank" rel="noopener">P2199 最后的迷宫</a></p>
<p><strong>题目描述</strong></p>
<p>哈利的视力非常好，他能从迷宫的一端沿直线看到迷宫的另一端（但他只能看八个方向——东北，东，东南，南，西南……），而且跑得非常快，跑一步（向上、下、左、右移动一格）只需要1s。但迷宫是不透光的，而且，要烧掉迷宫的墙也不容易，所以哈利决定绕到一个能够看到奖杯的地方。现在，哈利希望你能帮他确定最短需要多长时间才能拿到奖杯。</p>
<p><strong>输入格式</strong></p>
<p>第一行为2个数N，M表示迷宫的规模（N为高，M为宽）</p>
<p>接下来是N*M的迷宫，O表示空地，X表示墙。</p>
<p>最后是多对数据，分别是奖杯坐标及哈利的坐标（显然不可能在墙上），每对占一行，0为结束标志。</p>
<p><strong>输出格式</strong></p>
<p>根据每对数据，计算哈利拿到奖杯的最短时间，每对一行。如果魔法部有意难为选手，用墙将奖杯包围了起来，输出”Poor Harry”。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">OXXO</span><br><span class="line">XXOO</span><br><span class="line">XOOO</span><br><span class="line">3 2 2 4</span><br><span class="line">3 3 1 1</span><br><span class="line">0 0 0 0</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Poor Harry</span><br></pre></td></tr></table></figure>
<p><strong>hint</strong></p>
<p>对于30%的数据,有N*M&lt;=100</p>
<p>对于60%的数据,有N*M&lt;=1600</p>
<p>对于100%的数据,有N*m&lt;=16384</p>
<blockquote>
<p>二维数组总大小 &lt;=  16384 , 所以用一维数组表示二维数组。</p>
<p>剩下就是跑 bfs ,每次先初始化出可以看到终点的所有点并标记，然后搜索的时候判断即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">16384</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fx,fy,ex,ey;</span><br><span class="line"><span class="keyword">char</span> a[MAX];</span><br><span class="line"><span class="keyword">int</span> vis[MAX];</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> aw2[<span class="number">8</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,c;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _c)&#123;</span><br><span class="line">		x=_x;y=_y;c=_c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">isok</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">8</span>)&#123;</span><br><span class="line">		x=ex,y=ey;</span><br><span class="line">		<span class="keyword">while</span>(judge(x,y) &amp;&amp; a[(x<span class="number">-1</span>)*m+y<span class="number">-1</span>]!=<span class="string">'X'</span>)&#123;</span><br><span class="line">			vis[(x<span class="number">-1</span>)*m+y<span class="number">-1</span>] = d;</span><br><span class="line">			x += aw2[i][<span class="number">0</span>];</span><br><span class="line">			y += aw2[i][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">	q.push(node(fx,fy,<span class="number">0</span>));</span><br><span class="line">	vis[(fx<span class="number">-1</span>)*m+fy<span class="number">-1</span>]=d;</span><br><span class="line">	isok(d+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(vis[(fx<span class="number">-1</span>)*m+fy<span class="number">-1</span>] == d+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx = t.x + aw[i][<span class="number">0</span>],ty = t.y + aw[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; vis[(tx<span class="number">-1</span>)*m+ty<span class="number">-1</span>]!=d &amp;&amp; a[(tx<span class="number">-1</span>)*m+ty<span class="number">-1</span>]!=<span class="string">'X'</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(vis[(tx<span class="number">-1</span>)*m+ty<span class="number">-1</span>] == d+<span class="number">1</span>) <span class="keyword">return</span> t.c + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					vis[(tx<span class="number">-1</span>)*m+ty<span class="number">-1</span>]= d ;</span><br><span class="line">					q.push(node(tx,ty,t.c + <span class="number">1</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">0</span>,n) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+(i*m)); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(~sf(ex)&amp;&amp;ex)&#123;</span><br><span class="line">		sf(ey);sf(fx);sf(fy);</span><br><span class="line">		<span class="keyword">int</span> ans = bfs(cnt);</span><br><span class="line">		cnt +=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(ans == <span class="number">-1</span>) pfc(<span class="string">"Poor Harry\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> pfn(ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p2658  汽车拉力比赛[ 二分 ]</title>
    <url>/2020/04/09/%E6%B4%9B%E8%B0%B7p2658/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2658" target="_blank" rel="noopener">P2658 汽车拉力比赛</a></p>
<p><strong>题目描述</strong></p>
<p>博艾市将要举行一场汽车拉力比赛。</p>
<p>赛场凹凸不平，所以被描述为M*N的网格来表示海拔高度(1≤ M,N ≤500)，每个单元格的海拔范围在0到10^9之间。</p>
<p>其中一些单元格被定义为路标。组织者希望给整个路线指定一个难度系数D，这样参赛选手从任一路标到达别的路标所经过的路径上相邻单元格的海拔高度差不会大于D。也就是说这个难度系数D指的是保证所有路标相互可达的最小值。任一单元格和其东西南北四个方向上的单元格都是相邻的。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数M和N。第2行到第M+1行，每行N个整数描述海拔高度。第2+M行到第1+2M</p>
<p>行，每行N个整数，每个数非0即1，1表示该单元格是一个路标。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，即赛道的难度系数D。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5 </span><br><span class="line">20 21 18 99 5  </span><br><span class="line">19 22 20 16 26</span><br><span class="line">18 17 40 60 80</span><br><span class="line">1 0 0 0 1</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0 0 1</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bfs + 二分…  题目要求路标之间互达的最小落差，只要判断一个路标到其他路标是否可达即可，其它路标可以绕道过去，所以只需判断一次！如何判断到达所有路标呢？如上，路标标记为 1 ，其它为 0 ，所以 $cnt += g[ i][j]$ 并判断就行。（<del>题解区大佬思路</del>）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAX][MAX],g[MAX][MAX],ans=<span class="number">0</span>,sum,fx,fy;</span><br><span class="line"><span class="keyword">int</span> vis[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y)&#123;</span><br><span class="line">		x=_x;y=_y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt;n ||y&lt;<span class="number">1</span> ||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt;q;</span><br><span class="line">	q.push(node(fx,fy));</span><br><span class="line">	vis[fx][fy]=d;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node t= q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		cnt += g[t.x][t.y];</span><br><span class="line">		<span class="keyword">if</span>(cnt == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> tx = t.x +aw[i][<span class="number">0</span>],ty = t.y +aw[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; vis[tx][ty] != d &amp;&amp; <span class="built_in">abs</span>(a[t.x][t.y] - a[tx][ty]) &lt;= d)&#123;</span><br><span class="line">				vis[tx][ty] = d;</span><br><span class="line">				q.push(node(tx,ty));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> _max=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(a[i][j]);</span><br><span class="line">		_max=max(_max,a[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) fi(j,<span class="number">1</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(g[i][j]);</span><br><span class="line">		<span class="keyword">if</span>(g[i][j]) &#123;</span><br><span class="line">			sum ++;</span><br><span class="line">			<span class="keyword">if</span>(sum==<span class="number">1</span>) &#123;</span><br><span class="line">				fx = i;fy =j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>,r=_max;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m =(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(bfs(m))&#123;</span><br><span class="line">			ans = m;</span><br><span class="line">			r= m<span class="number">-1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> l=m+<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p2661 信息传递 [ 并查集 tarjan topsort ]</title>
    <url>/2020/02/24/%E6%B4%9B%E8%B0%B7p2661%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2661" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2661</a></p>
<p>题意 ：求有向图的最小环</p>
<blockquote>
<p><strong>tarjan</strong> : 求所有的强连通分量，再取最小值。<br><strong>并查集</strong>：（别处看来的思路）把每个同学看成一个点，信息的传递就是在他们之间连有向边，游戏轮数就是求最小环。<br>图论求最小环，我在里面看到了并查集。<br>假如说信息由A传递给B，那么就连一条由A指向B的边，同时更新A的父节点，A到它的父节点的路径长也就是B到它的父节点的路径长+1。<br>这样我们就建立好了一个图，之后信息传递的所有环节都按照这些路径。游戏结束的轮数，也就是这个图里最小环的长度。<br>如果有两个点祖先节点相同，那么就可以构成一个环，长度为两个点到祖先节点长度之和+1。<br><strong>topsort</strong> :经典的求圈…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Low[MAX],DFN[MAX],Stack[MAX],Belong[MAX];</span><br><span class="line"><span class="keyword">int</span> n,x;</span><br><span class="line"><span class="keyword">int</span> ind,top;</span><br><span class="line"><span class="keyword">int</span> scc;   <span class="comment">//强连通分量的个数 </span></span><br><span class="line"><span class="keyword">bool</span> InStack[MAX];</span><br><span class="line"><span class="keyword">int</span> num[MAX];<span class="comment">//各个强连通分量包含点的个数</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; e[MAX]; <span class="comment">//边表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	Low[u]=DFN[u]=++ind;</span><br><span class="line">	Stack[top++]=u;</span><br><span class="line">	InStack[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> size=e[u].size();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">		v=e[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span>(!DFN[v])&#123;</span><br><span class="line">			tarjan(v,u);</span><br><span class="line">			Low[u]=min(Low[u],Low[v]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(InStack[v])&#123;</span><br><span class="line">			Low[u]=min(Low[u],DFN[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Low[u]==DFN[u])&#123;</span><br><span class="line">		scc++;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			v=Stack[--top];</span><br><span class="line">			InStack[v]=<span class="literal">false</span>;</span><br><span class="line">			Belong[v]=scc; <span class="comment">//标记属于哪一个强连通分量</span></span><br><span class="line">			num[scc]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(DFN,<span class="number">0</span>,<span class="keyword">sizeof</span>(DFN));</span><br><span class="line">	<span class="built_in">memset</span>(InStack,<span class="literal">false</span>,<span class="keyword">sizeof</span>(InStack));</span><br><span class="line">	<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">	ind=scc=top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(!DFN[i])</span><br><span class="line">			tarjan(i,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(x);</span><br><span class="line">		e[i].push_back(x);</span><br><span class="line">		e[x].push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	solve(n);</span><br><span class="line">	<span class="keyword">int</span> _min=INF;</span><br><span class="line">	fi(i,<span class="number">1</span>,scc+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(num[i]!=<span class="number">1</span> &amp;&amp; _min&gt;num[i])</span><br><span class="line">			_min=num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	pf(_min);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大佬的并查集代码</p>
</blockquote>
<p><img src="/.io//1.PNG" alt="..."></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>并查集</tag>
        <tag>topsort</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p2678 p3743[ 二分 ]</title>
    <url>/2020/03/23/%E6%B4%9B%E8%B0%B7p2678/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2678" target="_blank" rel="noopener">P2678 跳石头</a></p>
<p>类似：<a href="https://www.luogu.com.cn/problem/P3853" target="_blank" rel="noopener">P3853 [TJOI2007]路标设置</a></p>
<p><strong>题目背景</strong></p>
<p>一年一度的“跳石头”比赛又要开始了!</p>
<p><strong>题目描述</strong></p>
<p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 <em>N</em> 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p>
<p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 <em>M</em> 块岩石（不能移走起点和终点的岩石）。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个整数 L<em>,</em>N<em>,</em>M<em>，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L</em>≥1 且 N<em>≥</em>M≥0。</p>
<p>接下来 <em>N</em> 行，每行一个整数，第 i<em>i</em> 行的整数 D_i( 0 &lt; D_i &lt; L)， 表示第 <em>i</em> 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p>
<p><strong>输出格式</strong></p>
<p>一个整数，即最短跳跃距离的最大值。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25 5 2 </span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">14</span><br><span class="line">17 </span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二分答案…</p>
<p>注意是起点和终点之间有 N 个石头，并且终点不能移走</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">50000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> L,n,m,ans,a[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-last&lt;x) &#123;</span><br><span class="line">			cnt ++;</span><br><span class="line">		&#125;<span class="keyword">else</span> last = a[i];</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[n]-last&lt;x) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//终点不能移走 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(L);sf(n);sf(m);</span><br><span class="line">	<span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	a[n] = L;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">0</span>,r=L;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(isok(m))&#123;</span><br><span class="line">			ans = m;</span><br><span class="line">			l=m+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3743" target="_blank" rel="noopener">P3743 kotori的设备</a></p>
<p><strong>题目描述</strong></p>
<p>kotori 有 n 个可同时使用的设备。第 i 个设备每秒消耗ai个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数 ,在 k 秒内消耗的能量均为k*ai 单位。在开始的时候第 i 个设备里存储着bi个单位能量。</p>
<p>同时 kotori 又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 p 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。</p>
<p>kotori 想把这些设备一起使用，直到其中有设备能量降为 0。所以 kotori 想知道，</p>
<p>在充电器的作用下，她最多能将这些设备一起使用多久。</p>
<blockquote>
<p>充电宝可以瞬间换一个设备充电，比如，当期望时间为 x , 当有2个设备同时快要到 0 时，选择哪一个先充？ 方法是先把其中一个充到 x ,再充另一个。因为充电宝可以瞬间移动，所以效果是一样的（<del>不看题解完全想不到…</del>）</p>
<p>然后，就是普通的二分了。</p>
<p>代码略</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p2937 Laserphones S[ BFS ]</title>
    <url>/2020/04/15/%E6%B4%9B%E8%B0%B7p2937/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2937" target="_blank" rel="noopener">P2937 [USACO09JAN]Laserphones S</a></p>
<h2 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h2><p><img src="/.io//9084.png" alt="img"></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 8 </span><br><span class="line">....... </span><br><span class="line">......C </span><br><span class="line">......* </span><br><span class="line">*****.* </span><br><span class="line">....*.. </span><br><span class="line">....*.. </span><br><span class="line">.C..*.. </span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>建立分层图跑最短路</li>
<li>dfs </li>
<li>lca ？</li>
<li>bfs: <del>$low[x][y][f]$ 表示到达（x，y）方向为 f 时的最少转弯次数。在某个点，有三个转移状态，向左向右或前进一步，用优先队列保存点的状态，转弯次数少的优先 (点上旋转不能转已经转过的方向，但是走上来的时候可惜更新代价)。这样第一个到达终点的即最优解.(hushuo ，糊了一个代码过了，感觉不对，但是不会证明…)</del></li>
<li>bfs:按这样的顺序入队：如果点从横向（f=1）拓展而来，则遍历此点时，按纵向（f=2）拓展所有可以到达的点（step + 1）,纵向同理。由 bfs 的性质可知，第一次到达终点的即最小。</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AC</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fx,fy;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX][MAX];</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt;n || y&lt;<span class="number">1</span> ||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,f,step;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _f,<span class="keyword">int</span> _step)&#123;</span><br><span class="line">		x=_x;y=_y;f=_f;step=_step;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">	q.push(node(x,y,f,<span class="number">0</span>));</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	vis[x][y]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt =<span class="number">0</span> ,tx,ty;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node t= q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(!(t.x == fx &amp;&amp; t.y == fy) &amp;&amp; a[t.x][t.y]==<span class="string">'C'</span>) <span class="keyword">return</span> t.step;</span><br><span class="line">		<span class="keyword">if</span>(t.f==<span class="number">1</span>)&#123; <span class="comment">// row</span></span><br><span class="line">			tx = t.x <span class="number">-1</span> ,ty = t.y;</span><br><span class="line">			<span class="keyword">while</span>(judge(tx,ty) &amp;&amp; !vis[tx][ty] &amp;&amp; a[tx][ty]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">				q.push(node(tx,ty,<span class="number">2</span>,t.step+<span class="number">1</span>));</span><br><span class="line">				vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">				tx--;</span><br><span class="line">			&#125;</span><br><span class="line">			tx = t.x +<span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">while</span>(judge(tx,ty)&amp;&amp; !vis[tx][ty]  &amp;&amp; a[tx][ty]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">				q.push(node(tx,ty,<span class="number">2</span>,t.step+<span class="number">1</span>));</span><br><span class="line">				vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">				tx++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123; <span class="comment">//col</span></span><br><span class="line">			tx = t.x ,ty = t.y - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(judge(tx,ty) &amp;&amp; !vis[tx][ty] &amp;&amp; a[tx][ty]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">				q.push(node(tx,ty,<span class="number">1</span>,t.step+<span class="number">1</span>));</span><br><span class="line">				vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">				ty--;</span><br><span class="line">			&#125;</span><br><span class="line">			ty = t.y +<span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">while</span>(judge(tx,ty) &amp;&amp; !vis[tx][ty] &amp;&amp; a[tx][ty]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">				q.push(node(tx,ty,<span class="number">1</span>,t.step+<span class="number">1</span>));</span><br><span class="line">				vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">				ty++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(m);sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(a[i][j]==<span class="string">'C'</span>) &#123;</span><br><span class="line">			fx = i; fy = j;</span><br><span class="line">		&#125;</span><br><span class="line">	pf(min(bfs(fx,fy,<span class="number">1</span>),bfs(fx,fy,<span class="number">2</span>))<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ganjuecuodanshique aclededaima</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,fx,fy,ans,aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> vis[MAX][MAX][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> low[MAX][MAX][<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,f;</span><br><span class="line">	node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _f )&#123;</span><br><span class="line">		x=_x;y=_y;f=_f;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> low[x][y][f] &gt; low[a.x][a.y][a.f];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt;n || y&lt;<span class="number">1</span> ||y&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	mem(vis,<span class="number">0</span>);mem(low,<span class="number">0x3f</span>);</span><br><span class="line">	q.push(node(x,y,<span class="number">0</span>));q.push(node(x,y,<span class="number">1</span>));</span><br><span class="line">	q.push(node(x,y,<span class="number">2</span>));q.push(node(x,y,<span class="number">3</span>));</span><br><span class="line">	vis[x][y][<span class="number">0</span>]=vis[x][y][<span class="number">1</span>]=vis[x][y][<span class="number">2</span>]=vis[x][y][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">	low[x][y][<span class="number">0</span>]=low[x][y][<span class="number">1</span>]=low[x][y][<span class="number">2</span>]=low[x][y][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		node t =q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(!(t.x == fx &amp;&amp; t.y == fy) &amp;&amp; a[t.x][t.y]==<span class="string">'C'</span>)&#123;</span><br><span class="line">			ans = low[t.x][t.y][t.f];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!vis[t.x][t.y][(t.f+<span class="number">5</span>)%<span class="number">4</span>])&#123; <span class="comment">// right</span></span><br><span class="line">			q.push(node(t.x,t.y,(t.f+<span class="number">5</span>)%<span class="number">4</span>));</span><br><span class="line">			vis[t.x][t.y][(t.f+<span class="number">5</span>)%<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">			low[t.x][t.y][(t.f+<span class="number">5</span>)%<span class="number">4</span>] = low[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!vis[t.x][t.y][(t.f+<span class="number">3</span>)%<span class="number">4</span>])&#123; <span class="comment">//left</span></span><br><span class="line">			q.push(node(t.x,t.y,(t.f+<span class="number">3</span>)%<span class="number">4</span>));</span><br><span class="line">			vis[t.x][t.y][(t.f+<span class="number">3</span>)%<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">			low[t.x][t.y][(t.f+<span class="number">3</span>)%<span class="number">4</span>] = low[t.x][t.y][t.f] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> tx = t.x +aw[t.f][<span class="number">0</span>],ty = t.y +aw[t.f][<span class="number">1</span>]; <span class="comment">//forward</span></span><br><span class="line">		<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; a[tx][ty]!=<span class="string">'*'</span> &amp;&amp; low[tx][ty][t.f] &gt; low[t.x][t.y][t.f])&#123;</span><br><span class="line">			q.push(node(tx,ty,t.f));</span><br><span class="line">			vis[tx][ty][t.f] = <span class="number">1</span>;</span><br><span class="line">			low[tx][ty][t.f] = low[t.x][t.y][t.f];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(m);sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]+<span class="number">1</span>);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>) fi(j,<span class="number">1</span>,m+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(a[i][j]==<span class="string">'C'</span>) &#123;</span><br><span class="line">			fx = i; fy = j;</span><br><span class="line">		&#125;</span><br><span class="line">	ans = INF;</span><br><span class="line">	bfs(fx,fy); </span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
        <tag>BFS</tag>
        <tag>spfa</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p3368 树状数组[ 差分数组 ]</title>
    <url>/2020/03/28/%E6%B4%9B%E8%B0%B7p3368/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3368" target="_blank" rel="noopener">P3368 【模板】树状数组 2</a></p>
<p>树状数组介绍 ：<a href="https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees/" target="_blank" rel="noopener"><strong>Binary Indexed Trees</strong> structure</a></p>
<p><strong>题目描述</strong></p>
<p>已知一个数列，你需要进行下面两种操作：</p>
<ol>
<li>将某区间每一个数数加上 x<em>x</em>；</li>
<li>求出某一个数的值。</li>
</ol>
<blockquote>
<p>板子…</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">500000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t,x,y,k,a[MAX],b[MAX];</span><br><span class="line"><span class="keyword">int</span> tree[MAX];</span><br><span class="line"><span class="comment">// getsum( r ) - getsum( l - 1 )</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		sum += tree[i];</span><br><span class="line">		i-=(i&amp;-i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单点修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">		tree[i]+=val;</span><br><span class="line">		i+=(i&amp;-i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLR</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;  </span><br><span class="line">	update(l,val);</span><br><span class="line">	update(r+<span class="number">1</span>,-val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n) 建树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		tree[i]+=a[i];</span><br><span class="line">		<span class="keyword">int</span> j=i+(i&amp;(-i));</span><br><span class="line">		<span class="keyword">if</span>(j&lt;=n)  tree[j]+=tree[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等比放缩 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">        tree[i] = tree[i] / c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//权值树状数组查询第k小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = log2(n); ~i; --i) &#123;      <span class="comment">// i与上文depth含义相同</span></span><br><span class="line">    ret += <span class="number">1</span> &lt;&lt; i;                      <span class="comment">//尝试扩展</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= n || cnt + tree[ret] &gt;= k)  <span class="comment">//如果扩展失败</span></span><br><span class="line">      ret -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      cnt += tree[ret];  <span class="comment">//扩展成功后 要更新之前求和的值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(log n) </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getone</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = tree[i]; </span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>)&#123; </span><br><span class="line">		<span class="keyword">int</span> z = i - (i &amp; -i);</span><br><span class="line">		i--; </span><br><span class="line">		<span class="keyword">while</span> (i != z)&#123; </span><br><span class="line">			sum -= tree[i]; </span><br><span class="line">		    i -= (i &amp; -i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		sf(b[i]);</span><br><span class="line">		a[i]=b[i]-b[i<span class="number">-1</span>]; <span class="comment">//差分</span></span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		sf(t);</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">			sf(x);sf(y);sf(k);</span><br><span class="line">			updateLR(x,y,k);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">			sf(x);</span><br><span class="line">			pf(getsum(x));</span><br><span class="line">			pfc(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p3379 [ LCA模板 ]</title>
    <url>/2020/03/24/%E6%B4%9B%E8%B0%B7p3379/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">P3379 【模板】最近公共祖先（LCA）</a></p>
<p><strong>题目描述</strong></p>
<p>如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个正整数 N,M,S<em>N</em>,<em>M</em>,<em>S</em>，分别表示树的结点个数、询问的个数和树根结点的序号。</p>
<p>接下来 N-1<em>N</em>−1 行每行包含两个正整数 x, y<em>x</em>,<em>y</em>，表示 x<em>x</em> 结点和 y<em>y</em> 结点之间有一条直接连接的边（数据保证可以构成树）。</p>
<p>接下来 M<em>M</em> 行每行包含两个正整数 a, b<em>a</em>,<em>b</em>，表示询问 a<em>a</em> 结点和 b<em>b</em> 结点的最近公共祖先。</p>
<p><strong>输出格式</strong></p>
<p>输出包含 M<em>M</em> 行，每行包含一个正整数，依次为每一个询问的结果。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5 4</span><br><span class="line">3 1</span><br><span class="line">2 4</span><br><span class="line">5 1</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lca 模板。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">500000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,x,y;</span><br><span class="line"><span class="keyword">int</span> anc[MAX][<span class="number">25</span>],l[MAX];</span><br><span class="line"><span class="keyword">bool</span> vis[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		l[v]=l[u]+<span class="number">1</span>;</span><br><span class="line">		anc[v][<span class="number">0</span>]=u;</span><br><span class="line">		fi(j,<span class="number">1</span>,<span class="number">15</span>) anc[v][j]=<span class="number">-1</span>;<span class="comment">//初始化为祖先不存在  这题卡常，log小点，或初始化一下</span></span><br><span class="line">		dfs(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fi(j,<span class="number">1</span>,<span class="number">21</span>)</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)	</span><br><span class="line">			<span class="keyword">if</span>(anc[i][j<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">				anc[i][j]=anc[anc[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]; <span class="comment">//anc(i,j) 节点i的第2^j级祖先编号</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l[p]&lt;l[q]) swap(p,q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)   <span class="comment">//p q 同深度</span></span><br><span class="line">		<span class="keyword">if</span>(l[anc[p][i]]&gt;=l[q])</span><br><span class="line">			p=anc[p][i];</span><br><span class="line">	<span class="keyword">if</span>(p==q) <span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(anc[p][i]!=<span class="number">-1</span>&amp;&amp;anc[p][i]!=anc[q][i])&#123;</span><br><span class="line">			p=anc[p][i];q=anc[q][i];   <span class="comment">//向上</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> anc[p][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(head,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(m);sf(s);</span><br><span class="line">	fi(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		addedge(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	l[s]=<span class="number">1</span>;anc[s][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	dfs(s);pre();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		pf(lca(x,y));pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p3387 缩点 [ tarjan缩点+dp ]</title>
    <url>/2020/03/27/%E6%B4%9B%E8%B0%B7p3387%E7%BC%A9%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3387" target="_blank" rel="noopener">P3387 【模板】缩点</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个 <em>n</em> 个点 m* 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p>
<p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个正整数 n<em>,</em>m*</p>
<p>第二行 n* 个整数，依次代表点权</p>
<p>第三至 <em>m</em>+2 行，每行两个整数 u<em>,</em>v<em>，表示一条 u</em>→<em>v</em> 的有向边。</p>
<p><strong>输出格式</strong></p>
<p>共一行，最大的点权之和。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tarjan 缩点模板…</p>
<p>对于每一个强连通分量，指定一个节点 $u_i （dfn[u_i]==low[u_i]）$的点 ,并且$w[u_i]=sum(w[v_i]）$, </p>
<p>遍历所有的边（u，v），如果 u，v 属于不同的强连通分量 $ i,j$，则在该强连通分量的 $ u_i  , u_j$ 之间连边；</p>
<p>可能会连重复的边？看存储方式处理一下，或者不处理…</p>
<p><del>一种可能的情况 ： 强连通分量的总的代价 等于0 ，所以是不能以 w[u] 是否等于 0 来判断该点是否是最后树中的节点的。</del></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAX],n,m,u,v,ans;</span><br><span class="line"><span class="keyword">int</span> indeg[MAX],d[MAX],rt[MAX];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">10</span>*<span class="number">2</span>],e2[MAX*<span class="number">10</span>*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],head2[MAX],tot=<span class="number">0</span>,tot2=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to = v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e2[tot2].to = v;</span><br><span class="line">	e2[tot2].next=head2[u];</span><br><span class="line">	head2[u]=tot2++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[MAX],low[MAX],color[MAX],num[MAX],Stack[MAX];	</span><br><span class="line"><span class="keyword">bool</span> instack[MAX];</span><br><span class="line"><span class="keyword">int</span> ind,scc,top;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	dfn[u]=low[u]=++ind;</span><br><span class="line">	Stack[top++]=u;</span><br><span class="line">	instack[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		v = e[i].to;</span><br><span class="line">		<span class="comment">//if(v==fa) continue; //无向图 </span></span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			tarjan(v,u);</span><br><span class="line">			low[u]=min(low[u],low[v]);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(instack[v])&#123;</span><br><span class="line">			low[u]=min(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">		scc++;</span><br><span class="line">		rt[scc]=u;  <span class="comment">//记录此联通块的缩点 </span></span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			v=Stack[--top];</span><br><span class="line">			instack[v]=<span class="literal">false</span>;</span><br><span class="line">			color[v]=scc; <span class="comment">//标记属于哪一个强连通分量</span></span><br><span class="line">			num[scc]++;</span><br><span class="line">			<span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">				a[u]+=a[v]; <span class="comment">// 缩点 </span></span><br><span class="line">				a[v]=<span class="number">0</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mem(instack,<span class="number">0</span>);</span><br><span class="line">	mem(num,<span class="number">0</span>);</span><br><span class="line">	mem(dfn,<span class="number">0</span>);</span><br><span class="line">	ind=scc=top=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])</span><br><span class="line">			tarjan(i,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(!indeg[i]) &#123;</span><br><span class="line">			d[i]=a[i];</span><br><span class="line">			q.push(i); <span class="comment">//i 点没有被"缩"掉 </span></span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> u= q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="comment">// todo 记录 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head2[u];i!=<span class="number">-1</span>;i=e2[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v= e2[i].to;</span><br><span class="line">			d[v]=max(d[v],d[u]+a[v]);</span><br><span class="line">			<span class="keyword">if</span>(--indeg[v]==<span class="number">0</span>) q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(head,<span class="number">-1</span>);mem(head2,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		sf(a[i]);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(u);sf(v);</span><br><span class="line">		addedge(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	solve();</span><br><span class="line">	fi(u,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(color[u]!=color[v] )&#123; <span class="comment">//收缩后的点才连边 </span></span><br><span class="line">				indeg[rt[color[v]]]++;</span><br><span class="line">				addedge2(rt[color[u]],rt[color[v]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	topo();</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">		ans = max(ans,d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>动态规划</tag>
        <tag>DAG</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p3388 割点 [ 割点模板 ]</title>
    <url>/2020/03/27/%E6%B4%9B%E8%B0%B7p3388%E5%89%B2%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3388" target="_blank" rel="noopener">P3388 【模板】割点（割顶）</a></p>
<p>题意： 求割点</p>
<blockquote>
<p>无向图，割点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,x,y,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[MAX*<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAX],tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	e[tot].to=v;</span><br><span class="line">	e[tot].next=head[u];</span><br><span class="line">	head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> low[MAX],dfn[MAX];</span><br><span class="line"><span class="keyword">int</span> ind; </span><br><span class="line"><span class="keyword">bool</span> instack[MAX],iscut[MAX]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>,lowu,lowv;</span><br><span class="line">	lowu=dfn[u]=++ind;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">		<span class="keyword">int</span> v=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">			cnt ++;</span><br><span class="line">			lowv=tarjan(v,u);</span><br><span class="line">			lowu=min(lowu,lowv);</span><br><span class="line">			<span class="keyword">if</span>(lowv&gt;=dfn[u])&#123;  <span class="comment">//  &gt;=</span></span><br><span class="line">				iscut[u]=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dfn[v]&lt;dfn[u])&#123;</span><br><span class="line">			lowu=min(lowu,dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fa&lt;<span class="number">0</span> &amp;&amp; cnt==<span class="number">1</span>)</span><br><span class="line">		iscut[u]=<span class="literal">false</span>;</span><br><span class="line">	low[u]=lowu;</span><br><span class="line">	<span class="keyword">return</span> lowu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	mem(dfn,<span class="number">0</span>);</span><br><span class="line">	ind=<span class="number">0</span>;</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])</span><br><span class="line">			tarjan(i,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	mem(head,<span class="number">-1</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(x);sf(y);</span><br><span class="line">		addedge(x,y);</span><br><span class="line">		addedge(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	solve();</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(iscut[i])</span><br><span class="line">			ans ++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(iscut[i])</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p3650 滑雪课程设计 [ 枚举 ]</title>
    <url>/2020/03/10/%E6%B4%9B%E8%B0%B7p3650/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3650" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P3650</a></p>
<p><strong>题目描述</strong></p>
<p>农民约翰的农场里有 <em>n</em> 座山峰，每座山都有一个在 0 到 100 之间的整数的海拔高度。在冬天,因为山上有丰富的积雪，约翰经常开办滑雪训练营。</p>
<p>不幸的是，约翰刚刚得知税法在滑雪训练营方面有新变化，明年开始实施。在仔细阅读法律后，他发现如果滑雪训练营的最高和最低的山峰海拔高度差大于 17 就要收税。因此，如果他改变山峰的高度（使最高与最低的山峰海拔高度差不超过 17 ），约翰可以避免支付税收。</p>
<p>如果改变一座山 <em>x</em> 单位的高度成本是 $x^2$单位，约翰最少需要付多少钱才能使海拔最高的山峰与海拔最低的山峰的高度只差不超过 17 约翰只愿意改变整数单位的高度。</p>
<p><strong>输入格式</strong></p>
<p>输入的第一行是一个整数，代表山峰的数量 <em>n</em>。</p>
<p>第 22 行到 (<em>n</em>+1) 行，每行一个整数。第 <em>i</em> 行的整数 $a_i$ 代表第 <em>i</em> 座山的海拔高度。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个整数，代表约翰需要支付修改山海拔高度的总金额。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">20</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">24</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure>
<blockquote>
<p><del>每次选择最高最低的山峰（可能有多个），计算最小代价，更新修改后山峰的数量，继续。</del></p>
<p>跑完用程序验证一下，其实是错的…</p>
<p>题解：枚举山的高度，计算取最小值…</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p3956 棋牌 [ 剪枝 ]</title>
    <url>/2020/03/20/%E6%B4%9B%E8%B0%B7p3956%E6%A3%8B%E7%89%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3956" target="_blank" rel="noopener">P3956 棋盘</a></p>
<p>题意: 常见的矩阵…那样…</p>
<blockquote>
<p>dfs + 剪枝 ，最优性剪枝和记忆化搜索都是要记录一部分结果，但是又有区别，可以看一下这里 <a href="https://lscgx.github.io/2020/02/22/%E6%B4%9B%E8%B0%B71433%E5%90%83%E5%A5%B6%E9%85%AA/">洛谷 1434 [SHOI2002]滑雪</a> </p>
<p>本题可以将每一块看成一个图上的节点，跑 dij, 这样</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m,a[MAX][MAX],x,y,c,vis[MAX][MAX],ans,_min[MAX][MAX]; </span><br><span class="line"><span class="keyword">int</span> aw[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span>||x&gt;n||y&lt;<span class="number">1</span>||y&gt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n&amp;&amp;y==n)&#123;</span><br><span class="line">		ans = min(ans,d);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	_min[x][y]=d;</span><br><span class="line">	fi(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tx= x+aw[i][<span class="number">0</span>],ty=y+aw[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(judge(tx,ty) &amp;&amp; !vis[tx][ty])&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[tx][ty]==<span class="number">-1</span> &amp;&amp; f) <span class="keyword">continue</span>;<span class="comment">//不能连续走空白格</span></span><br><span class="line">			vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(a[tx][ty]==<span class="number">-1</span> &amp;&amp; d+<span class="number">2</span>&lt;_min[tx][ty])&#123;</span><br><span class="line">				a[tx][ty]=a[x][y];</span><br><span class="line">				dfs(tx,ty,d+<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">				a[tx][ty]=<span class="number">-1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[tx][ty]==a[x][y] &amp;&amp; d&lt;_min[tx][ty])&#123;</span><br><span class="line">				dfs(tx,ty,d,<span class="number">0</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(d+<span class="number">1</span>&lt;_min[tx][ty])&#123;</span><br><span class="line">				dfs(tx,ty,d+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			vis[tx][ty]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);sf(m);</span><br><span class="line">	mem(a,<span class="number">-1</span>);</span><br><span class="line">	mem(vis,<span class="number">0</span>);</span><br><span class="line">	mem(_min,<span class="number">0x3f</span>);</span><br><span class="line">	fi(i,<span class="number">0</span>,m)&#123;</span><br><span class="line">		sf(x);sf(y);sf(c);</span><br><span class="line">		a[x][y]=c;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;ans =INF;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(ans==INF)pfc(<span class="string">"-1"</span>);</span><br><span class="line">	<span class="keyword">else</span> pf(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>剪枝</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 p4047 [ 生成树+二分 ]</title>
    <url>/2020/03/25/%E6%B4%9B%E8%B0%B7p4047/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4047" target="_blank" rel="noopener">P4047 [JSOI2010]部落划分</a></p>
<p><strong>题目描述</strong></p>
<p>聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。</p>
<p>不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 <em>n</em> 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 k* 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：</p>
<p>对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。</p>
<p>例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。</p>
<p><img src="/.io//30573.png" alt="img"></p>
<p><strong>输入格式</strong></p>
<p>输入文件第一行包含两个整数n和 k，分别代表了野人居住点的数量和部落的数量。</p>
<p>接下来 n 行，每行包含两个整数 x<em>，</em>y，描述了一个居住点的坐标。</p>
<p><strong>输出格式</strong></p>
<p>输出一行一个实数，为最优划分时，最近的两个部落的距离，精确到小数点后两位。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 3</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">4 6</span><br><span class="line">6 2</span><br><span class="line">6 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.00</span><br></pre></td></tr></table></figure>
<blockquote>
<p>求最小生成树，一共有k个部落，我们只需要找n-k条边，第n-k+1条边就是答案.</p>
<p>二分：枚举一个距离 d ,将所有 &lt;d 的连起来，用并查集判断是否可以分成 k 个部落。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,tot=<span class="number">0</span>,cnt=<span class="number">0</span>,f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[x]==<span class="number">-1</span>?x:f[x]=find(f[x]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> x,y;</span><br><span class="line">&#125;a[MAX];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(node u,node v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	<span class="keyword">double</span> c;</span><br><span class="line">	edge()&#123;&#125;</span><br><span class="line">	edge(<span class="keyword">int</span> _u,<span class="keyword">int</span> _v)&#123;</span><br><span class="line">		u=_u;v=_v;c=calc(a[u],a[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> edge&amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c&lt;x.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;e[MAX*MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	mem(f,<span class="number">-1</span>);</span><br><span class="line">	sf(n);sf(k);</span><br><span class="line">	fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	fi(i,<span class="number">0</span>,n)</span><br><span class="line">		fi(j,i+<span class="number">1</span>,n)</span><br><span class="line">			e[tot++]=edge(i,j);</span><br><span class="line">	sort(e,e+tot);</span><br><span class="line">	fi(i,<span class="number">0</span>,tot)&#123;</span><br><span class="line">		<span class="keyword">int</span> u=find(e[i].u);</span><br><span class="line">		<span class="keyword">int</span> v=find(e[i].v);</span><br><span class="line">		<span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line">			f[u]=v;</span><br><span class="line">			cnt ++;</span><br><span class="line">			<span class="keyword">if</span>(n-k+<span class="number">1</span>==cnt)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%.2lf"</span>,e[i].c);<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P5662 纪念品[ 背包 ]</title>
    <url>/2020/04/24/%E6%B4%9B%E8%B0%B7p5662/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5662" target="_blank" rel="noopener">P5662 纪念品</a></p>
<p><strong>题目描述</strong></p>
<p>小伟突然获得一种超能力，他知道未来 T<em> 天 N</em> 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。</p>
<p>每天，小伟可以进行以下两种交易<strong>无限次</strong>：</p>
<ol>
<li>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；</li>
<li>卖出持有的任意一个纪念品，以当日价格换回金币。</li>
</ol>
<p>每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。</p>
<p><em>T</em> 天之后，小伟的超能力消失。因此他一定会在第 <em>T</em> 天卖出<strong>所有</strong>纪念品换回金币。</p>
<p>小伟现在有 M* 枚金币，他想要在超能力消失后拥有尽可能多的金币。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个正整数 T, N, M，相邻两数之间以一个空格分开，分别代表未来天数 T<em>，纪念品数量 N</em>，小伟现在拥有的金币数量 M*。</p>
<p>接下来 T 行，每行包含 <em>N</em> 个正整数，相邻两数之间以一个空格分隔。第 i 行的 <em>N</em> 个正整数分别为 P_{i,1}，P_{i,2},……,P{i,j} 表示第 <em>i</em> 天第 <em>j</em> 种纪念品的价格。</p>
<p><strong>输出格式</strong></p>
<p>输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 1 100</span><br><span class="line">50</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">50</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">305</span><br></pre></td></tr></table></figure>
<p><strong>输入 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 100</span><br><span class="line">10 20 15</span><br><span class="line">15 17 13</span><br><span class="line">15 25 16</span><br></pre></td></tr></table></figure>
<p><strong>输出 #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">217</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考虑连续持有一件物品：</p>
<p>当日买入，未来第 x 天 卖出收益最大，考虑第二天：</p>
<ul>
<li><p>第二天（x=2）卖出，那么直接卖出即可</p>
</li>
<li><p>第二天 (x&gt;2) 之后卖出，第二天直接卖出的话收益为负，那么今天直接不买,第二天再买就好了</p>
</li>
<li><p>同上，第二天卖出收益为正，但是第 x 天卖出收益更大，可以观察出，第二天卖出再买回来，和第二天不卖，第 x 天卖出收益是一样的。</p>
<p>综上，只需要考虑临近两天的最大收益即可。</p>
</li>
</ul>
<p>对于连续两天，设当日买入价格为 “空间” ， 第二日与今日收益为 “价值”，就是完全背包问题。</p>
<p><del>虽然一开始完全没想到背包…</del></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fi(i,<span class="number">0</span>,t)&#123;</span><br><span class="line">	mem(f,<span class="number">0</span>);</span><br><span class="line">	fi(j,<span class="number">0</span>,n)</span><br><span class="line">		fi(k,a[j][i],m+<span class="number">1</span>)</span><br><span class="line">			f[k]=max(f[k],f[k-a[j][i]]+a[j][i+<span class="number">1</span>]-a[j][i]);</span><br><span class="line">	m = max(m,f[m]+m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 情侣 [ 状压dp ]</title>
    <url>/2020/03/29/%E6%B4%9B%E8%B0%B7%E6%83%85%E4%BE%A3/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/U108001?contestId=27946" target="_blank" rel="noopener">U108001 情侣</a></p>
<p><strong>题目背景</strong></p>
<p>FFF 团正在策划一场行动……</p>
<p><strong>题目描述</strong></p>
<p>这场行动准备在一座城市实施。这座城市有 <em>n</em> 个小镇编号为 1,2,⋯,<em>n</em>，小镇两两之间都有一条双向道路连接。</p>
<p>FFF 团拿到了一张图，上面标明了小镇两两之间的道路上的情侣对数。</p>
<p>团长小 A 命令你去把这些情侣都烧掉。当然，他也会给你很多奖赏。</p>
<p>具体来说，是这样的：每次，你可以选择某一个小镇 x<em>，然后把与 x</em> 相连的所有道路上的情侣都烧掉。如果你这一次烧掉了 t 对情侣，那么小 A 会给你 t^2 元的奖励。你可以这么做多次，直到所有情侣都被烧光为止。</p>
<p>你当然想尽快烧了所有情侣，但是你想先算算你的最大收益是多少。</p>
<p><strong>注意，情侣一旦被烧掉就不存在了</strong>。比如，你在城市 1 烧了一次，然后在城市 2 烧了一次，那么第二次就不会烧到(1,2) 这条路上的情侣。</p>
<p><strong>输入格式</strong></p>
<p>第一行一个整数 n，表示小镇的个数。</p>
<p>接下来 n<em> 行，第 i 行 n 个整数 ai1,ai2,ai3…ain  表示边 (</em>i<em>,</em>j*) 上的情侣有多少对。</p>
<p><strong>输出格式</strong></p>
<p>一行一个整数，表示你能获得的最大收益。</p>
<p><strong>输入输出样例</strong></p>
<p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 2</span><br><span class="line">1 0 1</span><br><span class="line">2 1 0</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dp[ s ] 表示当前烧了 s 集合个城市，烧掉最多情侣。转移方程 ：dp[s]=max(dp[s^(1&lt;&lt;(i-1))]+ val*val ,dp[s]); ​ val 为 s^(1&lt;&lt;(i-1))​ (s 中删除 i 城市) 集合下，删掉 i 带来的价值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,g[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(n);</span><br><span class="line">	fi(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		fi(j,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			sf(g[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	fi(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;n)&#123;</span><br><span class="line">		fi(i,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))&#123;</span><br><span class="line">				<span class="keyword">if</span>(s==(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))&#123;</span><br><span class="line">					<span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">					fi(k,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(i!=k &amp;&amp; g[i][k])&#123;</span><br><span class="line">							val += g[i][k];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					dp[s]= val*val;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">					fi(k,<span class="number">1</span>,n+<span class="number">1</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(i!=k &amp;&amp; g[i][k] &amp;&amp; !(s&amp;(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))))&#123;</span><br><span class="line">							val += g[i][k];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					dp[s]=max(dp[s^(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]+val*val,dp[s]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pf(dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>画家木板分配问题</title>
    <url>/2020/01/23/%E7%94%BB%E5%AE%B6%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.geeksforgeeks.org/painters-partition-problem/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/painters-partition-problem/</a></p>
<p>我们必须绘制n个长度为{A1，A2 … An}的木板。有k画家可用，每个画家需要1单位时间来绘画1单位的木板。问题是找到获取的最短时间。这项工作是在以下条件下完成的：任何画家都只能绘制连续的木板部分，例如木板{2，3，4}或仅木板{1}或什么都不涂，而不是木板{2，4，5}。</p>
<blockquote>
<p>方法一 : dp[ ][ ] 表示前 j 块木板，i 个人的最短时间。<br>dp[ i ][ j ] = min( dp[ i ][ j ] , max(dp[ i - 1 ][ k ] , sum (a, k + 1  , j )) ) ,(1 &lt;= k &lt;=j  );<br>dp[ i ] 只与 dp[ i - 1] 有关</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(n) scanf(<span class="meta-string">"%d"</span>,&amp;n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf(n) printf(<span class="meta-string">"%d"</span>,n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfc(c) printf(c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi(i,s,t) for(int i=s;i&lt;t;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(s,t) for(int i=s-1;i&gt;=t;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,c) memset(a,c,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000000</span>+<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> t,n,m,a[MAX];</span><br><span class="line">ll sum[MAX],dp[MAX],dp2[MAX],best;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	sf(t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		sf(n);</span><br><span class="line">		fi(i,<span class="number">0</span>,n)&#123;</span><br><span class="line">			sf(a[i]);</span><br><span class="line">			sum[i] = a[i];</span><br><span class="line">			<span class="keyword">if</span>(i) sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		sf(m);</span><br><span class="line">		<span class="keyword">if</span>(n&lt;m) &#123;</span><br><span class="line">			pfc(<span class="string">"-1\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fi(i,<span class="number">0</span>,n)</span><br><span class="line">			dp[i] = sum[i];</span><br><span class="line">		fi(i,<span class="number">2</span>,m+<span class="number">1</span>)&#123;</span><br><span class="line">			fi(h,<span class="number">0</span>,n) dp2[h] = dp[h];</span><br><span class="line">			fi(j,<span class="number">0</span>,n)&#123;</span><br><span class="line">				best = INF;</span><br><span class="line">				fi(p,<span class="number">0</span>,j+<span class="number">1</span>)&#123;</span><br><span class="line">					best = min(best, max(dp2[p] ,sum[j] - sum[p]));</span><br><span class="line">				&#125;</span><br><span class="line">				dp[j] = best;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pf(dp[n<span class="number">-1</span>]);pfc(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方法二：分治。<br>最后的结果属于 max( a[ i ] ) - sum( a[ i ] ) ,对于 mid 如果对于给定的 k 个画家不可行，则取更大值继续。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Source code submitted by Gaurav on Q&amp;A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to check if it is possible to distribute pages</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> curMin)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> studentsRequired = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;       </span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; curMin) <span class="keyword">return</span> <span class="literal">false</span>;          </span><br><span class="line">        <span class="comment">// check if current number of pages are greater </span></span><br><span class="line">        <span class="comment">// than curr_min that means we will get the result </span></span><br><span class="line">        <span class="comment">// after mid no. of pages </span></span><br><span class="line">        <span class="keyword">if</span> (curSum + arr[i] &gt; curMin) &#123;            </span><br><span class="line">            studentsRequired++;</span><br><span class="line">            curSum = arr[i];</span><br><span class="line">             <span class="comment">// if students required becomes greater </span></span><br><span class="line">             <span class="comment">// than given no. of students,return false </span></span><br><span class="line">            <span class="keyword">if</span> (studentsRequired &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            curSum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// function to find min number of pages</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return -1 if no. of books is less than </span></span><br><span class="line">    <span class="comment">// no. of students </span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    <span class="comment">// Count total number of pages </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) sum += arr[i];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> end = sum, mid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="keyword">int</span>(<span class="number">1e15</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        </span><br><span class="line">        mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check if it is possible to distribute </span></span><br><span class="line">        <span class="comment">// books by using mid as current minimum </span></span><br><span class="line">        <span class="keyword">if</span> (isPossible(arr, n, m, mid)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if yes then find the minimum distribution </span></span><br><span class="line">            ans = ans&lt;mid? ans:mid;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// as we are finding minimum and books </span></span><br><span class="line">            <span class="comment">// are sorted so reduce end = mid -1 </span></span><br><span class="line">            <span class="comment">// that means </span></span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// if not possible means pages should be </span></span><br><span class="line">         <span class="comment">// increased so update start = mid + 1 </span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// at-last return minimum no. of  pages </span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> A[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(A, n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>简单dp</title>
    <url>/2018/04/26/%E7%AE%80%E5%8D%95dp/</url>
    <content><![CDATA[<p><img src="/.io//1.PNG" alt="dp"></p>
<blockquote>
<p>Two Kinds of Guessing</p>
<ol>
<li>Within a subproblem<br>– Crazy    Eights:    previous    card    in    trick<br>– Sequence    alignment:    align/drop    one    character<br>– Bellman‐Ford:    previous    edge    in    path<br>– Floyd‐Warshall:    use    vertex     ?<br>– Parenthesization:    last    multiplication<br>– Knapsack:    include    item     ?<br>– Tetris    training:    how    to    place    piece    </li>
<li>Using additional subproblems<br>– Knapsack:    how    much    space    left    in    knapsack<br>– Tetris    training:    current    board    configuration</li>
</ol>
</blockquote>
<h3 id="矩阵取数"><a href="#矩阵取数" class="headerlink" title="矩阵取数"></a>矩阵取数</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=1" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=1</a><br>给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。走过的数的总和作为你的得分，求最大的得分。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("yzhid.in", "r", stdin);</span></span><br><span class="line">   <span class="comment">//freopen("yzhid.out", "w", stdout);</span></span><br><span class="line">	<span class="keyword">int</span> n,a[MAX][MAX],d[MAX][MAX];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">	d[<span class="number">0</span>][<span class="number">0</span>]=a[<span class="number">0</span>][<span class="number">0</span>];	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i][j]=max(d[i<span class="number">-1</span>][j],d[i][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[n][n]);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大字段和问题"><a href="#最大字段和问题" class="headerlink" title="最大字段和问题"></a>最大字段和问题</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=2" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=2</a><br>给出一个整数数组a(正负数都有)，如何找出一个连续子数组（可以一个都不取，那么结果为0），使得其中的和最大？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 50000+1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("yzhid.in", "r", stdin);</span></span><br><span class="line">	<span class="keyword">int</span> n,a[MAX];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> endmax,ans;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	endmax=a[<span class="number">1</span>];</span><br><span class="line">	ans=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		endmax=max(endmax,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>)+a[i];</span><br><span class="line">		ans=max(ans,endmax);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=4" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=4</a><br>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000+5</span></span><br><span class="line"><span class="keyword">char</span> a[MAX],b[MAX],c[MAX];</span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX],r[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s\n%s"</span>,&amp;a[<span class="number">1</span>],&amp;b[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">int</span> la=<span class="built_in">strlen</span>(&amp;a[<span class="number">1</span>]),lb=<span class="built_in">strlen</span>(&amp;b[<span class="number">1</span>]);		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=la;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lb;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || j== <span class="number">0</span>)</span><br><span class="line">	            dp[i][j]= <span class="number">0</span>;</span><br><span class="line">	        <span class="keyword">else</span> <span class="keyword">if</span> (a[i]==b[j]) &#123;</span><br><span class="line">	        	dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">	        	r[i][j]=<span class="number">2</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]&gt;=dp[i][j<span class="number">-1</span>])&#123;</span><br><span class="line">        		dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        		r[i][j]=<span class="number">1</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">        	<span class="keyword">else</span> &#123;</span><br><span class="line">        		dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">        		r[i][j]=<span class="number">3</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">char</span> ans[MAX];</span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">0</span>,i=la,j=lb;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(r[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">			ans[t++]=a[i];</span><br><span class="line">			i--;j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(r[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(r[i][j]==<span class="number">3</span>)&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=t<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="built_in">putchar</span>(ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=3" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=3</a><br>给定两个字符串S和T，对于T我们允许三种操作：</p>
<p>(1) 在任意位置添加任意字符<br>(2) 删除存在的任意字符<br>(3) 修改任意字符 </p>
<p>问最少操作多少次可以把字符串T变成S？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000+5 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> same(a,b) a==b?0:1</span></span><br><span class="line"><span class="keyword">char</span> a[MAX],b[MAX];</span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("yzhid.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s\n%s"</span>,&amp;a[<span class="number">1</span>],&amp;b[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">int</span> la =<span class="built_in">strlen</span>(&amp;a[<span class="number">1</span>]),lb=<span class="built_in">strlen</span>(&amp;b[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=la;i++)</span><br><span class="line">		dp[i][<span class="number">0</span>]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lb;i++)</span><br><span class="line">		dp[<span class="number">0</span>][i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=la;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lb;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> t =same(a[i],b[j]);</span><br><span class="line">			dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+t,min(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[la][lb]);		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长单增子序列"><a href="#最长单增子序列" class="headerlink" title="最长单增子序列"></a>最长单增子序列</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=5" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=5</a><br>(LIS Longest Increasing Subsequence)给定一个数列，从中删掉任意若干项剩余的序列叫做它的一个子序列，求它的最长的子序列，满足子序列中的元素是单调递增的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 50000+5 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> a[MAX],f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">1</span>,e=len,mid;</span><br><span class="line">	<span class="keyword">while</span>(b&lt;len)&#123;</span><br><span class="line">		mid=(b+len)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;x) b=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> len=mid; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[b]&gt;=x?b<span class="number">-1</span>:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m=<span class="number">1</span>;<span class="comment">//m:f's length</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	f[<span class="number">0</span>]=-INF;f[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=bs(f,m,a[i]);</span><br><span class="line">		f[x+<span class="number">1</span>]=a[i];</span><br><span class="line">		m=max(m,x+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=6" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=6</a><br>有n件物品，第i件物品(I = 1,2,3…n)的价值是vi, 重量是wi,我们有一个能承重为m的背包，我们选择一些物品放入背包，显然放入背包的总重量不超过m。我们要求选择物品的总价值最大，请问如何选择？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> wi[<span class="number">105</span>],pi[<span class="number">105</span>],n,w,f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("yzhid.in", "r", stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;w);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;wi[i],&amp;pi[i]);</span><br><span class="line">	<span class="built_in">memset</span>(f+<span class="number">1</span>,-INF,MAX);</span><br><span class="line">	<span class="keyword">int</span> ans=-INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=w;j&gt;=wi[i];j--)&#123;</span><br><span class="line">			f[j]=max(f[j],f[j-wi[i]]+pi[i]);</span><br><span class="line">			ans=max(ans,f[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正整数分组"><a href="#正整数分组" class="headerlink" title="正整数分组"></a>正整数分组</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=7" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=7</a><br>将一堆正整数分为2组，要求2组的和相差最小。例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。 整数个数n&lt;=100，所有整数的和&lt;=10000<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX 10000+5</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],f[<span class="number">105</span>][MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sum/<span class="number">2</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;a[i])</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=a[i]&amp;&amp;j&lt;=sum/<span class="number">2</span>)</span><br><span class="line">				f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-a[i]]+a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> ans=(sum/<span class="number">2</span>-f[n][sum/<span class="number">2</span>])*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>) </span><br><span class="line">		ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>简单dp2</title>
    <url>/2018/07/11/%E7%AE%80%E5%8D%95dp2/</url>
    <content><![CDATA[<h3 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=8" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=8</a><br>一个M*N的矩阵，矩阵中有一些整数（有正有负），找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 500+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span>  a[MAX][MAX];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MAX][MAX],d[MAX],ans=-INF;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> m,n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">			f[i][j]=f[i<span class="number">-1</span>][j]+f[i][j<span class="number">-1</span>]-f[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">1</span>;h&lt;=m;h++)&#123;</span><br><span class="line">				<span class="keyword">long</span> <span class="keyword">long</span>  t=f[j][h]-f[i<span class="number">-1</span>][h]-f[j][h<span class="number">-1</span>]+f[i<span class="number">-1</span>][h<span class="number">-1</span>];</span><br><span class="line">				d[h]=max(d[h<span class="number">-1</span>]+t,t);</span><br><span class="line">				ans=max(ans,d[h]);</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="循环数组最大字段和"><a href="#循环数组最大字段和" class="headerlink" title="循环数组最大字段和"></a>循环数组最大字段和</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=9" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=9</a><br>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 50000+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> a[MAX];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ma=-INF,mi=INF,tmax=-INF,tmin=INF,sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		ma=max(ma,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>)+a[i];</span><br><span class="line">		tmax=max(tmax,ma);</span><br><span class="line">		mi=min(mi,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>)+a[i];</span><br><span class="line">		tmin=min(tmin,mi);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,max(sum-tmin,tmax));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=10" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=10</a><br>一个背包，承量有限为W，有n种物体，第i种物体，价值Vi，占用重量为 Wi，且有Ci件，选择物品若干放入背包，使得总重量不超过背包的承重。总价值最大？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 50000+5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,v;</span><br><span class="line"><span class="keyword">int</span> wi[<span class="number">105</span>],pi[<span class="number">105</span>],ci[<span class="number">105</span>];</span><br><span class="line">ll f[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(ll *f,<span class="keyword">int</span> c ,<span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=v;i&gt;=c;i--)</span><br><span class="line">		f[i]=max(f[i],f[i-c]+w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(ll *f,<span class="keyword">int</span> c ,<span class="keyword">int</span> w )</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=v;i++)</span><br><span class="line">		f[i]=max(f[i],f[i-c]+w);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(ll *f,<span class="keyword">int</span> c ,<span class="keyword">int</span> w ,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c*m&gt;v)&#123;</span><br><span class="line">		CompletePack(f, c ,w );</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k&lt;m)&#123;</span><br><span class="line">		ZeroOnePack(f, k*c ,k*w );</span><br><span class="line">		m-=k;</span><br><span class="line">		k*=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ZeroOnePack(f, m*c ,m*w );</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;v); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;wi[i],&amp;pi[i],&amp;ci[i]); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		MultiplePack(f,wi[i] ,pi[i] ,ci[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[v]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="更难的矩阵取数问题"><a href="#更难的矩阵取数问题" class="headerlink" title="更难的矩阵取数问题"></a>更难的矩阵取数问题</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=11" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=11</a><br>给定一个m行n列的矩阵，矩阵每个元素是一个正整数，你现在在左上角（第一行第一列），你需要走到右下角（第m行，第n列），每次只能朝右或者下走到相邻的位置，不能走出矩阵。然后再从右下角返回到左上角，这时只能朝上或者左走，两次如果经过同一个格子，则该数字只计算一次，所有走过的数的总和作为你的得分，求最大的得分。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000+10</span></span><br><span class="line"><span class="keyword">int</span> m,n,a[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line">ll  f[<span class="number">410</span>][<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;m,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=m+n<span class="number">-1</span>;step++)&#123;</span><br><span class="line">		<span class="keyword">int</span> start=step&gt;n?step-n+<span class="number">1</span>:<span class="number">1</span>,end=step&gt;m?m:step;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x1=start;x1&lt;=end;x1++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x2=start;x2&lt;=end;x2++)&#123;</span><br><span class="line">				<span class="keyword">int</span> t=max(f[step<span class="number">-1</span>][x1<span class="number">-1</span>][x2],max(f[step<span class="number">-1</span>][x1<span class="number">-1</span>][x2<span class="number">-1</span>],max(f[step<span class="number">-1</span>][x1][x2<span class="number">-1</span>],f[step<span class="number">-1</span>][x1][x2])));</span><br><span class="line">				<span class="keyword">if</span>(x1==x2)</span><br><span class="line">					f[step][x1][x2]=t+ a[step+<span class="number">1</span>-x1][x1] ;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					f[step][x1][x2]=t+ a[step+<span class="number">1</span>-x1][x1] + a[step+<span class="number">1</span>-x2][x2];</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[m+n<span class="number">-1</span>][m][m]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长单增子序列"><a href="#最长单增子序列" class="headerlink" title="最长单增子序列"></a>最长单增子序列</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=12" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=12</a><br>(LIS Longest Increasing Subsequence)给定一个数列，从中删掉任意若干项剩余的序列叫做它的一个子序列，求它的最长的子序列，满足子序列中的元素是单调递增的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 50000+5 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> a[MAX],f[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> len,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">0</span>,e=len,mid;</span><br><span class="line">	<span class="keyword">while</span>(b&lt;len)&#123;</span><br><span class="line">		mid=(b+len)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[mid]&lt;x) b=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> len=mid; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[b]&gt;=x?b<span class="number">-1</span>:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> n,m=<span class="number">1</span>;<span class="comment">//m:f's length</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	f[<span class="number">0</span>]=-INF;f[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x=bs(f,m,a[i]);</span><br><span class="line">		f[x+<span class="number">1</span>]=a[i];</span><br><span class="line">		m=max(m,x+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="子序列的个数"><a href="#子序列的个数" class="headerlink" title="子序列的个数"></a>子序列的个数</h3><p><a href="http://www.51nod.com/tutorial/course.html#!courseId=15" target="_blank" rel="noopener">http://www.51nod.com/tutorial/course.html#!courseId=15</a><br>给定一个正整数序列，序列中元素的个数和元素值大小都不超过105, 求其所有子序列的个数。注意相同的只算一次：例如 {1,2,1}有子序列{1} {2} {1,2} {2,1}和{1,2,1}。最后结果对10^9 + 7取余数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000+10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">int</span> a[MAX],h[MAX];</span><br><span class="line">ll d[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"yzhid.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	d[<span class="number">0</span>]=<span class="number">1</span>;h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		d[i]=(d[i<span class="number">-1</span>]*<span class="number">2</span>)%MOD;</span><br><span class="line">		<span class="keyword">if</span>(h[a[i]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			d[i]=(MOD+d[i]-d[h[a[i]]<span class="number">-1</span>])%MOD;	</span><br><span class="line">		&#125;</span><br><span class="line">		h[a[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,d[n]<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>背包[ emmmm ]</title>
    <url>/2020/03/01/%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>—– <a href="https://www.luogu.com.cn/blog/XTZORZ/pudong-dp" target="_blank" rel="noopener">天泽龟</a></p>
<a id="more"></a>
<h3 id="1、01-完全-多重-背包"><a href="#1、01-完全-多重-背包" class="headerlink" title="1、01 / 完全 / 多重 背包"></a><strong>1、01 / 完全 / 多重 背包</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zop</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//01 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=c;i--)</span><br><span class="line">		f[i]=max(f[i],f[i-c]+w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cp</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> w)</span></span>&#123; <span class="comment">//完全 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=n;i++)</span><br><span class="line">		f[i]=max(f[i],f[i-c]+w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mp</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> w,<span class="keyword">int</span> num)</span></span>&#123; <span class="comment">//多重 </span></span><br><span class="line">	<span class="keyword">if</span>(c*num&gt;=n) cp(c,w);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(k&lt;num)&#123;</span><br><span class="line">			zop(k*c,k*w);</span><br><span class="line">			num-=k;</span><br><span class="line">			k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		zop(num*c,num*w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、混合背包"><a href="#2、混合背包" class="headerlink" title="2、混合背包"></a><strong>2、混合背包</strong></h3><p>分开处理，<del>说着简单</del>…</p>
<h3 id="3、分组背包"><a href="#3、分组背包" class="headerlink" title="3、分组背包"></a><strong>3、分组背包</strong></h3><p>先枚举容量，再枚举每组的物品</p>
<p><img src="/.io//2.PNG" alt="feizu"></p>
<h3 id="4、二维费用背包"><a href="#4、二维费用背包" class="headerlink" title="4、二维费用背包"></a><strong>4、二维费用背包</strong></h3><p>碰到再说…</p>
<h3 id="5、依赖背包"><a href="#5、依赖背包" class="headerlink" title="5、依赖背包"></a><strong>5、依赖背包</strong></h3><p><a href="https://www.luogu.com.cn/problem/P1064" target="_blank" rel="noopener">金明的预算方案</a></p>
<p>直接放题解… <a href="https://www.luogu.com.cn/problemnew/solution/P1064?page=1" target="_blank" rel="noopener">题解</a></p>
<p>第一种方法 ：对于每种 主件+附件 共五种情况(本题)，枚举就行</p>
<p>第二种：背包九讲上关于依赖背包的方法。将每个主件和附件的集合看成一个物品组，可以先对主件及其附件集合进行一次 01 背包，得到费用一次为 $0…V - C_k$ 所有这些值时相应的最大价值 $F_k[0…V - C_k]$,那么这个主件及其附件集合相当于 $V - C_k + 1$个物品的物品组 ，其中费用为 $v$  的物品价值为  $F_k[v - C_k] + W_k$ ,$v$ 的取值范围是 $C_k \leq v \leq V$ 。</p>
<p>然后再用分组背包的做法。</p>
<p>另一种：<a href="https://www.luogu.com.cn/blog/colazcy/solution-p1064" target="_blank" rel="noopener">Solution [NOIP提高组2006]金明的预算方案</a> </p>
<h3 id="6、树形背包…"><a href="#6、树形背包…" class="headerlink" title="6、树形背包…"></a><strong><del>6、树形背包</del>…</strong></h3><p>待补…</p>
<h3 id="7、背包问题的变化"><a href="#7、背包问题的变化" class="headerlink" title="7、背包问题的变化"></a><strong>7、背包问题的变化</strong></h3><h4 id="1）打印方案"><a href="#1）打印方案" class="headerlink" title="1）打印方案"></a><strong>1）打印方案</strong></h4><p>我们设 $g[i][j]$表示当 $ f[i][j]$状态时的转移来源， $g[i][j]=0$即从 $ f[i-1][j]$ 转来的，$ g[i][j]=1$即从$ f[i-1][j-v[i]]$ 转移的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fd(i,n,<span class="number">0</span>)   <span class="comment">// 这里应和求背包时的顺序相反</span></span><br><span class="line">    <span class="keyword">if</span>(g[i][V])&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        V -= c[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）求方案数"><a href="#2）求方案数" class="headerlink" title="2）求方案数"></a><strong>2）求方案数</strong></h4><p>例题 1 ：<a href="https://www.luogu.com.cn/problem/P1164" target="_blank" rel="noopener">小A点菜</a></p>
<p>只需要把转移方程改成 $ f[j]=\sum_{i=0}^n (f[j−v[i]]+w[i])$  具体到就是 : </p>
<p>$f[i]=max(f[i],f[i-c]+w) \rightarrow f[i]=f[i]+f[i-c]$  , $f[0]=1$</p>
<p>例题 2 ：自然数累加问题</p>
<p>给定一个数 s ，在 1~to~n 中，求可累加任意数等于 s 的方案数。  </p>
<p>例题3：<a href="https://www.luogu.com.cn/problem/P1832" target="_blank" rel="noopener">P1832 A+B Problem（再升级）</a></p>
<p>给定一个正整数n，求将其分解成若干个素数之和的方案总数。</p>
<p>每个素数可以选若干次，如果可以。完全背包计数，正着计数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=c;i&lt;=n;i++)<span class="comment">//f[0]=1;</span></span><br><span class="line">	f[i]+=f[i-c];</span><br></pre></td></tr></table></figure>
<p>例题4：<a href="https://www.luogu.com.cn/problem/P1077" target="_blank" rel="noopener">P1077 摆花</a></p>
<p>看着像多重背包计数？其实不是，对于每一种花，只能选择一个数量，比如选择了三个，不能拆成 2 + 1，否则会重复计数。其实更像分组背包，只能选择其中一个固定的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>]=<span class="number">1l</span>l;</span><br><span class="line">fi(i,<span class="number">0</span>,n)</span><br><span class="line">fd(j,m+<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=a[i]&amp;&amp;k&lt;=j;k++)</span><br><span class="line">		f[j]+=f[j-k],f[j]%=MOD;</span><br></pre></td></tr></table></figure>
<h4 id="3）特定顺序的背包"><a href="#3）特定顺序的背包" class="headerlink" title="3）特定顺序的背包"></a>3）特定顺序的背包</h4><p>例题：<a href="https://www.luogu.com.cn/problem/P1417" target="_blank" rel="noopener">烹调方案</a></p>
<p>每件物品的价值和时间有关系。先排序后，套 01 背包。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>递归-排序</title>
    <url>/2018/03/01/%E9%80%92%E5%BD%92-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>在算法分析中，主定理（英语：master theorem）提供了用渐近符号（大O符号）表示许多由分治法得到的递推关系式的方法<br>递归式子中三种情况：大部分操作（消耗时间）运行在根节点上，叶节点上或递归树的各行之间。<br><a id="more"></a></p>
<h4 id="情形一"><a href="#情形一" class="headerlink" title="情形一"></a>情形一</h4><blockquote>
<p>如果存在常数  $\epsilon &gt;0$，有<br> $ f(n)=O\left(n^{\log _{b}(a)-\epsilon }\right) $ (多项式地小于）<br>那么<br> $ T(n)=\Theta \left(n^{\log _{b}a}\right) $</p>
</blockquote>
<h4 id="情形二"><a href="#情形二" class="headerlink" title="情形二"></a>情形二</h4><blockquote>
<p>如果存在常数 k ≥ 0，有<br>$ f(n)=\Theta \left(n^{\log _{b}a}\log ^{k}n\right)$<br>那么<br>$T(n)=\Theta \left(n^{\log _{b}a}\log ^{k+1}n\right)$</p>
</blockquote>
<h4 id="情形三"><a href="#情形三" class="headerlink" title="情形三"></a>情形三</h4><blockquote>
<p>如果存在常数$ \epsilon &gt;0$，有<br>$f(n)=\Omega \left(n^{\log _{b}(a)+\epsilon }\right)$（多项式地大于）<br>同时存在常数$ c&lt;1$以及充分大的 $n$，满足<br>$af\left(\frac  {n}{b}\right)\leq cf(n)$<br>那么<br>$T\left(n\right)=\Theta \left(f\left(n\right)\right)$</p>
</blockquote>
<h3 id="归纳-induction-、递归-recursion-及-归简-reduction"><a href="#归纳-induction-、递归-recursion-及-归简-reduction" class="headerlink" title="归纳(induction)、递归(recursion)及 归简(reduction)"></a>归纳(induction)、递归(recursion)及 归简(reduction)</h3><blockquote>
<p><strong>归简法</strong>是指将某一问题转换称另一个问题。如将一个未知问题转换称一个已解决问题。<br>   <strong>归纳法</strong>则用于证明某个语句对于大型对象类是否成立。<br>   <strong>递归法</strong>则用于函数自我调用时。</p>
</blockquote>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>在无序区查找最大元素放置最后，循环n次，复杂度$O(n^{2})$，稳定，$O(1)$。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">			<span class="keyword">if</span> seq[i]&lt;seq[j]:</span><br><span class="line">				seq[j],seq[i]=seq[i],seq[j]</span><br></pre></td></tr></table></figure></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p> $O(n^{2})$，对数组稳定（链表不稳定），$O(1)$。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sel_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">       max_j=i</span><br><span class="line">       <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">           <span class="keyword">if</span> seq[j]&gt;seq[max_j]: max_j=j</span><br><span class="line">       seq[i],seq[max_j]=seq[max_j],seq[i]</span><br></pre></td></tr></table></figure></p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>假设前 n-1 个数据已排好序，现在要将 n 插入到合适的位置（将无序区的元素插入到有序区的合适位置）。$O(n^{2})$，稳定，$O(1)$。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ins_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(seq)):</span><br><span class="line">       j=i</span><br><span class="line">       <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> seq[j<span class="number">-1</span>]&gt;seq[j]:</span><br><span class="line">           seq[j<span class="number">-1</span>],seq[j]=seq[j],seq[j<span class="number">-1</span>]</span><br><span class="line">           j-=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p> 将问题归简为两个相等子问题，依次递归。$O(n\log n)$，空间复杂度 $O(n)+O(\log n)$(从上往下)$O(1)$(从下往上),稳定。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(seq)</span>:</span></span><br><span class="line">   mid=len(seq)//<span class="number">2</span></span><br><span class="line">   lft,rgt=seq[:mid],seq[mid:]</span><br><span class="line">   <span class="keyword">if</span> len(lft)&gt;<span class="number">1</span>:lft=mergesort(lft)</span><br><span class="line">   <span class="keyword">if</span> len(rgt)&gt;<span class="number">1</span>:rgt=mergesort(rgt)</span><br><span class="line">   res=[]</span><br><span class="line">   <span class="keyword">while</span> lft <span class="keyword">and</span> rgt:</span><br><span class="line">       <span class="keyword">if</span> lft[<span class="number">-1</span>]&gt;=rgt[<span class="number">-1</span>]:</span><br><span class="line">           res.append(lft.pop())</span><br><span class="line">       <span class="keyword">else</span> :</span><br><span class="line">           res.append(rgt.pop())</span><br><span class="line">   res.reverse()</span><br><span class="line">   <span class="keyword">return</span> (lft <span class="keyword">or</span> rgt)+ res</span><br></pre></td></tr></table></figure></p>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>统计每一个数字出现的次数。 $O(n+m)$，稳定，$O(n+m)$。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(seq,key=lambda x:x)</span>:</span></span><br><span class="line">    B,C=[],defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> seq:</span><br><span class="line">        C[key(x)].append(x)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(min(C),max(C)+<span class="number">1</span>):</span><br><span class="line">        B.extend(C[k])</span><br><span class="line">    <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure></p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>  对数字的每一位进行排序。$O(k\times n)(平均) O(n^{2})(最坏)$，稳定，$O(n)$。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(seq,radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    K=int(math.ceil(math.log(max(seq)+<span class="number">1</span>,radix)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">        bucket=[[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> seq:</span><br><span class="line">            bucket[val%(radix**i)//(radix**(i<span class="number">-1</span>))].append(val)</span><br><span class="line">        <span class="keyword">del</span> seq[:]</span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> bucket:</span><br><span class="line">            seq.extend(each)</span><br></pre></td></tr></table></figure></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>  使用堆结构的性质。$O(n\log n)$，不稳定，$O(1)$。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">sift_down</span><span class="params">(start,end)</span>:</span></span><br><span class="line">       root=start</span><br><span class="line">       <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">           child=<span class="number">2</span>*root+<span class="number">1</span></span><br><span class="line">           <span class="keyword">if</span> child&gt;end:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           <span class="keyword">if</span> child+<span class="number">1</span>&lt;=end <span class="keyword">and</span> seq[child]&lt;seq[child+<span class="number">1</span>]:</span><br><span class="line">               child+=<span class="number">1</span></span><br><span class="line">           <span class="keyword">if</span> seq[root]&lt;seq[child]:</span><br><span class="line">               seq[root],seq[child]=seq[child],seq[root]</span><br><span class="line">               root=child</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">for</span> start <span class="keyword">in</span> range((len(seq)<span class="number">-2</span>)//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">       sift_down(start,len(seq)<span class="number">-1</span>)</span><br><span class="line">   <span class="keyword">for</span> end <span class="keyword">in</span> range(len(seq)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">       seq[<span class="number">0</span>],seq[end]=seq[end],seq[<span class="number">0</span>]</span><br><span class="line">       sift_down(<span class="number">0</span>,end<span class="number">-1</span>)</span><br><span class="line">   <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>  分解为两个子问题，时间代价主要在分解上，$left&lt;right$。$O(n\log n)(平均) O(n^{2})(最坏)$，不稳定，$O(\log n)$。<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(seq,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left&lt;right:</span><br><span class="line">        p=partition(seq,left,right)</span><br><span class="line">        quicksort(seq,left,p)</span><br><span class="line">        quicksort(seq,p+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(seq,lft,rgt)</span>:</span></span><br><span class="line">    pivot=seq[rgt<span class="number">-1</span>]</span><br><span class="line">    i=lft<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(lft,rgt):</span><br><span class="line">        <span class="keyword">if</span> seq[j]&lt;pivot:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            seq[i],seq[j]=seq[j],seq[i]</span><br><span class="line">    <span class="keyword">if</span> seq[rgt<span class="number">-1</span>]&lt;seq[i+<span class="number">1</span>]:</span><br><span class="line">        seq[i+<span class="number">1</span>],seq[rgt<span class="number">-1</span>]=seq[rgt<span class="number">-1</span>],seq[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p> 插入排序的进化版。 $O(n\log ^{2}n)(平均)      O(n^{2})(最坏)    $，不稳定，$O(1)$.<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n=len(seq)</span><br><span class="line">    gap=n//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,n):</span><br><span class="line">            temp=seq[i]</span><br><span class="line">            j=i</span><br><span class="line">            <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> seq[j-gap]&gt;temp:</span><br><span class="line">                seq[j]=seq[j-gap]</span><br><span class="line">                j-=gap</span><br><span class="line">            seq[j]=temp</span><br><span class="line">        gap=gap//<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure></p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p> 数据分为几组。组间有序，组内再排序。 $O(n)$，稳定，$O(m)$.<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(seq,n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    buckets=[[]<span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(seq)):</span><br><span class="line">        buckets[seq[i]//n].append(seq[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">        buckets[i]=mergesort(buckets[i])</span><br><span class="line">    <span class="keyword">del</span> seq[:]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> buckets:</span><br><span class="line">        seq.extend(x)</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</a></li>
<li>《python算法教程》 </li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
